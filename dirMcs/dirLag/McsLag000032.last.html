<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Mcs.lagoFrml-(McsLag000032.0-4-0.2023-10-17 draft) formal--human-language</title>
  <meta name="keywords" content="formal--human-language, lagoFrml, ModelConceptSensorial, McsHitp, Synagonism">
  <link rel="stylesheet" href="../Mcsmgr/mMcsh2.css">
</head>

<body>
<header id="idHeader">
  <p></p>
  <h1 id="idHeaderH1">formal--human-language
    <br>senso-concept-Mcs (lagoFrml)
    </h1>
  <p id="idHeadercrd">McsHitp-creation:: {2023-10-14}
    <a class="clsHide" href="#idHeadercrd"></a></p>
</header>

<section id="idOverview">
  <h1 id="idOverviewH1">overview of lagoFrml
    <a class="clsHide" href="#idOverviewH1"></a></h1>
  <p id="idDescription">description::
    <br>· a-formal-language is primarily syntactic, first defines its logo-domain.
    <br>· a-natural-language is primarily semantic, first defines its mind-domain.
    <br>[<a class="clsPreview" href="../dirHmn/McsHmn000003.last.html#idOverview">hmnSngo</a>.{2023-10-17}]
    <br>
    <br>"A language is formal if the syntax of the language is defined with sufficient precision that a computer could be programmed to check whether any particular sentence belongs to the language."
    <br>[{2023-10-17 retrieved} https://www.rbjones.com/rbjpub/logic/log001.htm]
    <br>
    <br>"In logic, mathematics, computer science, and linguistics, a formal language consists of words whose letters are taken from an alphabet and are well-formed according to a specific set of rules.
    <br>The alphabet of a formal language consists of symbols, letters, or tokens that concatenate into strings of the language.[1] Each string concatenated from symbols of this alphabet is called a word, and the words that belong to a particular formal language are sometimes called well-formed words or well-formed formulas. A formal language is often defined by means of a formal grammar such as a regular grammar or context-free grammar, which consists of its formation rules.
    <br>In computer science, formal languages are used among others as the basis for defining the grammar of programming languages and formalized versions of subsets of natural languages in which the words of the language represent concepts that are associated with meanings or semantics. In computational complexity theory, decision problems are typically defined as formal languages, and complexity classes are defined as the sets of the formal languages that can be parsed by machines with limited computational power. In logic and the foundations of mathematics, formal languages are used to represent the syntax of axiomatic systems, and mathematical formalism is the philosophy that all of mathematics can be reduced to the syntactic manipulation of formal languages in this way.
    <br>The field of formal language theory studies primarily the purely syntactical aspects of such languages—that is, their internal structural patterns. Formal language theory sprang out of linguistics, as a way of understanding the syntactic regularities of natural languages."
    <br>[{2023-08-30 retrieved} https://en.wikipedia.org/wiki/Formal_language]
    <a class="clsHide" href="#idDescription"></a></p>
  <p id="idName">name::
    <br>* McsEngl.McsLag000032.last.html//dirLag//dirMcs!⇒lagoFrml,
    <br>* McsEngl.dirLag/McsLag000032.last.html!⇒lagoFrml,
    <br>* McsEngl.formal--human-language!⇒lagoFrml,
    <br>* McsEngl.formal-language!⇒lagoFrml,
    <br>* McsEngl.lagoFrml,
    <br>* McsEngl.lagoFrml!=McsLag000032,
    <br>* McsEngl.lagoFrml!=formal--human-language,
    <br>* McsEngl.language.formal!⇒lagoFrml,
    <br>====== langoGreek:
    <br>* McsElln.γλώσσα-τυπική!η!=lagoFrml,
    <a class="clsHide" href="#idName"></a></p>
</section>

<section id="idLFrmlipt1">
  <h1 id="idLFrmlipt1H1">input1-(mind-view) of lagoFrml
    <a class="clsHide" href="#idLFrmlipt1H1"></a></h1>
  <p id="idLFrmlipt1dsn">description::
    <br>· a-system of mind-concepts.
    <a class="clsHide" href="#idLFrmlipt1dsn"></a></p>
  <p id="idLFrmlipt1nam">name::
    <br>* McsEngl.lagoFrml'mind-view,
    <a class="clsHide" href="#idLFrmlipt1nam"></a></p>

  <section id="idLFrmlipt1domn">
  <h2 id="idLFrmlipt1domnH2">mind-domain of lagoFrml
    <a class="clsHide" href="#idLFrmlipt1domnH2"></a></h2>
  <p id="idLFrmlipt1domndsn">description::
    <br>· mind-domain is the-set of mind-views.
    <a class="clsHide" href="#idLFrmlipt1domndsn"></a></p>
  <p id="idLFrmlipt1domnnam">name::
    <br>* McsEngl.lagoFrml'mind-domain,
    <br>* McsEngl.mind-domain@lagoFrml,
    <a class="clsHide" href="#idLFrmlipt1domnnam"></a></p>
  </section>
</section>

<section id="idLFrmlipt2">
  <h1 id="idLFrmlipt2H1">input2-(senso-mind-view) of lagoFrml
    <a class="clsHide" href="#idLFrmlipt2H1"></a></h1>
  <p id="idLFrmlipt2dsn">description::
    <br>·
    <a class="clsHide" href="#idLFrmlipt2dsn"></a></p>
  <p id="idLFrmlipt2nam">name::
    <br>* McsEngl.lagoFrml'senso-mind-view,
    <a class="clsHide" href="#idLFrmlipt2nam"></a></p>
</section>

<section id="idLFrmlipt3">
  <h1 id="idLFrmlipt3H1">input3-(semo-view) of lagoFrml
    <a class="clsHide" href="#idLFrmlipt3H1"></a></h1>
  <p id="idLFrmlipt3dsn">description::
    <br>·
    <a class="clsHide" href="#idLFrmlipt3dsn"></a></p>
  <p id="idLFrmlipt3nam">name::
    <br>* McsEngl.lagoFrml'semo-view,
    <a class="clsHide" href="#idLFrmlipt3nam"></a></p>
</section>

<section id="idLFrmlotpt">
  <h1 id="idLFrmlotptH1">output-(logo-view) of lagoFrml
    <a class="clsHide" href="#idLFrmlotptH1"></a></h1>
  <p id="idLFrmlotptdsn">description::
    <br>·
    <a class="clsHide" href="#idLFrmlotptdsn"></a></p>
  <p id="idLFrmlotptnam">name::
    <br>* McsEngl.lagoFrml'output,
    <a class="clsHide" href="#idLFrmlotptnam"></a></p>

  <section id="idLFrmlsmbl">
  <h2 id="idLFrmlsmblH2">symbol of lagoFrml
    <a class="clsHide" href="#idLFrmlsmblH2"></a></h2>
  <p id="idLFrmlsmbldsn">description::
    <br>· the-units.
    <a class="clsHide" href="#idLFrmlsmbldsn"></a></p>
  <p id="idLFrmlsmblnam">name::
    <br>* McsEngl.lagoFrml'letter,
    <br>* McsEngl.lagoFrml'symbol,
    <br>* McsEngl.lagoFrml'token,
    <br>* McsEngl.symbol@lagoFrml,
    <a class="clsHide" href="#idLFrmlsmblnam"></a></p>

  <section id="idLFrmlalbt">
  <h3 id="idLFrmlalbtH3">alphabet of lagoFrml
    <a class="clsHide" href="#idLFrmlalbtH3"></a></h3>
  <p id="idLFrmlalbtdsn">description::
    <br>"alphabet of formal-language:
    <br>The alphabet of a formal language is a set of symbols that can be used to construct strings in the language. The alphabet can be finite or infinite, but it is usually finite in most applications.
    <br>
    <br>For example, the alphabet of the programming language C is the set of all ASCII characters, except for the whitespace characters. The alphabet of the binary language is the set {0, 1}. The alphabet of the mathematical language is the set of all mathematical symbols, such as +, -, *, /, and x.
    <br>
    <br>The alphabet of a formal language is important because it defines the set of all possible strings that can be constructed in the language. It is also important for designing automata and grammars, which are used to parse and generate strings in the language.
    <br>
    <br>Here are some examples of alphabets of formal languages:
    <br>* Programming languages: ASCII characters, except for whitespace characters
    <br>* Binary language: {0, 1}
    <br>* Mathematical language: {+, -, *, /, x, ..., (, ), [, ], etc.}
    <br>* Chemical formulas: {C, H, O, N, S, etc.}
    <br>* Musical notation: {A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, 1, 2, 3, 4, etc.}
    <br>
    <br>These are just a few examples, and there are many other possible alphabets of formal languages. The specific alphabet used depends on the purpose of the formal language."
    <br>[{2023-10-14 retrieved} https://bard.google.com/chat/9e0d2f33a7b7460e]
    <a class="clsHide" href="#idLFrmlalbtdsn"></a></p>
  <p id="idLFrmlalbtnam">name::
    <br>* McsEngl.alphabet@lagoFrml,
    <br>* McsEngl.lagoFrml'alphabet,
    <a class="clsHide" href="#idLFrmlalbtnam"></a></p>
  </section>
  </section>

  <section id="idLFrmlword">
  <h2 id="idLFrmlwordH2">word of lagoFrml
    <a class="clsHide" href="#idLFrmlwordH2"></a></h2>
  <p id="idLFrmlworddsn">description::
    <br>·
    <a class="clsHide" href="#idLFrmlworddsn"></a></p>
  <p id="idLFrmlwordnam">name::
    <br>* McsEngl.lagoFrml'string,
    <br>* McsEngl.lagoFrml'word,
    <br>* McsEngl.word@lagoFrml,
    <a class="clsHide" href="#idLFrmlwordnam"></a></p>
  </section>

  <section id="idLFrmlwffl">
  <h2 id="idLFrmlwfflH2">well-formed-formula of lagoFrml
    <a class="clsHide" href="#idLFrmlwfflH2"></a></h2>
  <p id="idLFrmlwffldsn">description::
    <br>"well formed formula:
    <br>In logic and formal language theory, a well-formed formula (often abbreviated as "WFF" or "wff") is a syntactically valid expression that conforms to the rules and grammar of a formal language. Well-formed formulas are the building blocks of logical systems, such as propositional logic, predicate logic, and other mathematical and symbolic languages. They are used to represent statements, propositions, or predicates in a structured and unambiguous way. Here are some key characteristics of well-formed formulas:
    <br>
    <br>1. Syntax: Well-formed formulas adhere to the syntax rules of the specific logical or formal language in which they are expressed. These rules define how symbols, operators, and variables should be combined to create valid expressions. Any expression that violates the syntax rules is not considered a well-formed formula.
    <br>
    <br>2. Symbols and Variables: Well-formed formulas consist of a combination of symbols, operators, variables, and constants from the alphabet of the formal language. In propositional logic, for example, symbols might represent propositions or logical operators, while in predicate logic, variables can represent objects or individuals.
    <br>
    <br>3. Parentheses: In many formal languages, parentheses are used to specify the order of operations and to group elements within a well-formed formula. Ensuring the proper placement and balancing of parentheses is crucial to the formation of valid expressions.
    <br>
    <br>4. No Ambiguity: Well-formed formulas are unambiguous; their structure and meaning should be clear and unequivocal. There should be no room for interpretation or multiple possible readings.
    <br>
    <br>5. Meaning: While well-formed formulas specify the structure of an expression, they do not necessarily convey meaning on their own. The semantics of the language provide the interpretation and truth conditions for well-formed formulas.
    <br>
    <br>Examples of well-formed formulas in different logical systems:
    <br>1. In Propositional Logic:
    <br>   - p ∧ (q ∨ ¬r)
    <br>   - (p → q) ↔ (r ∨ s)
    <br>   - ¬(p ∧ q) ∨ (r → s)
    <br>
    <br>2. In First-Order Predicate Logic:
    <br>   - ∀x (P(x) → Q(x))
    <br>   - ∃y ∃z (R(y, z) ∧ S(x))
    <br>   - ¬(∀x R(x) → ∃y Q(y))
    <br>
    <br>3. In Set Theory:
    <br>   - {x | x is an even integer}
    <br>   - {y | y is a prime number}
    <br>   - ∅ (the empty set)
    <br>
    <br>In each of these examples, the expressions are well-formed because they follow the syntax and rules of the respective formal language.
    <br>
    <br>Well-formed formulas are essential for conducting rigorous and unambiguous reasoning, formal proofs, and mathematical modeling in various domains of mathematics, philosophy, computer science, and other disciplines. They serve as the foundation for symbolically representing and manipulating logical and mathematical concepts."
    <br>[{2023-10-14 retrieved} https://chat.openai.com/c/e8c2e8fa-fd4a-4726-bd0e-3f39ac871600]
    <a class="clsHide" href="#idLFrmlwffldsn"></a></p>
  <p id="idLFrmlwfflnam">name::
    <br>* McsEngl.WFF!=well-formed-formula,
    <br>* McsEngl.lagoFrml'sentence,
    <br>* McsEngl.lagoFrml'well-formed-formula,
    <br>* McsEngl.well-formed-formula@lagoFrml,
    <br>* McsEngl.sentence@lagoFrml,
    <a class="clsHide" href="#idLFrmlwfflnam"></a></p>
  </section>

  <section id="idLFrmlthry">
  <h2 id="idLFrmlthryH2">theory of lagoFrml
    <a class="clsHide" href="#idLFrmlthryH2"></a></h2>
  <p id="idLFrmlthrydsn">description::
    <br>"In mathematical logic, a theory (also called a formal theory) is a set of sentences in a formal language."
    <br>[{2023-10-14 retrieved} https://en.wikipedia.org/wiki/Theory_(mathematical_logic)]
    <a class="clsHide" href="#idLFrmlthrydsn"></a></p>
  <p id="idLFrmlthrynam">name::
    <br>* McsEngl.formal-theory,
    <br>* McsEngl.lagoFrml'theory,
    <br>* McsEngl.theory@lagoFrml,
    <a class="clsHide" href="#idLFrmlthrynam"></a></p>
  </section>

  <section id="idLFrmldomn">
  <h2 id="idLFrmldomnH2">domain of lagoFrml
    <a class="clsHide" href="#idLFrmldomnH2"></a></h2>
  <p id="idLFrmldomndsn">description::
    <br>· the-set of logo-views.
    <br>· logo-domain is what call 'formal-language' in logic, math, philosophy, formal-language-theory.
    <a class="clsHide" href="#idLFrmldomndsn"></a></p>
  <p id="idLFrmldomnnam">name::
    <br>* McsEngl.formal-language@FLTH,
    <br>* McsEngl.lagoFrml'domain,
    <br>* McsEngl.logo-domain@lagoFrml,
    <a class="clsHide" href="#idLFrmldomnnam"></a></p>
  </section>
</section>

<section id="idLFrmlrenc">
  <h1 id="idLFrmlrencH1">encoding-relation of lagoFrml
    <a class="clsHide" href="#idLFrmlrencH1"></a></h1>
  <p id="idLFrmlrencdsn">description::
    <br>·
    <a class="clsHide" href="#idLFrmlrencdsn"></a></p>
  <p id="idLFrmlrencnam">name::
    <br>* McsEngl.lagoFrml'encoding-relation,
    <a class="clsHide" href="#idLFrmlrencnam"></a></p>
</section>

<section id="idLFrmlrdcd">
  <h1 id="idLFrmlrdcdH1">decoding-relation-(interpretation) of lagoFrml
    <a class="clsHide" href="#idLFrmlrdcdH1"></a></h1>
  <p id="idLFrmlrdcddsn">description::
    <br>"interpretation of formal-language:
    <br>The interpretation of a formal language refers to the process of assigning meaning to the symbols, strings, or expressions within that language. Formal languages are abstract systems of symbols and rules for manipulating those symbols, often used in mathematics, computer science, and linguistics. They have clear and precise syntax and semantics, making them suitable for various applications, including programming languages and mathematical logic.
    <br>
    <br>Here are key aspects of interpreting a formal language:
    <br>1. Syntax: Formal languages have a well-defined syntax, which specifies the rules for constructing valid expressions or sentences. Syntax defines the structure of the language, including rules for symbol combinations, ordering, and grouping. Syntax defines what is grammatically correct within the language.
    <br>
    <br>2. Semantics: Semantics defines the meaning associated with the symbols and expressions in the formal language. It answers questions like, "What does a given expression represent or describe?" Semantics can be formalized in various ways, depending on the specific language. In some cases, semantics are provided through a mathematical model or a mapping to another, more easily interpretable language.
    <br>
    <br>3. Formalization: Formal languages are characterized by their precise, unambiguous rules. Interpretation of a formal language often involves mapping the expressions in the language to mathematical or logical structures to establish their meaning rigorously. This formalization ensures that there is no ambiguity in the interpretation.
    <br>
    <br>4. Types of Formal Languages: There are various types of formal languages, each with its own interpretation methods. These include:
    <br>   - Programming Languages: In programming languages, interpreters and compilers translate high-level source code into machine code or an intermediate language, making the computer understand and execute the instructions.
    <br>   - Mathematical Logic: Formal logic languages, such as propositional and predicate logic, involve interpreting expressions as logical statements and their truth values.
    <br>   - Regular and Context-Free Languages: These are types of formal languages used in automata theory and formal language theory. Interpretation may involve constructing finite automata, pushdown automata, or context-free grammars to recognize valid strings.
    <br>   - Natural Language Processing: In linguistics and natural language processing, formal languages are used to represent and interpret human languages. This interpretation involves understanding the meaning and structure of sentences, often through semantic analysis and parsing techniques.
    <br>
    <br>5. Interpretation Tools: Interpretation of formal languages may require specialized tools or algorithms, such as parsers, compilers, interpreters, and theorem provers, depending on the nature of the language and its application.
    <br>
    <br>In summary, interpreting a formal language involves understanding the syntax and semantics of the language's symbols and expressions in a precise and unambiguous manner. This interpretation is crucial for various fields, including computer science, mathematics, and linguistics, where formal languages are used to represent and manipulate information."
    <br>[{2023-10-17 retrieved} https://chat.openai.com/c/ccbd3472-109d-4ad1-b8c5-aa591c186ce6]
    <a class="clsHide" href="#idLFrmlrdcddsn"></a></p>
  <p id="idLFrmlrdcdnam">name::
    <br>* McsEngl.lagoFrml'decoding-relation,
    <br>* McsEngl.lagoFrml'interpretation,
    <a class="clsHide" href="#idLFrmlrdcdnam"></a></p>
  <p id="idLFrmlrdcddsnL">descriptionLong::
    <br>"An interpretation is an assignment of meaning to the symbols of a formal language. Many formal languages used in mathematics, logic, and theoretical computer science are defined in solely syntactic terms, and as such do not have any meaning until they are given some interpretation. The general study of interpretations of formal languages is called formal semantics.
    <br>
    <br>The most commonly studied formal logics are propositional logic, predicate logic and their modal analogs, and for these there are standard ways of presenting an interpretation. In these contexts an interpretation is a function that provides the extension of symbols and strings of symbols of an object language. For example, an interpretation function could take the predicate T (for "tall") and assign it the extension {a} (for "Abraham Lincoln"). Note that all our interpretation does is assign the extension {a} to the non-logical constant T, and does not make a claim about whether T is to stand for tall and 'a' for Abraham Lincoln. Nor does logical interpretation have anything to say about logical connectives like 'and', 'or' and 'not'. Though we may take these symbols to stand for certain things or concepts, this is not determined by the interpretation function.
    <br>
    <br>An interpretation often (but not always) provides a way to determine the truth values of sentences in a language. If a given interpretation assigns the value True to a sentence or theory, the interpretation is called a model of that sentence or theory."
    <br>[{2023-10-14 retrieved} https://en.wikipedia.org/wiki/Interpretation_(logic)]
    <a class="clsHide" href="#idLFrmlrdcddsnL"></a></p>

  <section id="idLFrmlmeng">
  <h2 id="idLFrmlmengH2">meaning of lagoFrml
    <a class="clsHide" href="#idLFrmlmengH2"></a></h2>
  <p id="idLFrmlmengdsn">description::
    <br>"meaning in formal-languages:
    <br>In the context of formal languages, "meaning" can have different interpretations depending on the specific formal language and context. Here are a few common interpretations:
    <br>
    <br>1. **Syntax and Semantics:** In formal languages, such as programming languages or mathematical notation, meaning often refers to the relationship between the syntax (the structure and rules of the language) and the semantics (the meaning or interpretation of the language). For example, in a programming language, the meaning of a statement or expression is what it does when executed. Understanding the meaning in this context is crucial for writing and analyzing programs.
    <br>
    <br>2. **Formal Logic:** In the context of formal logic and mathematical logic, meaning typically refers to the truth value or interpretation of a logical statement or formula. For example, in propositional logic, the meaning of a logical formula is whether it is true or false under a given assignment of truth values to its variables.
    <br>
    <br>3. **Natural Language Processing:** In the study of natural language processing and computational linguistics, meaning often relates to the interpretation of words, phrases, sentences, and texts in human languages. This can involve various levels of meaning, such as the denotative (literal) and connotative (emotional or contextual) meanings of words and phrases.
    <br>
    <br>4. **Automata Theory:** In automata theory and formal language theory, meaning may relate to the interpretation of strings or words in a formal language by automata or grammars. For instance, in a regular language, the meaning of a string is its acceptance or rejection by a finite automaton.
    <br>
    <br>5. **Model Theory:** In model theory, meaning is concerned with the relationships between formal languages and the mathematical structures they describe. Model theory explores how formal languages can be used to describe and reason about mathematical concepts and structures.
    <br>
    <br>In summary, the concept of "meaning" in formal languages depends on the specific domain and context in which it is used. It often pertains to the interpretation, semantics, and understanding of symbols, statements, or expressions within that particular formal language or system."
    <br>[{2023-10-17 retrieved} https://chat.openai.com/c/373d5f2c-c3c4-4dba-bf9b-28f1180d735a]
    <a class="clsHide" href="#idLFrmlmengdsn"></a></p>
  <p id="idLFrmlmengnam">name::
    <br>* McsEngl.lagoFrml'meaning,
    <a class="clsHide" href="#idLFrmlmengnam"></a></p>
  </section>
</section>

<section id="idLFrmlgrmr">
  <h1 id="idLFrmlgrmrH1">formal-grammar of lagoFrml
    <a class="clsHide" href="#idLFrmlgrmrH1"></a></h1>
  <p id="idLFrmlgrmrdsn">description::
    <br>· the-mapping-method (algorithm) of mapping-relations.
    <br>· in FLTH 'formal-grammar' is only the-syntactic-rules.
    <br>
    <br>"A formal grammar defines (or generates) a formal language, which is a (possibly infinite) set of sequences of symbols that may be constructed by applying production rules to a sequence of symbols which initially contains just the start symbol."
    <br>[http://en.wikipedia.org/wiki/Chomsky_hierarchy]
    <a class="clsHide" href="#idLFrmlgrmrdsn"></a></p>
  <p id="idLFrmlgrmrnam">name::
    <br>* McsEngl.lagoFrml'formal-grammar,
    <br>* McsEngl.lagoFrml'grammar,
    <a class="clsHide" href="#idLFrmlgrmrnam"></a></p>

  <section id="idLFrmlfrul">
  <h2 id="idLFrmlfrulH2">formation-rule of lagoFrml
    <a class="clsHide" href="#idLFrmlfrulH2"></a></h2>
  <p id="idLFrmlfruldsn">description::
    <br>"In mathematical logic, formation rules are rules for describing which strings of symbols formed from the alphabet of a formal language are syntactically valid within the language.[1] These rules only address the location and manipulation of the strings of the language. It does not describe anything else about a language, such as its semantics (i.e. what the strings mean). (See also formal grammar)."
    <br>[{2023-10-14 retrieved} https://en.wikipedia.org/wiki/Formation_rule]
    <a class="clsHide" href="#idLFrmlfruldsn"></a></p>
  <p id="idLFrmlfrulnam">name::
    <br>* McsEngl.lagoFrml'formation-rule,
    <br>* McsEngl.lagoFrml'production-rule,
    <a class="clsHide" href="#idLFrmlfrulnam"></a></p>
  </section>
</section>

<section id="idLFrmlrtcl">
  <h1 id="idLFrmlrtclH1">relation-to-constructed-language of lagoFrml
    <a class="clsHide" href="#idLFrmlrtclH1"></a></h1>
  <p id="idLFrmlrtcldsn">description::
    <br>"formal-language vs constructed-language:
    <br>Formal language and constructed language (conlang) are two distinct concepts in the field of linguistics and communication.
    <br>
    <br>1. Formal Language:
    <br>Formal languages are a specific type of language that are used in various fields, particularly in mathematics, computer science, and logic. They are characterized by a strict set of rules and syntax that dictate the structure and interpretation of the language. Formal languages are used to express abstract concepts precisely and are often used in technical or scientific contexts. Examples of formal languages include programming languages like Python, regular expressions used in pattern matching, and formal logic languages like propositional calculus and first-order logic.
    <br>
    <br>2. Constructed Language (Conlang):
    <br>Constructed languages, often abbreviated as conlangs, are languages that are intentionally created by individuals or groups for various purposes. Conlangs can serve a wide range of functions, including artistic, cultural, or practical purposes. They are not typically used for everyday communication, but rather for specific applications. Conlangs are intentionally designed, and their grammar, vocabulary, and phonology are constructed rather than evolving naturally over time. Some well-known examples of conlangs include J.R.R. Tolkien's Elvish languages (such as Quenya and Sindarin), the Klingon language from Star Trek, and the constructed language Esperanto, which was created to be a universal auxiliary language.
    <br>
    <br>In summary, the main difference between formal languages and constructed languages lies in their purpose and nature. Formal languages are abstract systems used for precise technical or mathematical communication, while constructed languages are intentionally created for various artistic, cultural, or practical reasons and are not typically used for everyday communication."
    <br>[{2023-10-14 retrieved} https://chat.openai.com/c/4b5543c7-f975-4c05-bd36-cba820e1c5ff]
    <a class="clsHide" href="#idLFrmlrtcldsn"></a></p>
  <p id="idLFrmlrtclnam">name::
    <br>* McsEngl.lagCnrd'relation-to-constructed-language,
    <br>* McsEngl.lagoFrml'relation-to-constructed-language,
    <a class="clsHide" href="#idLFrmlrtclnam"></a></p>
</section>

<section id="idLFrmlrtnl">
  <h1 id="idLFrmlrtnlH1">relation-to-natural-language of lagoFrml
    <a class="clsHide" href="#idLFrmlrtnlH1"></a></h1>
  <p id="idLFrmlrtnldsn">description::
    <br>"formal language vs natural language:
    <br>Formal language and natural language are two distinct types of communication systems used by humans and computers. They serve different purposes and have different characteristics:
    <br>Natural Language:
    <br>Natural language refers to the way humans communicate with each other using spoken or written words. It is the language we use in everyday conversations, literature, and communication. Natural language is rich, complex, and often ambiguous. It evolves over time and can convey not only factual information but also emotions, intentions, and cultural nuances. Examples of natural languages include English, Spanish, Chinese, and so on.
    <br>Key characteristics of natural language:
    <br>* Ambiguity: Natural language can often be interpreted in multiple ways due to its inherent ambiguity.
    <br>* Contextual: Meaning is often derived from the context in which words are used.
    <br>* Emotional Expression: Natural language can convey emotions, tone, and nuances.
    <br>* Evolution: Natural languages change and evolve over time due to cultural, social, and linguistic factors.
    <br>Formal Language:
    <br>Formal languages are designed for specific applications and typically lack the ambiguity of natural languages. They are used in mathematics, computer programming, logic, and scientific contexts. Formal languages have precise syntax and rules that govern their structure and interpretation. These languages are used to express complex ideas in a clear and unambiguous manner, making them suitable for communication between humans and computers.
    <br>Key characteristics of formal language:
    <br>* Precision: Formal languages have well-defined rules that eliminate ambiguity.
    <br>* Symbolic Representation: Formal languages often use symbols and notations that represent specific concepts.
    <br>* Limited Vocabulary: The vocabulary of a formal language is usually smaller and more focused.
    <br>* Rigidity: Formal languages adhere strictly to their defined rules and syntax.
    <br>Examples of formal languages include programming languages like Python, C++, and mathematical notation.
    <br>In summary, while natural language is the primary means of human communication, formal languages serve specialized purposes where precision, clarity, and unambiguous communication are essential. Natural languages are versatile and capable of expressing a wide range of concepts and emotions, while formal languages are designed to convey specific information with a high degree of accuracy."
    <br>[{2023-08-30 retrieved} https://chat.openai.com/]
    <a class="clsHide" href="#idLFrmlrtnldsn"></a></p>
  <p id="idLFrmlrtnlnam">name::
    <br>* McsEngl.lagoFrml'relation-to-natural-language,
    <br>* McsEngl.lagNtrl'relation-to-formal-language,
    <a class="clsHide" href="#idLFrmlrtnlnam"></a></p>
</section>

<section id="idLFrmlusag">
  <h1 id="idLFrmlusagH1">usage of lagoFrml
    <a class="clsHide" href="#idLFrmlusagH1"></a></h1>
  <p id="idLFrmlusagdsn">description::
    <br>"If you can describe a problem in a formally defined language then you may find a computer program which will be able to solve the problem for you."
    <br>[{2023-10-17 retrieved} https://www.rbjones.com/rbjpub/logic/log001.htm]
    <a class="clsHide" href="#idLFrmlusagdsn"></a></p>
  <p id="idLFrmlusagnam">name::
    <br>* McsEngl.lagoFrml'usage,
    <a class="clsHide" href="#idLFrmlusagnam"></a></p>
</section>

<section id="idLFrmlrscF">
  <h1 id="idLFrmlrscFH1">info-resource of lagoFrml
    <a class="clsHide" href="#idLFrmlrscFH1"></a></h1>
  <p id="idLFrmlrscwpa">addressWpg::
    <br>*
    <a class="clsHide" href="#idLFrmlrscwpa"></a></p>
  <p id="idLFrmlrscnam">name::
    <br>* McsEngl.lagoFrml'Infrsc,
    <a class="clsHide" href="#idLFrmlrscnam"></a></p>
</section>

<section id="idLFrmldngF">
  <h1 id="idLFrmldngFH1">DOING of lagoFrml
    <a class="clsHide" href="#idLFrmldngFH1"></a></h1>
  <p id="idLFrmldngdsn">description::
    <br>*
    <a class="clsHide" href="#idLFrmldngdsn"></a></p>
  <p id="idLFrmldngnam">name::
    <br>* McsEngl.lagoFrml'doing,
    <a class="clsHide" href="#idLFrmldngnam"></a></p>
</section>

<section id="idLFrmlevgF">
  <h1 id="idLFrmlevgFH1">evoluting of lagoFrml
    <a class="clsHide" href="#idLFrmlevgFH1"></a></h1>
  <p id="idLFrmlevgnam">name::
    <br>* McsEngl.evoluting-of-lagoFrml,
    <br>* McsEngl.lagoFrml'evoluting,
    <a class="clsHide" href="#idLFrmlevgnam"></a></p>
  <p id="idLFrmlevg20231014">{2023-10-14}::
    <br>=== McsHitp-creation:
    <br>· creation of current <a class="clsPreview" href="../dirTchInf/McsTchInf000009.last.html#idMcsHitp">concept</a>.
    <br>
    <br>"evolution of formal-languages"
    <br>The evolution of formal languages is closely tied to the development of computer science, mathematics, and linguistics. Formal languages are essential for specifying and describing various aspects of computation, communication, and reasoning. Here is a brief overview of the evolution of formal languages:
    <br>
    <br>1. Mathematical Notation (Pre-20th Century):
    <br>   - Formal languages have deep roots in mathematics, with symbols and notations used to represent mathematical concepts. Early algebraic notation and symbolic logic were precursors to more formalized languages.
    <br>
    <br>2. Formal Logic (19th Century):
    <br>   - The work of logicians like George Boole and Augustus De Morgan in the 19th century laid the foundation for formal logic, which is a crucial part of formal languages. Boole's algebraic logic and De Morgan's laws greatly influenced the development of formal languages.
    <br>
    <br>3. Automata Theory (20th Century):
    <br>   - The early 20th century saw the development of automata theory, which is central to the study of formal languages. Automata, such as finite automata and Turing machines, were introduced by Alonzo Church and Alan Turing, providing formal models for computation.
    <br>
    <br>4. Chomsky Hierarchy (1950s):
    <br>   - Noam Chomsky proposed a hierarchy of formal languages in the 1950s. He introduced four classes of grammars (Type 0 to Type 3) that are associated with different types of automata and languages. Chomsky's work was instrumental in understanding the structure of formal languages and their computational power.
    <br>
    <br>5. Regular Expressions (1950s):
    <br>   - The concept of regular expressions, introduced by Stephen Kleene in the 1950s, became a fundamental tool in string processing and text pattern matching. Regular expressions are a concise way to describe regular languages, which are the simplest class of formal languages.
    <br>
    <br>6. Context-Free Grammars (1960s):
    <br>   - Context-free grammars (CFGs) and pushdown automata, introduced by John Backus and Peter Naur, were essential for defining the syntax of programming languages. CFGs are widely used for specifying the structure of programming languages and compilers.
    <br>
    <br>7. Formal Language Theory and Linguistics:
    <br>   - The study of formal languages has also had a significant impact on linguistics. Linguists like Noam Chomsky used formal language theory to describe the syntax of natural languages, contributing to the development of generative grammars.
    <br>
    <br>8. Application in Computer Science:
    <br>   - Formal languages play a vital role in computer science, especially in the fields of compilers, formal verification, and automata-based algorithms. Regular expressions, context-free grammars, and other formal language constructs are used in software development and analysis.
    <br>
    <br>9. Programming Languages:
    <br>   - Programming languages themselves can be seen as formal languages. The development of various programming languages and their grammars has been a significant area of research in the field of formal languages.
    <br>
    <br>10. Quantum Computing and Beyond:
    <br>   - With the advent of quantum computing and new computational paradigms, the study of formal languages continues to evolve to adapt to these emerging technologies.
    <br>
    <br>The evolution of formal languages is ongoing as researchers explore new applications and extensions of formal language theory to address the challenges of modern computing and communication systems. It remains a fundamental and interdisciplinary field that underpins various aspects of science and technology."
    <br>[{2023-10-14 retrieved} https://chat.openai.com/c/9ade04b6-1074-4742-9927-a38a6d4d4df5]
    <br>
    <br>"evolution of formal-languages:
    <br>The evolution of formal languages can be traced back to the early 20th century, with the work of mathematicians and logicians such as Gottlob Frege, Bertrand Russell, and Alfred North Whitehead. Frege, in particular, was interested in developing a formal language that could be used to express the laws of logic and mathematics in a clear and unambiguous way.
    <br>
    <br>In the 1930s, the study of formal languages took a new turn with the work of Alan Turing and Emil Post. Turing developed a formal model of computation, known as the Turing machine, which could be used to simulate any other computational device. Post, meanwhile, developed a formal definition of a formal language, as a set of strings of symbols.
    <br>
    <br>Building on the work of Turing and Post, Noam Chomsky developed a hierarchy of formal languages in the 1950s and 1960s. The Chomsky hierarchy classifies formal languages according to their complexity, from the simplest (regular languages) to the most complex (recursive languages).
    <br>
    <br>Formal languages have found many applications in computer science, including:
    <br>* Programming languages: Formal languages are used to define the syntax of programming languages. This allows compilers and interpreters to parse and translate programs into machine code.
    <br>* Compilers and interpreters: Formal languages are used to describe the semantics of programming languages. This allows compilers and interpreters to generate correct machine code from programs.
    <br>* Operating systems: Formal languages are used to describe the syntax and semantics of operating system commands. This allows operating systems to parse and execute commands correctly.
    <br>* Databases: Formal languages are used to define the structure and constraints of databases. This allows databases to store and retrieve data efficiently.
    <br>* Natural language processing: Formal languages are used to develop algorithms for processing natural language text, such as machine translation and speech recognition.
    <br>
    <br>In recent years, the study of formal languages has expanded to include new areas such as formal semantics, formal verification, and program analysis. Formal semantics is concerned with the meaning of formal languages, while formal verification is concerned with proving that software and hardware systems meet their specifications. Program analysis is concerned with analyzing the behavior of programs without executing them.
    <br>
    <br>The evolution of formal languages has been driven by the need for precise and unambiguous ways to describe and reason about complex systems. Formal languages play an essential role in many areas of computer science, and their importance is likely to continue to grow in the future."
    <br>[{2023-10-14 retrieved} https://bard.google.com/chat/8c42eed2be99b7c5]
    <a class="clsHide" href="#idLFrmlevg20231014"></a></p>
</section>

<section id="idLFrmlpctF">
  <h1 id="idLFrmlpctFH1">PARENT-CHILD-TREE of lagoFrml
    <a class="clsHide" href="#idLFrmlpctFH1"></a></h1>
  <p id="idLFrmlptr">parent-tree-of-lagoFrml::
    <br>* ,
    <br>* McsEngl.lagoFrml'parent-tree,
    <a class="clsHide" href="#idLFrmlptr"></a></p>
  <p id="idLFrmlctr">child-tree-of-lagoFrml::
    <br>* ,
    <br>* McsEngl.lagoFrml'child-tree,
    <a class="clsHide" href="#idLFrmlctr"></a></p>
</section>

<section id="idLFrmlwptF">
  <h1 id="idLFrmlwptFH1">WHOLE-PART-TREE of lagoFrml
    <a class="clsHide" href="#idLFrmlwptFH1"></a></h1>
  <p id="idLFrmlwtr">whole-tree-of-lagoFrml::
    <br>* ,
    <br>* ... <a class="clsPreview" href="../dirCor/McsCor000003.last.html#idEntwtr">Sympan</a>.
    <br>* McsEngl.lagoFrml'whole-tree,
    <a class="clsHide" href="#idLFrmlwtr"></a></p>
  <p id="idLFrmlptr">part-tree-of-lagoFrml::
    <br>* ,
    <br>* McsEngl.lagoFrml'part-tree,
    <a class="clsHide" href="#idLFrmlptr"></a></p>
</section>

<section id="idLFrmlgstF">
  <h1 id="idLFrmlgstFH1">GENERIC-SPECIFIC-TREE of lagoFrml
    <a class="clsHide" href="#idLFrmlgstFH1"></a></h1>
  <p id="idLFrmlgtr">generic-tree-of-lagoFrml::
    <br>* ,
    <br>* ... <a class="clsPreview" href="../dirCor/McsCor000003.last.html#idOverview">entity</a>.
    <br>* McsEngl.lagoFrml'generic-tree,
    <a class="clsHide" href="#idLFrmlgtr"></a></p>
  <p id="idLFrmlstr">specific-tree-of-lagoFrml::
    <br>* ,
    <br>* McsEngl.lagoFrml.specific-tree,
    <a class="clsHide" href="#idLFrmlstr"></a></p>
</section>

<section id="idLFrmlExpl">
  <h1 id="idLFrmlExplH1">lagoFrml.example
    <a class="clsHide" href="#idLFrmlExplH1"></a></h1>
  <p id="idLFrmlExpldsn">description::
    <br>"The following rules describe a formal language L over the alphabet Σ = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, +, =}:
    <br>* Every nonempty string that does not contain "+" or "=" and does not start with "0" is in L.
    <br>* The string "0" is in L.
    <br>* A string containing "=" is in L if and only if there is exactly one "=", and it separates two valid strings of L.
    <br>* A string containing "+" but not "=" is in L if and only if every "+" in the string separates two valid strings of L.
    <br>* No string is in L other than those implied by the previous rules.
    <br>Under these rules, the string "23+4=555" is in L, but the string "=234=+" is not. This formal language expresses natural numbers, well-formed additions, and well-formed addition equalities, but it expresses only what they look like (their syntax), not what they mean (semantics). For instance, nowhere in these rules is there any indication that "0" means the number zero, "+" means addition, "23+4=555" is false, etc."
    <br>[{2023-10-17 retrieved} https://en.wikipedia.org/wiki/Formal_language#Examples]
    <a class="clsHide" href="#idLFrmlExpldsn"></a></p>
  <p id="idLFrmlExplnam">name::
    <br>* McsEngl.lagoFrml.example,
    <a class="clsHide" href="#idLFrmlExplnam"></a></p>
</section>

<section id="idLFrml003">
  <h1 id="idLFrml003H1">lagoFrml.first-order-logic (<a class="clsPreview" href="../dirTchInf/McsTchInf000007.last.html#idLCnkl014">link</a>)
    <a class="clsHide" href="#idLFrml003H1"></a></h1>
</section>

<section id="idLFrml005">
  <h1 id="idLFrml005H1">lagoFrml.recursively-enumerable
    <a class="clsHide" href="#idLFrml005H1"></a></h1>
  <p id="idLFrml005dsn">description::
    <br>"overview of recursively-enumerable-language:
    <br>A recursively enumerable language is a formal language classification within the Chomsky hierarchy, used to describe a set of languages with a very high degree of generative power. Here's an overview of recursively enumerable languages:
    <br>
    <br>1. Formal Definition: Recursively enumerable languages are defined using formal grammar rules and machines. A language L is considered recursively enumerable if it can be generated by a Turing machine that will eventually accept any string in the language, or it can be generated by a type-0 grammar, which is a more general and less restrictive formal grammar compared to context-sensitive grammars.
    <br>
    <br>2. Generative Power: Recursively enumerable languages are the most expressive class of languages in the Chomsky hierarchy. They can describe virtually any language or problem that can be computed algorithmically. This means that they can capture complex linguistic structures, non-terminating computations, and undecidable problems.
    <br>
    <br>3. Turing Machines: To recognize recursively enumerable languages, we typically use a Turing machine that operates with no restrictions on time or space. Unlike context-free languages, which can be recognized by a deterministic pushdown automaton, recursively enumerable languages may require non-deterministic or unbounded computation to recognize.
    <br>
    <br>4. Halting Problem: The halting problem, which is undecidable, is an example of a language that is recursively enumerable but not recursive (decidable). This problem asks whether a given Turing machine halts on a given input. Since there is no general algorithm to decide this problem for all possible inputs, it is an example of a recursively enumerable language that is not recursive.
    <br>
    <br>5. Limitations: While recursively enumerable languages have immense generative power, this power comes at a cost. Membership and decision problems for recursively enumerable languages may not always have algorithmic solutions. Decidability and computability in the context of recursively enumerable languages are essential concepts in theoretical computer science.
    <br>
    <br>6. Applications: Recursively enumerable languages find applications in various theoretical and computational fields, including the study of computability, formal language theory, and the analysis of undecidable problems. They are also used to explore the limits of computation and to establish the undecidability of various computational problems.
    <br>
    <br>In summary, recursively enumerable languages represent a class of languages that encompasses the most powerful and expressive languages within the Chomsky hierarchy. They can describe a wide range of problems and computations, including those that are undecidable. Recognizing such languages often involves the use of Turing machines with no resource constraints, making them a fundamental concept in the theory of computation."
    <br>[{2023-10-16 retrieved} https://chat.openai.com/c/b265236c-b05b-493e-90e7-c12afd957620]
    <a class="clsHide" href="#idLFrml005dsn"></a></p>
  <p id="idLFrml005nam">name::
    <br>* McsEngl.lagoFrml.005-recursively-enumerable,
    <br>* McsEngl.lagoFrml.recursively-enumerable,
    <br>* McsEngl.recursively-enumerable-language,
    <a class="clsHide" href="#idLFrml005nam"></a></p>
</section>

<section id="idLFrml004">
  <h1 id="idLFrml004H1">lagoFrml.context-sensitive
    <a class="clsHide" href="#idLFrml004H1"></a></h1>
  <p id="idLFrml004dsn">description::
    <br>"Context-Sensitive Languages: These languages are recognized by more powerful automata called linear-bounded automata and are used for representing complex syntax and semantics in programming languages."
    <br>[{2023-10-16 retrieved} https://chat.openai.com/c/bb5ddc26-bd11-414c-b3bb-5aaaebd0bc3c]
    <a class="clsHide" href="#idLFrml004dsn"></a></p>
  <p id="idLFrml004nam">name::
    <br>* McsEngl.context-sensitive-language,
    <br>* McsEngl.lagoFrml.004-context-sensitive,
    <br>* McsEngl.lagoFrml.context-sensitive,
    <a class="clsHide" href="#idLFrml004nam"></a></p>
  <p id="idLFrml004dsnL">descriptionLong::
    <br>"overview of context-sensitive-language:
    <br>A context-sensitive language is a formal language classification in the Chomsky hierarchy, which is a system for categorizing formal languages based on their generative power. Context-sensitive languages are one step more expressive than context-free languages and one step less expressive than recursively enumerable languages. Here's an overview of context-sensitive languages:
    <br>
    <br>1. Formal Definition: Context-sensitive languages are defined using formal grammar rules. A language L is considered context-sensitive if it can be generated by a context-sensitive grammar, which is a formal grammar with rules of the form α → β, where α and β are strings of symbols and |α| ≤ |β|, meaning that the replacement of α with β is sensitive to the surrounding context.
    <br>
    <br>2. Generative Power: Context-sensitive languages are more expressive than context-free languages, which are generated by context-free grammars. This means that context-sensitive languages can describe a wider range of languages and structures. They are capable of capturing certain linguistic phenomena that cannot be represented by context-free grammars.
    <br>
    <br>3. Linear Bounded Automata: Context-sensitive languages can be recognized by a computational device known as a linear bounded automaton (LBA). An LBA is a Turing machine with a tape that is limited in size to be proportional to the size of the input. This limitation ensures that the machine operates in a linear space, and it is powerful enough to recognize context-sensitive languages.
    <br>
    <br>4. Use Cases: Context-sensitive languages are often used to model natural languages, such as human languages, since they can represent linguistic features that involve long-distance dependencies and intricate grammatical structures. They are also used in the formal specification of programming languages and in certain aspects of compiler design.
    <br>
    <br>5. Complexity: Determining membership in a context-sensitive language is undecidable, which means there is no algorithm that can always determine whether a given string belongs to a context-sensitive language. This contrasts with context-free languages, where membership can be decided algorithmically.
    <br>
    <br>In summary, context-sensitive languages are a formal language class that sits between context-free languages and recursively enumerable languages in terms of generative power. They are characterized by their formal grammars and are recognized by linear bounded automata. They are important in the study of formal languages and have applications in areas like linguistics, programming language theory, and formal language processing."
    <br>[{2023-10-16 retrieved} https://chat.openai.com/c/b265236c-b05b-493e-90e7-c12afd957620]
    <a class="clsHide" href="#idLFrml004dsnL"></a></p>
</section>

<section id="idLFrml001">
  <h1 id="idLFrml001H1">lagoFrml.context-free
    <a class="clsHide" href="#idLFrml001H1"></a></h1>
  <p id="idLFrml001dsn">description::
    <br>"In formal language theory, a context-free language (CFL) is a language generated by a context-free grammar (CFG).
    <br>Context-free languages have many applications in programming languages, in particular, most arithmetic expressions are generated by context-free grammars."
    <br>[{2023-10-14 retrieved} https://en.wikipedia.org/wiki/Context-free_language]
    <a class="clsHide" href="#idLFrml001dsn"></a></p>
  <p id="idLFrml001nam">name::
    <br>* McsEngl.CFL!=context-free-language,
    <br>* McsEngl.context-free-language,
    <br>* McsEngl.lagoFrml.001-context-free,
    <br>* McsEngl.lagoFrml.context-free,
    <a class="clsHide" href="#idLFrml001nam"></a></p>
</section>

<section id="idLFrml002">
  <h1 id="idLFrml002H1">lagoFrml.regular
    <a class="clsHide" href="#idLFrml002H1"></a></h1>
  <p id="idLFrml002dsn">description::
    <br>"In theoretical computer science and formal language theory, a regular language (also called a rational language)[1][2] is a formal language that can be defined by a regular expression, in the strict sense in theoretical computer science (as opposed to many modern regular expression engines, which are augmented with features that allow the recognition of non-regular languages).
    <br>Alternatively, a regular language can be defined as a language recognized by a finite automaton. The equivalence of regular expressions and finite automata is known as Kleene's theorem[3] (after American mathematician Stephen Cole Kleene). In the Chomsky hierarchy, regular languages are the languages generated by Type-3 grammars."
    <br>[{2023-10-14 retrieved} https://en.wikipedia.org/wiki/Regular_language]
    <a class="clsHide" href="#idLFrml002dsn"></a></p>
  <p id="idLFrml002nam">name::
    <br>* McsEngl.rational-language,
    <br>* McsEngl.regular-language,
    <br>* McsEngl.lagoFrml.002-regular,
    <br>* McsEngl.lagoFrml.regular,
    <a class="clsHide" href="#idLFrml002nam"></a></p>
</section>

<section id="idLFrmlPrgm">
  <h1 id="idLFrmlPrgmH1">lagoFrml.programing-language (<a class="clsPreview" href="../dirTchInf/McsTchInf000006.last.html#idOverview">link</a>)
    <a class="clsHide" href="#idLFrmlPrgmH1"></a></h1>
</section>

<section id="idMeta">
  <h1 id="idMetaH1">meta-info
    <a class="clsHide" href="#idMetaH1"></a></h1>
  <p id="idMetaCounter" class="clsCenter">this WebPage was-visited
    <span class="clsColorRed">
    <script src="../../dirPgm/dirCntr/counter.php?page=McsLag000032"></script>
    </span>
    times since {2023-10-14}</p>
  <!-- the content of page-path paragraph is displayed as it is on top of toc -->
  <p id="idMetaWebpage_path"><span class="clsB clsColorGreen">page-wholepath</span>:
    <a class="clsPreview" href="../../#idOverview">synagonism.net</a> /
    <a class="clsPreview" href="../Mcs000000.last.html#idOverview">worldviewSngo</a> /
    <a class="clsPreview" href="../dirLag/McsLag000000.last.html#idOverview">dirLag</a> /
    lagoFrml
    </p>
  <p id="idMetaP1">SEARCH::
    <br>· this page uses '<span class="clsColorRed">locator-names</span>', names that when you find them, you find the-LOCATION of the-concept they denote.
    <br>⊛ <strong>GLOBAL-SEARCH</strong>:
    <br>· clicking on <span class="clsColorGreenBg">the-green-BAR of a-page</span> you have access to the-global--locator-names of my-site.
    <br>· use the-prefix '<span class="clsColorRed">lagoFrml</span>' for <a class="clsPreview" href="../dirCor/McsCor000002.last.html#idOverview">senso-concepts</a> related to current concept 'formal--human-language'.
    <br>⊛ <strong>LOCAL-SEARCH</strong>:
    <br>· TYPE <span class="clsColorRed">CTRL+F "McsLang.words-of-concept's-name"</span>, to go to the-LOCATION of the-concept.
    <br>· a-preview of the-description of a-global-name makes reading fast.
    <a class="clsHide" href="#idMetaP1"></a></p>
  <p id="idFooterP1">footer::
    <br>• author: <a class="clsPreview" href="../dirHmn/McsHmn000003.last.html#idOverview">Kaseluris.Nikos.1959</a>
    <br>• email:
    <br> &nbsp;<img src="../../dirRsc/dirImg/mail.png">
    <br>• edit on github: https://github.com/synagonism/McsWorld/blob/master/dirMcs/dirLag/McsLag000032.last.html,
    <br>• comments on <a class="clsPreview" href="../dirLag/McsLag000000.last.html#idComment">Disqus</a>,
    <br>• twitter: <a href="https://twitter.com/synagonism">@synagonism</a>,
    <a class="clsHide" href="#idFooterP1"></a></p>
  <p id="idMetaVersion">webpage-versions::
    <br>• version.last.dynamic: <a lass="clsPreview" href="McsLag000032.last.html">McsLag000032.last.html</a>,
    <br>• version.draft.creation: McsLag000032.0-1-0.2023-10-14.last.html,
    <a class="clsHide" href="#idMetaVersion"></a></p>
</section>

<section id="idSupport">
  <h1 id="idSupportH1">support (<a class="clsPreview" href="../../#idSupport">link</a>)</h1>
  <p></p>
</section>

<script type="module">
  import * as omMcsh from '../Mcsmgr/mMcsh2.js'
</script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-N8T0MHWLS1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-N8T0MHWLS1');
</script>
<!--   -->
</body>
</html>