<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Mcs.techCmpr-(McsTchInf000003.1-17-0.2024-01-25) technology.computer-machine</title>
  <meta name="keywords" content="computer-machine, techCmpr, ModelConceptStructured, McsHitp, Synagonism">
  <link rel="stylesheet" href="../Mcsmgr/mHitp.css">
</head>

<body>
<header id="idHeader">
  <p></p>
  <h1 id="idHeaderH1">computer-machine
    <br>senso-concept-Mcs (techCmpr)
    </h1>
  <p id="idHeadercrd">McsHitp-creation:: {2019-07-14},
    <a class="clsHide" href="#idHeadercrd"></a></p>
</header>

<section id="idOverview">
  <h1 id="idOverviewH1">overview of techCmpr
    <a class="clsHide" href="#idOverviewH1"></a></h1>
  <p id="idDescription">description::
    <br>· computer is an-info-machine that processes human and machine-information.
    <a class="clsHide" href="#idDescription"></a></p>
  <p id="idName">name::
    <br>* McsEngl.McsTchInf000003.last.html//dirTchInf//dirMcs!⇒techCmpr,
    <br>* McsEngl.dirMcs/dirTchInf/McsTchInf000003.last.html!⇒techCmpr,
    <br>* McsEngl.cmr!⇒techCmpr,
    <br>* McsEngl.cmpr!⇒techCmpr,
    <br>* McsEngl.computator!⇒techCmpr, {2023-08-23},
    <br>* McsEngl.computer!⇒techCmpr,
    <br>* McsEngl.computer-machine!⇒techCmpr,
    <br>* McsEngl.computer-system!⇒techCmpr,
    <br>* McsEngl.info-machine.computer!⇒techCmpr,
    <br>* McsEngl.informator!⇒techCmpr, {2023-08-23},
    <br>* McsEngl.machine.info.computer!⇒techCmpr,
    <br>* McsEngl.techCmpr,
    <br>* McsEngl.techCmpr!=McsTchInf000003,
    <br>* McsEngl.techCmpr!=computer-machine,
    <br>====== langoChinese:
    <br>* McsZhon.diànnǎo-电脑!=techCmpr::electric-brain,
    <br>* McsZhon.电脑-diànnǎo!=techCmpr::electric-brain,
    <br>* McsZhon.jìsuànjī-计算机!=techCmpr::calculating-machine,
    <br>* McsZhon.计算机-jìsuànjī!=techCmpr::calculating-machine, technical-formal,
    <br>====== langoGreek:
    <br>* McsElln.υπολογιστής!ο!=techCmpr,
    <br>====== langoTurkish:
    <br>* McsTurk.bilgisayar!=techCmpr,
    <a class="clsHide" href="#idName"></a></p>
</section>

<section id="idCmratt001">
  <h1 id="idCmratt001H1">01_hardware of techCmpr
    <a class="clsHide" href="#idCmratt001H1"></a></h1>
  <p id="idCmratt001dsn">description::
    <br>· hardware of computer\a\ is any physical, tangible part of it\a\.
    <a class="clsHide" href="#idCmratt001dsn"></a></p>
  <p id="idCmratt001nam">name::
    <br>* McsEngl.Cmrhardware,
    <br>* McsEngl.techCmpr'01_hardware!⇒Cmrhardware,
    <br>* McsEngl.techCmpr'att001-hardware!⇒Cmrhardware,
    <br>* McsEngl.techCmpr'hardware-att001!⇒Cmrhardware,
    <br>* McsEngl.techCmpr-hardware!⇒Cmrhardware,
    <br>* McsEngl.computer-hardware!⇒Cmrhardware,
    <br>* McsEngl.hardware-of-computer!⇒Cmrhardware,
    <br>====== langoChinese:
    <br>* McsZhon.yìngtǐ-硬体-(硬體)!=Cmrhardware,
    <br>* McsZhon.硬体-(硬體)-yìngtǐ!=Cmrhardware,
    <br>====== langoGreek:
    <br>* McsElln.υλικό-υπολογιστή!=Cmrhardware,
    <a class="clsHide" href="#idCmratt001nam"></a></p>

  <section id="idCmratt001Spc">
  <h2 id="idCmratt001SpcH2">hardware.SPECIFIC of techCmpr
    <a class="clsHide" href="#idCmratt001SpcH2"></a></h2>
  <p id="idCmratt001Spcdsn">description::
    <br>* processor-unit,
    <br>* storage-unit,
    <br>* input-unit,
    <br>* output-unit,
    <a class="clsHide" href="#idCmratt001Spcdsn"></a></p>
  <p id="idCmratt001Spcnam">name::
    <br>* McsEngl.Cmrhardware.specific,
    <a class="clsHide" href="#idCmratt001Spcnam"></a></p>
  </section>

  <section id="idCmrpcsr">
  <h2 id="idCmrpcsrH2">hardware.processor of techCmpr
    <a class="clsHide" href="#idCmrpcsrH2"></a></h2>
  <p id="idCmrpcsrdsn">description::
    <br>· processor of a-computer\a\ is its\a\ unit that performs the-info-processing task.
    <a class="clsHide" href="#idCmrpcsrdsn"></a></p>
  <p id="idCmrpcsrnam">name::
    <br>* McsEngl.techCmpr'processor!⇒techCmpr-processor,
    <br>* McsEngl.Cmrhardware.processor!⇒techCmpr-processor,
    <br>* McsEngl.techCmpr-processor,
    <br>* McsEngl.computer-processor!⇒techCmpr-processor,
    <br>* McsEngl.processor-of-computer!⇒techCmpr-processor,
    <br>====== langoChinese:
    <br>* McsZhon.chǔlǐqì-处理器-(處理器)!=techCmpr-processor,
    <br>* McsZhon.处理器-(處理器)-chǔlǐqì!=techCmpr-processor,
    <a class="clsHide" href="#idCmrpcsrnam"></a></p>

  <section id="idCmrpcsrSpc">
  <h3 id="idCmrpcsrSpcH3">processor.SPECIFIC of techCmpr
    <a class="clsHide" href="#idCmrpcsrSpcH3"></a></h3>
  <p id="idCmrpcsrSpcdsn">description::
    <br>· alphabetically:
    <br>* CPU – central processing unit,
    <br>* DSP – digital signal processor,
    <br>* GPU – graphics processing unit,
    <br>* ISP – image signal processor,
    <br>* NPU – neural processing unit,
    <br>* PPU – physics processing unit,
    <br>* SPU or SPE – synergistic processing element in Cell microprocessor,
    <br>* TPU – tensor processing unit,
    <br>* VPU – vision processing unit,
    <br>* FPGA – field-programmable gate array,
    <br>* general-purpose--CPU,
    <br>* general-purpose.no--CPU,
    <br>* integrated-circuit--CPU,
    <br>* mechanical-CPU,
    <br>* microprocessor,
    <br>* sound chip,
    <br>* transistor-CPU,
    <br>* vacuum-tube--CPU,
    <a class="clsHide" href="#idCmrpcsrSpcdsn"></a></p>
  <p id="idCmrpcsrSpcnam">name::
    <br>* McsEngl.techCmpr-processor.specific,
    <a class="clsHide" href="#idCmrpcsrSpcnam"></a></p>
  </section>

  <section id="idCmrpcsrCpu">
  <h3 id="idCmrpcsrCpuH3">processor.CPU of techCmpr
    <a class="clsHide" href="#idCmrpcsrCpuH3"></a></h3>
  <p id="idCmrpcsrCpudsn">description::
    <br>· computer-CPU is the-main processing unit of a-computer.
    <a class="clsHide" href="#idCmrpcsrCpudsn"></a></p>
  <p id="idCmrpcsrCpunam">name::
    <br>* McsEngl.CPU-of-computer!⇒techCmpr-Cpu,
    <br>* McsEngl.central-processing-unit--of-computer!⇒techCmpr-Cpu,
    <br>* McsEngl.techCmpr'CPU!⇒techCmpr-Cpu,
    <br>* McsEngl.techCmpr-Cpu,
    <br>* McsEngl.Cmrhardware.CPU!⇒techCmpr-Cpu,
    <br>* McsEngl.techCmpr-processor.CPU!⇒techCmpr-Cpu,
    <br>* McsEngl.computer-CPU!⇒techCmpr-Cpu,
    <a class="clsHide" href="#idCmrpcsrCpunam"></a></p>
  </section>

  <section id="idCmrpcsrCpuN">
  <h3 id="idCmrpcsrCpuNH3">processor.CPU.NO of techCmpr
    <a class="clsHide" href="#idCmrpcsrCpuNH3"></a></h3>
  </section>

  <section id="idCmrpcsrMcr">
  <h3 id="idCmrpcsrMcrH3">processor.microprocessor of techCmpr
    <a class="clsHide" href="#idCmrpcsrMcrH3"></a></h3>
  <p id="idCmrpcsrMcrdsn">description::
    <br>· a-microprocessor is one or more central-processing-units on a-single integrated-circuit.
    <a class="clsHide" href="#idCmrpcsrMcrdsn"></a></p>
  <p id="idCmrpcsrMcrnam">name::
    <br>* McsEngl.techCmpr-Cpu.microprocessor!⇒techCmpr-microprocessor,
    <br>* McsEngl.techCmpr-microprocessor,
    <br>* McsEngl.computer-microprocessor!⇒techCmpr-microprocessor,
    <br>* McsEngl.microprocessor-of-computer!⇒techCmpr-microprocessor,
    <a class="clsHide" href="#idCmrpcsrMcrnam"></a></p>
  </section>
  </section>

  <section id="idCmrmmr">
  <h2 id="idCmrmmrH2">hardware.memory of techCmpr
    <a class="clsHide" href="#idCmrmmrH2"></a></h2>
  <p id="idCmrmmrdsn">description::
    <br>· <span class="clsColorRed">techCmpr-memory</span> is hardware that stores software\a\ TEMPORARILY for processing and the-Cpu access it\a\ directly.
    <br>· you will-see to call it 'PRIMARY STORAGE'.
    <br><img src="McsTchInf000003.files/computer_storage_types.svg" style="width:70%">
    <br>[https://upload.wikimedia.org/wikipedia/commons/3/3e/Computer_storage_types.svg]
    <a class="clsHide" href="#idCmrmmrdsn"></a></p>
  <p id="idCmrmmrnam">name::
    <br>* McsEngl.Cpu-accessible--computer-storage!⇒Cmrmemory,
    <br>* McsEngl.Cmrmemory,
    <br>* McsEngl.techCmpr'memory!⇒Cmrmemory,
    <br>* McsEngl.techCmpr-memory!⇒Cmrmemory,
    <br>* McsEngl.computer-memory!⇒Cmrmemory,
    <br>* McsEngl.memory-of-computer!⇒Cmrmemory,
    <br>* McsEngl.primary-storage-of-computer!⇒Cmrmemory,
    <br>====== langoGreek:
    <br>* McsElln.μνήμη-υπολογιστή!=Cmrmemory,
    <a class="clsHide" href="#idCmrmmrnam"></a></p>

  <section id="idCmrmmrScdnCpu">
  <h3 id="idCmrmmrScdnCpuH3">memory.specifics-division.Cpu
    <a class="clsHide" href="#idCmrmmrScdnCpuH3"></a></h3>
  <p id="idCmrmmrScdnCpudsn">description::
    <br>· division on location: inside Cpu or not:
    <br>* <a class="clsPreview" href="#idCmrmmrInl">internal-memory</a>,
    <br>* <a class="clsPreview" href="#idCmrmmrInlN">internalNo-memory</a>,
    <a class="clsHide" href="#idCmrmmrScdnCpudsn"></a></p>
  <p id="idCmrmmrScdnCpunam">name::
    <br>* McsEngl.Cmrmemory.specifics-division.Cpu,
    <a class="clsHide" href="#idCmrmmrScdnCpunam"></a></p>
  </section>

  <section id="idCmrmmrInl">
  <h3 id="idCmrmmrInlH3">memory.internal of techCmpr
    <a class="clsHide" href="#idCmrmmrInlH3"></a></h3>
  <p id="idCmrmmrInldsn">description::
    <br>· internal-memory is <a class="clsPreview" href="#idCmrmmr">memory</a> inside <a class="clsPreview" href="#idCmrpcsrCpu">the-Cpu</a>.
    <a class="clsHide" href="#idCmrmmrInldsn"></a></p>
  <p id="idCmrmmrInlnam">name::
    <br>* McsEngl.techCmpr-internal-memory,
    <br>* McsEngl.Cmrmemory.internal!⇒techCmpr-internal-memory,
    <a class="clsHide" href="#idCmrmmrInlnam"></a></p>

  <section id="idCmrmmrInlCch">
  <h4 id="idCmrmmrInlCchH4">interal--Cpu-storage.cache of techCmpr
    <a class="clsHide" href="#idCmrmmrInlCchH4"></a></h4>
  <p id="idCmrmmrInlCchdsn">description::
    <br>"Processor cache is an intermediate stage between ultra-fast registers and much slower main memory. It was introduced solely to improve the performance of computers. Most actively used information in the main memory is just duplicated in the cache memory, which is faster, but of much lesser capacity. On the other hand, main memory is much slower, but has a much greater storage capacity than processor registers. Multi-level hierarchical cache setup is also commonly used—primary cache being smallest, fastest and located inside the processor; secondary cache being somewhat larger and slower."
    <br>[{2020-04-04} https://en.wikipedia.org/wiki/Computer_data_storage#Primary_storage]
    <a class="clsHide" href="#idCmrmmrInlCchdsn"></a></p>
  <p id="idCmrmmrInlCchnam">name::
    <br>* McsEngl.Cmrcache,
    <br>* McsEngl.cache-of-computer!⇒Cmrcache,
    <br>* McsEngl.techCmpr'cache!⇒Cmrcache,
    <br>* McsEngl.techCmpr-Cpu-cache!⇒Cmrcache,
    <br>* McsEngl.techCmpr-cache!⇒Cmrcache,
    <br>* McsEngl.techCmpr-internal-memory.cache!⇒Cmrcache,
    <br>* McsEngl.processor-cache!⇒Cmrcache,
    <a class="clsHide" href="#idCmrmmrInlCchnam"></a></p>
  </section>

  <section id="idCmrmmrInlRgr">
  <h4 id="idCmrmmrInlRgrH4">interal--Cpu-storage.register of techCmpr
    <a class="clsHide" href="#idCmrmmrInlRgrH4"></a></h4>
  <p id="idCmrmmrInlRgrdsn">description::
    <br>"Processor registers are located inside the processor. Each register typically holds a word of data (often 32 or 64 bits). CPU instructions instruct the arithmetic logic unit to perform various calculations or other operations on this data (or with the help of it). Registers are the fastest of all forms of computer data storage."
    <br>[https://en.wikipedia.org/wiki/Computer_data_storage#Primary_storage]
    <a class="clsHide" href="#idCmrmmrInlRgrdsn"></a></p>
  <p id="idCmrmmrInlRgrnam">name::
    <br>* McsEngl.Cmrregister,
    <br>* McsEngl.techCmpr'register!⇒Cmrregister,
    <br>* McsEngl.techCmpr-Cpu-register!⇒Cmrregister,
    <br>* McsEngl.techCmpr-register!⇒Cmrregister,
    <br>* McsEngl.techCmpr-internal-memory.register!⇒Cmrregister,
    <br>* McsEngl.processor-register!⇒Cmrregister,
    <a class="clsHide" href="#idCmrmmrInlRgrnam"></a></p>
  </section>
  </section>

  <section id="idCmrmmrInlN">
  <h3 id="idCmrmmrInlNH3">memory.internalNo of techCmpr
    <a class="clsHide" href="#idCmrmmrInlNH3"></a></h3>
  <p id="idCmrmmrInlNdsn">description::
    <br>· internalNo-memory is <a class="clsPreview" href="#idCmrmmr">memory</a> external to <a class="clsPreview" href="#idCmrpcsrCpu">Cpu</a>.
    <a class="clsHide" href="#idCmrmmrInlNdsn"></a></p>
  <p id="idCmrmmrInlNnam">name::
    <br>* McsEngl.CmrRam,
    <br>* McsEngl.RAM!⇒CmrRam,
    <br>* McsEngl.techCmpr'RAM!⇒CmrRam,
    <br>* McsEngl.techCmpr-RAM!⇒CmrRam,
    <br>* McsEngl.techCmpr-internalNo-memory!⇒CmrRam,
    <br>* McsEngl.Cmrmemory.internalNo!⇒CmrRam,
    <br>* McsEngl.main-memory-of-computer!⇒CmrRam,
    <a class="clsHide" href="#idCmrmmrInlNnam"></a></p>
  </section>
  </section>

  <section id="idCmrstrg">
  <h2 id="idCmrstrgH2">hardware.storage of techCmpr
    <a class="clsHide" href="#idCmrstrgH2"></a></h2>
  <p id="idCmrstrgdsn">description::
    <br>· storage of computer\a\ is <a class="clsPreview" href="#idCmratt001">hardware</a> that stores its\a\ <a class="clsPreview" href="#idCmratt002">software</a> PERMANENTLY.
    <br>"Secondary storage (also known as external memory or auxiliary storage), differs from primary storage in that it is not directly accessible by the CPU. The computer usually uses its input/output channels to access secondary storage and transfer the desired data to primary storage. Secondary storage is non-volatile (retaining data when power is shut off)."
    <br>[https://en.wikipedia.org/wiki/Computer_data_storage#Secondary_storage]
    <br><img src="McsTchInf000003.files/computer_storage_types.svg" style="width:70%">
    <br>[https://upload.wikimedia.org/wikipedia/commons/3/3e/Computer_storage_types.svg]
    <a class="clsHide" href="#idCmrstrgdsn"></a></p>
  <p id="idCmrstrgnam">name::
    <br>* McsEngl.Cmrstorage,
    <br>* McsEngl.techCmpr'storage!⇒Cmrstorage,
    <br>* McsEngl.Cmrhardware.storage!⇒Cmrstorage,
    <br>* McsEngl.techCmpr-storage!⇒Cmrstorage,
    <br>* McsEngl.primaryNo-storage-of-computer!⇒Cmrstorage,
    <br>* McsEngl.storage-of-computer!⇒Cmrstorage,
    <br>====== langoGreek:
    <br>* McsElln.αποθήκη-υπολογιστή!=Cmrstorage,
    <a class="clsHide" href="#idCmrstrgnam"></a></p>

  <section id="idCmrstrgSpc">
  <h3 id="idCmrstrgSpcH3">Cmrstorage.SPECIFIC
    <a class="clsHide" href="#idCmrstrgSpcH3"></a></h3>
  <p id="idCmrstrgSpcdsn">description::
    <br>· alphabetically:
    <br>* CD-drive,
    <br>* DVD-drive,
    <br>* USB-drive,
    <br>* floppy-disk,
    <br>* hard-disk-drive-(HDD),
    <br>* magnetic-tape,
    <br>* optical-storage,
    <br>* solid-state-drive-(SSD),
    <a class="clsHide" href="#idCmrstrgSpcdsn"></a></p>
  <p id="idCmrstrgSpcnam">name::
    <br>* McsEngl.techCmpr-CpuNo-storage.specific,
    <a class="clsHide" href="#idCmrstrgSpcnam"></a></p>
  <p id="idCmrstrgSpcwpa">addressWpg::
    <br>* https://twitter.com/historylvrsclub/status/1167893075126931460,
    <a class="clsHide" href="#idCmrstrgSpcwpa"></a></p>
  </section>

  <section id="idCmrstrgUsb">
  <h3 id="idCmrstrgUsbH3">Cmrstorage.USB-drive
    <a class="clsHide" href="#idCmrstrgUsbH3"></a></h3>
  <p id="idCmrstrgUsbdsn">description::
    <br>· TROUBLESHOOTING:
    <br>- open device-manager and add drive-letter.
    <a class="clsHide" href="#idCmrstrgUsbdsn"></a></p>
  <p id="idCmrstrgUsbnam">name::
    <br>* McsEngl.Cmrstorage.USB-drive,
    <br>* McsEngl.Cmrtroubleshooting.USB-drive-not-showing-up,
    <br>* McsEngl.USB-hard-disk,
    <a class="clsHide" href="#idCmrstrgUsbnam"></a></p>
  </section>
  </section>

  <section id="idCmrhdwrIn">
  <h2 id="idCmrhdwrInH2">hardware.input of techCmpr
    <a class="clsHide" href="#idCmrhdwrInH2"></a></h2>
  <p id="idCmrhdwrIndsn">description::
    <br>·
    <a class="clsHide" href="#idCmrhdwrIndsn"></a></p>
  <p id="idCmrhdwrInnam">name::
    <br>* McsEngl.Cmrhardware.input!⇒techCmpr-input-hardware,
    <br>* McsEngl.techCmpr-input-hardware,
    <br>* McsEngl.input-hardware-of-computer!⇒techCmpr-input-hardware,
    <a class="clsHide" href="#idCmrhdwrInnam"></a></p>
  </section>

  <section id="idCmrhdwrOut">
  <h2 id="idCmrhdwrOutH2">hardware.output of techCmpr
    <a class="clsHide" href="#idCmrhdwrOutH2"></a></h2>
  <p id="idCmrhdwrOutdsn">description::
    <br>·
    <a class="clsHide" href="#idCmrhdwrOutdsn"></a></p>
  <p id="idCmrhdwrOutnam">name::
    <br>* McsEngl.Cmrhardware.output!⇒techCmpr-output-hardware,
    <br>* McsEngl.techCmpr-output-hardware,
    <br>* McsEngl.output-hardware-of-computer!⇒techCmpr-output-hardware,
    <a class="clsHide" href="#idCmrhdwrOutnam"></a></p>
  </section>
</section>

<section id="idCmratt002">
  <h1 id="idCmratt002H1">02_software of techCmpr
    <a class="clsHide" href="#idCmratt002H1"></a></h1>
  <p id="idCmratt002dsn">description::
    <br>· software of computer\a\ is <a class="clsPreview" href="../dirCor/filMcs.last.html#idMcsattDvsnclmtPrt">the-part-complement</a> of <a class="clsPreview" href="#idCmratt001">hardware</a>, ie <a class="clsPreview" href="#idCmratt002Data">the-data</a> that it\a\ processes[b] and <a class="clsPreview" href="../dirTchInf/McsTchInf000006.last.html#idLagCpgmalg">the-algorithms</a> that uses to do it[b].
    <a class="clsHide" href="#idCmratt002dsn"></a></p>
  <p id="idCmratt002nam">name::
    <br>* McsEngl.techCmpr'02_software!⇒techCmpr-software,
    <br>* McsEngl.techCmpr'att002-software!⇒techCmpr-software,
    <br>* McsEngl.techCmpr'software!⇒techCmpr-software,
    <br>* McsEngl.techCmpr-software,
    <br>* McsEngl.computer-software!⇒techCmpr-software,
    <br>* McsEngl.information-of-computer!⇒techCmpr-software,
    <br>* McsEngl.software-of-computer!⇒techCmpr-software,
    <br>====== langoChinese:
    <br>* McsZhon.ruǎnjiàn-软件-(軟件)!=techCmpr-software,
    <br>* McsZhon.软件-(軟件)-ruǎnjiàn!=techCmpr-software,
    <a class="clsHide" href="#idCmratt002nam"></a></p>

  <section id="idCmratt002lag">
  <h2 id="idCmratt002lagH2">language (<a class="clsPreview" href="../dirTchInf/McsTchInf000005.last.html#idOverview">link</a>) of software of techCmpr
    <a class="clsHide" href="#idCmratt002lagH2"></a></h2>
  </section>

  <section id="idCmratt002Spc">
  <h2 id="idCmratt002SpcH2">software.SPECIFIC of techCmpr
    <a class="clsHide" href="#idCmratt002SpcH2"></a></h2>
  <p id="idCmratt002Spcdsn">description::
    <br>* data,
    <br>* <a class="clsPreview" href="../dirTchInf/McsTchInf000006.last.html#idLagCpgmalg">algorithm</a>,
    <a class="clsHide" href="#idCmratt002Spcdsn"></a></p>
  <p id="idCmratt002Spcnam">name::
    <br>* McsEngl.techCmpr-sotware.specific,
    <a class="clsHide" href="#idCmratt002Spcnam"></a></p>
  </section>

  <section id="idCmratt002Data">
  <h2 id="idCmratt002DataH2">software.data of techCmpr
    <a class="clsHide" href="#idCmratt002DataH2"></a></h2>
  <p id="idCmratt002Datadsn">description::
    <br>· data of computer is input or output information of a-computer.
    <a class="clsHide" href="#idCmratt002Datadsn"></a></p>
  <p id="idCmratt002Datanam">name::
    <br>* McsEngl.techCmpr'data!⇒techCmpr-data,
    <br>* McsEngl.techCmpr-data,
    <br>* McsEngl.techCmpr-software.data!⇒techCmpr-data,
    <br>* McsEngl.computer-data!⇒techCmpr-data,
    <br>* McsEngl.data-of-cmrdata!⇒techCmpr-data,
    <a class="clsHide" href="#idCmratt002Datanam"></a></p>
  </section>

  <section id="idCmratt002Inrn">
  <h2 id="idCmratt002InrnH2">software.algorithm (<a class="clsPreview" href="../dirTchInf/McsTchInf000006.last.html#idLagCpgmalg">link</a>) of techCmpr
    <a class="clsHide" href="#idCmratt002InrnH2"></a></h2>
  </section>
</section>

<section id="idCmratt003">
  <h1 id="idCmratt003H1">03_health-issue of techCmpr
    <a class="clsHide" href="#idCmratt003H1"></a></h1>
  <p id="idCmratt003nam">name::
    <br>* McsEngl.techCmpr'03_health-issue,
    <br>* McsEngl.techCmpr'att003-health-issue,
    <br>* McsEngl.techCmpr'health-issue-att003,
    <br>* McsEngl.techCmpr'health-issue,
    <br>* McsEngl.computer-induced-medical-problem,
    <br>* McsEngl.diseaseFrom-computer,
    <br>* McsEngl.disease.252-computer-induced,
    <br>* McsEngl.disease.computer-induced-252,
    <a class="clsHide" href="#idCmratt003nam"></a></p>
  <p id="idCmratt003dsn">description::
    <br>"Computer-induced health problems can be an umbrella term for the various problems a computer user can develop from extended and incorrect computer use. A computer user may experience many physical health problems from using computers extensively over a prolonged period of time in an inefficient manner. The computer user may have poor etiquette when using peripherals, for example incorrect posture. Reportedly, excessive use of electronic screen media can have ill effects on mental health related to mood, cognition, and behavior, even to the point of hallucination.[1]"
    <br>[https://en.wikipedia.org/wiki/Computer-induced_medical_problems]
    <a class="clsHide" href="#idCmratt003dsn"></a></p>
  <p id="idCmratt003str">specific-tree-of-diseaseFrom-computer::
    <br>* carpal-tunnel-syndrome-CTS,
    <br>* computer-mental-disorder,
    <br>* computer-musculoskeletal-disorder,
    <br>* computer-vision-syndrome,
    <br>* sleep-disorder,
    <a class="clsHide" href="#idCmratt003str"></a></p>
</section>

<section id="idCmratt004">
  <h1 id="idCmratt004H1">interface of techCmpr
    <a class="clsHide" href="#idCmratt004H1"></a></h1>
  <p id="idCmratt004dsn">description::
    <br>· "In computing, an interface is a shared boundary across which two or more separate components of a computer system exchange information. The exchange can be between software, computer hardware, peripheral devices, humans, and combinations of these.[1] Some computer hardware devices, such as a touchscreen, can both send and receive data through the interface, while others such as a mouse or microphone may only provide an interface to send data to a given system.[2]"
    <br>[{2023-08-02 retrieved} https://en.wikipedia.org/wiki/Interface_(computing)]
    <a class="clsHide" href="#idCmratt004dsn"></a></p>
  <p id="idCmratt004nam">name::
    <br>* McsEngl.Cmrinterface,
    <br>* McsEngl.techCmpr'att004-interface!⇒Cmrinterface,
    <br>* McsEngl.techCmpr'interface!⇒Cmrinterface,
    <a class="clsHide" href="#idCmratt004nam"></a></p>

  <section id="idCmratt004Hard">
  <h2 id="idCmratt004HardH2">Cmrinterface.hardware
    <a class="clsHide" href="#idCmratt004HardH2"></a></h2>
  <p id="idCmratt004Harddsn">description::
    <br>· "Hardware interfaces exist in many components, such as the various buses, storage devices, other I/O devices, etc. A hardware interface is described by the mechanical, electrical, and logical signals at the interface and the protocol for sequencing them (sometimes called signaling).[3] A standard interface, such as SCSI, decouples the design and introduction of computing hardware, such as I/O devices, from the design and introduction of other components of a computing system, thereby allowing users and manufacturers great flexibility in the implementation of computing systems.[3] Hardware interfaces can be parallel with several electrical connections carrying parts of the data simultaneously or serial where data are sent one bit at a time.[4]"
    <br>[{2023-08-02 retrieved} https://en.wikipedia.org/wiki/Interface_(computing)]
    <a class="clsHide" href="#idCmratt004Harddsn"></a></p>
  <p id="idCmratt004Hardnam">name::
    <br>* McsEngl.Cmrinterface.hardware,
    <br>* McsEngl.hardware-interface,
    <a class="clsHide" href="#idCmratt004Hardnam"></a></p>
  </section>

  <section id="idCmratt004Soft">
  <h2 id="idCmratt004SoftH2">Cmrinterface.software
    <a class="clsHide" href="#idCmratt004SoftH2"></a></h2>
  <p id="idCmratt004Softdsn">description::
    <br>· "A software interface may refer to a wide range of different types of interface at different "levels". For example, an operating system may interface with pieces of hardware. Applications or programs running on the operating system may need to interact via data streams, filters, and pipelines.[5] In object oriented programs, objects within an application may need to interact via methods.[6]"
    <br>[{2023-08-02 retrieved} https://en.wikipedia.org/wiki/Interface_(computing)]
    <a class="clsHide" href="#idCmratt004Softdsn"></a></p>
  <p id="idCmratt004Softnam">name::
    <br>* McsEngl.Cmrinterface.software,
    <br>* McsEngl.Softinterface,
    <br>* McsEngl.software-interface,
    <a class="clsHide" href="#idCmratt004Softnam"></a></p>

  <section id="idCmratt004SoftSpc">
  <h3 id="idCmratt004SoftSpcH3">Softinterface.SPECIFIC
    <a class="clsHide" href="#idCmratt004SoftSpcH3"></a></h3>
  <p id="idCmratt004SoftSpcdsn">description::
    <br>· ABI,
    <br>· API,
    <a class="clsHide" href="#idCmratt004SoftSpcdsn"></a></p>
  <p id="idCmratt004SoftSpcnam">name::
    <br>* McsEngl.Softinterface.specific,
    <a class="clsHide" href="#idCmratt004SoftSpcnam"></a></p>
  </section>

  <section id="idCmratt004SoftAbi">
  <h3 id="idCmratt004SoftAbiH3">Softinterface.ABI
    <a class="clsHide" href="#idCmratt004SoftAbiH3"></a></h3>
  <p id="idCmratt004SoftAbidsn">description::
    <br>· "In computer software, an application binary interface (ABI) is an interface between two binary program modules. Often, one of these modules is a library or operating system facility, and the other is a program that is being run by a user.
    <br>An ABI defines how data structures or computational routines are accessed in machine code, which is a low-level, hardware-dependent format. In contrast, an API defines this access in source code, which is a relatively high-level, hardware-independent, often human-readable format. A common aspect of an ABI is the calling convention, which determines how data is provided as input to, or read as output from, computational routines. Examples of this are the x86 calling conventions.
    <br>Adhering to an ABI (which may or may not be officially standardized) is usually the job of a compiler, operating system, or library author. However, an application programmer may have to deal with an ABI directly when writing a program in a mix of programming languages, or even compiling a program written in the same language with different compilers.
    <br>An ABI is as important as the underlying hardware architecture. The program will fail equally if it violates any constraints of these two."
    <br>[{2023-08-02 retrieved} https://en.wikipedia.org/wiki/Application_binary_interface]
    <a class="clsHide" href="#idCmratt004SoftAbidsn"></a></p>
  <p id="idCmratt004SoftAbinam">name::
    <br>* McsEngl.ABI!=application-binary-interface,
    <br>* McsEngl.Softinterface.ABI,
    <a class="clsHide" href="#idCmratt004SoftAbinam"></a></p>
  </section>
  </section>

  <section id="idCmratt004User">
  <h2 id="idCmratt004UserH2">Cmrinterface.user
    <a class="clsHide" href="#idCmratt004UserH2"></a></h2>
  <p id="idCmratt004Userdsn">description::
    <br>· "A user interface is a point of interaction between a computer and humans; it includes any number of modalities of interaction (such as graphics, sound, position, movement, etc.) where data is transferred between the user and the computer system."
    <br>[{2023-08-02 retrieved} https://en.wikipedia.org/wiki/Interface_(computing)]
    <a class="clsHide" href="#idCmratt004Userdsn"></a></p>
  <p id="idCmratt004Usernam">name::
    <br>* McsEngl.Cmrinterface.user,
    <br>* McsEngl.user-interface,
    <a class="clsHide" href="#idCmratt004Usernam"></a></p>
  </section>
</section>

<section id="idCmrrscF">
  <h1 id="idCmrrscFH1">04_resource of techCmpr
    <a class="clsHide" href="#idCmrrscFH1"></a></h1>
  <p id="idCmrrscnam">name::
    <br>* McsEngl.techCmpr'04_resource,
    <br>* McsEngl.techCmpr'attResource,
    <br>* McsEngl.techCmpr'Infrsc,
    <a class="clsHide" href="#idCmrrscnam"></a></p>
  <p id="idCmrrscwpa">addressWpg::
    <br>* https://waxy.org/2008/06/the_machine_that_changed_the_world_the_thinking_machine/,
    <a class="clsHide" href="#idCmrrscwpa"></a></p>
</section>

<section id="idCmrsrtr">
  <h1 id="idCmrsrtrH1">05_structure of techCmpr
    <a class="clsHide" href="#idCmrsrtrH1"></a></h1>
  <p id="idCmrsrtrnam">name::
    <br>* McsEngl.techCmpr'05_structure,
    <br>* McsEngl.techCmpr'attStructure,
    <br>* McsEngl.techCmpr'structure,
    <a class="clsHide" href="#idCmrsrtrnam"></a></p>
  <p id="idCmrsrtrdsn">description::
    <br>* hardware,
    <br>* software,
    <a class="clsHide" href="#idCmrsrtrdsn"></a></p>
</section>

<section id="idCmrdngF">
  <h1 id="idCmrdngFH1">06_DOING of techCmpr
    <a class="clsHide" href="#idCmrdngFH1"></a></h1>
  <p id="idCmrdngFnam">name::
    <br>* McsEngl.techCmpr'06_doing!⇒techCmpr-doing,
    <br>* McsEngl.techCmpr'attDoing!⇒techCmpr-doing,
    <br>* McsEngl.techCmpr'doing!⇒techCmpr-doing,
    <br>* McsEngl.techCmpr-doing,
    <a class="clsHide" href="#idCmrdngFnam"></a></p>

  <section id="idCmrdngSpc">
  <h2 id="idCmrdngSpcH2">doing.SPECIFIC of techCmpr
    <a class="clsHide" href="#idCmrdngSpcH2"></a></h2>
  <p id="idCmrdngSpcdsn">description::
    <br>* main-functing,
    <br>* <a class="clsPreview" href="#idCmrevgF">evoluting</a>,
    <a class="clsHide" href="#idCmrdngSpcdsn"></a></p>
  <p id="idCmrdngSpcnam">name::
    <br>* McsEngl.techCmpr-doing.specific,
    <a class="clsHide" href="#idCmrdngSpcnam"></a></p>
  </section>

  <section id="idCmrdngMnfg">
  <h2 id="idCmrdngMnfgH2">doing.main-functing of techCmpr
    <a class="clsHide" href="#idCmrdngMnfgH2"></a></h2>
  <p id="idCmrdngMnfgdsn">description::
    <br>· <span class="clsColorRed">computing</span> of techCmpr\a\ is any info-process it\a\ can-do.
    <a class="clsHide" href="#idCmrdngMnfgdsn"></a></p>
  <p id="idCmrdngMnfgnam">name::
    <br>* McsEngl.computation//techCmpr!⇒computing,
    <br>* McsEngl.computer-usage!⇒computing,
    <br>* McsEngl.computing, {2023-11-01},
    <br>* McsEngl.techCmpr'main-functing!⇒computing,
    <br>* McsEngl.techCmpr-doing.main-functing!⇒computing,
    <br>* McsEngl.techCmpr-usage!⇒computing,
    <a class="clsHide" href="#idCmrdngMnfgnam"></a></p>
  </section>

  <section id="idCmrdngClsd">
  <h2 id="idCmrdngClsdH2">doing.cloning-system-disk of techCmpr
    <a class="clsHide" href="#idCmrdngClsdH2"></a></h2>
  <p id="idCmrdngClsddsn">description::
    <br>· task: replace old SSD of 250MB with the-operating-system with another of 1TB because the-first was full, WITHOUT reinstalling the-system.
    <br>· on WINDOWS-10:
    <br>* install the-hardware.
    <br>* right-click on start and open 'Disk Management'.
    <br>* initialize the-disk with GPT partition style.
    <br>* install 'NIUBI Partition Editor Free Edition-(NPE)'
    <br>* execute 'Clone Disk Wizard' in NPE, and expand the-volume of data on all unallocated space in new disk (read the-help).
    <br>* on BIOS set the-new disk to boot first.
    <br>* do-not-add volumes after initialization.
    <br>* other 'free' programs (Macrium Reflect, AOMEI Backupper, MiniTool Partition Wizard) ask to pay to do most of these tasks.
    <br>* CloneZilla which needs a-live-Usb has no friedly user-interface and does-not-allocate the-new space.
    <a class="clsHide" href="#idCmrdngClsddsn"></a></p>
  <p id="idCmrdngClsdnam">name::
    <br>* McsEngl.cloning-system-disk-of-techCmpr,
    <br>* McsEngl.techCmpr'cloning-system-disk,
    <br>* McsEngl.techCmpr-doing.cloning-system-disk,
    <br>* McsEngl.replacing-system-disk-of-techCmpr,
    <br>====== langoGreek:
    <br>* McsElln.αντικατάσταση-δίσκου-συστήματος-υπολογιστή,
    <br>* McsElln.κλωνοποίηση-δίσκου-συστήματος-υπολογιστή,
    <a class="clsHide" href="#idCmrdngClsdnam"></a></p>
  </section>
</section>

<section id="idCmrevgF">
  <h1 id="idCmrevgFH1">07_EVOLUTING of techCmpr
    <a class="clsHide" href="#idCmrevgFH1"></a></h1>
  <p id="idCmrevgnam">name::
    <br>* McsEngl.techCmpr'07_evoluting,
    <br>* McsEngl.techCmpr'attEvoluting,
    <br>* McsEngl.evoluting-of-techCmpr,
    <br>* McsEngl.techCmpr'evoluting,
    <a class="clsHide" href="#idCmrevgnam"></a></p>

  <p id="idCmrevg1975">{1975}-techCmpr-portable-computer::
    <br>"A portable computer was a computer designed to be easily moved from one place to another and included a display and keyboard. The first commercially sold portable was the 50 pound IBM 5100, introduced 1975."
    <br>[https://en.wikipedia.org/wiki/Portable_computer]
    <br>* McsEngl.{science'1975}-techCmpr-portable-computer,
    <a class="clsHide" href="#idCmrevg195311"></a></p>

  <p id="idCmrevg1956">{1956}-techCmpr-operating-system::
    <br>"The first operating system used for real work was GM-NAA I/O, produced in 1956 by General Motors' Research division[ for its IBM 704."
    <br>[https://en.wikipedia.org/wiki/History_of_operating_systems#Mainframes]
    <br>* McsEngl.{science'1956}-operating-system,
    <a class="clsHide" href="#idCmrevg1956"></a></p>

  <p id="idCmrevg195311">{1953-11}-techCmpr-transistor-computer::
    <br>· the-first transistor-computer in the world, became operational in November 1953 at the-University-of-Manchester by a-team under the-leadersipt of Tom-Kilburn.
    <br>[https://en.wikipedia.org/wiki/Manchester_computers#Transistor_Computer]
    <br>* McsEngl.{science'1953-11}-techCmpr-transistor-computer,
    <a class="clsHide" href="#idCmrevg195311"></a></p>

  <p id="idCmrevg1948">{1948}-techCmpr-strored-program-computer::
    <br>"The Manchester Baby, also known as the Small-Scale Experimental Machine (SSEM), was the world's first electronic stored-program computer. It was built at the University of Manchester, England, by Frederic C. Williams, Tom Kilburn, and Geoff Tootill, and ran its first program on 21 June 1948,"
    <br>[https://en.wikipedia.org/wiki/Manchester_Baby]
    <br>* McsEngl.{science'1948}-techCmpr-strored-program-computer,
    <a class="clsHide" href="#idCmrevg1948"></a></p>

  <p id="idCmrevg1942">{1942}-techCmpr-electronic-binary-computer:
    <br>· the Atanasoff–Berry-computer (ABC) is the-first electronic binary but not program-controlled and not turing-complete.
    <br>[https://en.wikipedia.org/wiki/Atanasoff%E2%80%93Berry_computer]
    <br>* McsEngl.{science'1942}-techCmpr-electronic-binary-computer,
    <a class="clsHide" href="#idCmrevg1942"></a></p>

  <p id="idCmrevg1941">{1941}-techCmpr-elecromechanical-program-controlled-binary::
    <br>"The Z3 was a German electromechanical computer designed by Konrad Zuse. It was the world's first working programmable, fully automatic digital computer. The Z3 was built with 2,600 relays, implementing a 22-bit word length that operated at a clock frequency of about 4–5 Hz. Program code was stored on punched film. Initial values were entered manually."
    <br>[https://en.wikipedia.org/wiki/Z3_(computer)]
    <br>---
    <br>"In 1941 Konrad Zuse completed the Z3 (computer), the first working Turing-complete machine; this was the first digital computer in the modern sense."
    <br>[https://en.wikipedia.org/wiki/Turing_completeness]
    <br>* McsEngl.{science'1941}-techCmpr-elecromechanical-program-controlled-binary,
    <a class="clsHide" href="#idCmrevg1941"></a></p>

  <p id="idCmrevg1830s">{1840i10}-techCmpr-design-program-controlled-computer::
    <br>"The first design for a program-controlled computer was Charles Babbage's Analytical Engine in the 1830s."
    <br>[https://en.wikipedia.org/wiki/Manchester_Baby]
    <br>* McsEngl.{science'1840i10}-techCmpr-design-program-controlled-computer,
    <a class="clsHide" href="#idCmrevg1830s"></a></p>

  <p id="idCmrevgc100BC">{Bce0100≈}-techCmpr-first-analog::
    <br>=== Antikythera-mechanism first analog:
    <br>"The Antikythera mechanism is an ancient Greek analogue computer used to predict astronomical positions and eclipses for calendar and astrological purposes decades in advance. It could also be used to track the four-year cycle of athletic games which was similar to an Olympiad, the cycle of the ancient Olympic Games."
    <br>[https://en.wikipedia.org/wiki/Antikythera_mechanism]
    <br>* McsEngl.{science'Bce100≈}-techCmpr-first-analog,
    <a class="clsHide" href="#idCmrevgc100BC"></a></p>
</section>

<section id="idCmrwptF">
  <h1 id="idCmrwptFH1">WHOLE-PART-TREE of techCmpr
    <a class="clsHide" href="#idCmrwptFH1"></a></h1>
  <p id="idCmrwptnam">name::
    <br>* McsEngl.techCmpr'whole-part-tree,
    <a class="clsHide" href="#idCmrwptnam"></a></p>
  <p id="idCmrwtr">whole-tree-of-::
    <br>* household,
    <br>===
    <br>* computer-network,
    <a class="clsHide" href="#idCmrwtr"></a></p>
</section>

<section id="idCmrgstF">
  <h1 id="idCmrgstFH1">GENERIC-SPECIFIC-TREE of techCmpr
    <a class="clsHide" href="#idCmrgstFH1"></a></h1>
  <p id="idCmrgstFnam">name::
    <br>* McsEngl.techCmpr'generic-specific-tree,
    <a class="clsHide" href="#idCmrgstFnam"></a></p>
  <p id="idCmrgtr">generic-tree-of-::
    <br>* info-machine,
    <br>* machine,
    <br>...
    <br>* <a class="clsPreview" href="../dirCor/filMcsEnt.last.html#idOverview">entity</a>,
    <a class="clsHide" href="#idCmrgtr"></a></p>
  <p id="idCmrgstattihf">att-inherited-from::
    <br>*
    <a class="clsHide" href="#idCmrgstattihf"></a></p>
  <p id="idCmrgstattown">att-own-of-::
    <br>*
    <a class="clsHide" href="#idCmrgstattown"></a></p>

  <section id="idCmrSpc">
  <h2 id="idCmrSpcH2">techCmpr.SPECIFIC
    <a class="clsHide" href="#idCmrSpcH2"></a></h2>
  <p id="idCmrSpcnam">name::
    <br>* McsEngl.techCmpr.specific,
    <a class="clsHide" href="#idCmrSpcnam"></a></p>
  <p id="idCmrSpcP1">specific::
    <br>* analog-computer,
    <br>* binary-computer,
    <br>* digital-computer,
    <br>* mechanical-computer,
    <br>* transistor-computer,
    <br>* trinary-computer,
    <br>* quantum-computer,
    <a class="clsHide" href="#idCmrSpcP1"></a></p>
  <p id="idCmrSpcwpa">addressWpg::
    <br>* https://en.wikipedia.org/wiki/Category:Classes_of_computers,
    <a class="clsHide" href="#idCmrSpcwpa"></a></p>
  </section>
</section>

<section id="idCmrScdnDcd">
  <h1 id="idCmrScdnDcdH1">techCmpr.specifics-division.decade
    <a class="clsHide" href="#idCmrScdnDcdH1"></a></h1>
  <p id="idCmrScdnDcddsn">description::
    <br>· on 2010s:
    <br>* <a class="clsPreview" href="#idCmrMdrn2010s">modern2010s-computer</a>,
    <br>* old2010s-computer,
    <br>* future2010s-computer,
    <a class="clsHide" href="#idCmrScdnDcddsn"></a></p>
  <p id="idCmrScdnDcdnam">name::
    <br>* McsEngl.techCmpr.specifics-division.decade,
    <a class="clsHide" href="#idCmrScdnDcdnam"></a></p>
</section>

<section id="idCmrScdnHdwr">
  <h1 id="idCmrScdnHdwrH1">techCmpr.specifics-division.hardware
    <a class="clsHide" href="#idCmrScdnHdwrH1"></a></h1>
  <p id="idCmrScdnHdwrdsn">description::
    <br>· on hardware:
    <br>* mechanical-computer,
    <br>* electro-mechanical-computer,
    <br>* electronic-computer:,
    <br>* electronic.vacuum-tube--computer,
    <br>* electronic.transistor-computer,
    <br>* electronic.microchip-computer,
    <a class="clsHide" href="#idCmrScdnHdwrdsn"></a></p>
  <p id="idCmrScdnHdwrnam">name::
    <br>* McsEngl.techCmpr.specifics-division.hardware,
    <a class="clsHide" href="#idCmrScdnHdwrnam"></a></p>

  <section id="idCmrMchl">
  <h2 id="idCmrMchlH2">techCmpr.mechanical
    <a class="clsHide" href="#idCmrMchlH2"></a></h2>
  <p id="idCmrMchldsn">description::
    <br>"A mechanical computer is built from mechanical components such as levers and gears, rather than electronic components. The most common examples are adding machines and mechanical counters, which use the turning of gears to increment output displays."
    <br>[https://en.wikipedia.org/wiki/Mechanical_computer]
    <a class="clsHide" href="#idCmrMchldsn"></a></p>
  <p id="idCmrMchlnam">name::
    <br>* McsEngl.techCmpr.mechanical!⇒cmrMechanical,
    <br>* McsEngl.cmrMechanical,
    <a class="clsHide" href="#idCmrMchlnam"></a></p>
  </section>

  <section id="idCmrErml">
  <h2 id="idCmrErmlH2">techCmpr.electro-mechanical
    <a class="clsHide" href="#idCmrErmlH2"></a></h2>
  <p id="idCmrErmldsn">description::
    <br>· electro-mechanical--computer is a-computer with electric-switches that drive mechanical-relays to perform computations.
    <a class="clsHide" href="#idCmrErmldsn"></a></p>
  <p id="idCmrErmlnam">name::
    <br>* McsEngl.techCmpr.electro-mechanical,
    <br>* McsEngl.electro-mechanical--computer,
    <br>* McsEngl.relay-computer,
    <a class="clsHide" href="#idCmrErmlnam"></a></p>
  <p id="idCmrErmlwpa">addressWpg::
    <br>* https://en.wikipedia.org/wiki/Category:Electro-mechanical_computers,
    <a class="clsHide" href="#idCmrErmlwpa"></a></p>
  </section>

  <section id="idCmrElrc">
  <h2 id="idCmrElrcH2">techCmpr.electronic
    <a class="clsHide" href="#idCmrElrcH2"></a></h2>
  <p id="idCmrElrcdsn">description::
    <br>· electronic-computer is a-computer that uses electronic components such as vacuum-tubes, transistors, microchips.
    <a class="clsHide" href="#idCmrElrcdsn"></a></p>
  <p id="idCmrElrcnam">name::
    <br>* McsEngl.techCmpr.electronic,
    <br>* McsEngl.electronic-computer,
    <a class="clsHide" href="#idCmrElrcnam"></a></p>
  </section>

  <section id="idCmrVmtb">
  <h2 id="idCmrVmtbH2">techCmpr.vacuum-tube
    <a class="clsHide" href="#idCmrVmtbH2"></a></h2>
  <p id="idCmrVmtbdsn">description::
    <br>"Vacuum tube computers, now termed first generation computers, are programmable digital computers using vacuum tube logic circuitry. They were preceded by systems using electromechanical relays and followed by systems built from discrete transistors."
    <br>[https://en.wikipedia.org/wiki/List_of_vacuum_tube_computers]
    <a class="clsHide" href="#idCmrVmtbdsn"></a></p>
  <p id="idCmrVmtbnam">name::
    <br>* McsEngl.techCmpr.vacuum-tube!⇒cmrVtube,
    <br>* McsEngl.cmrVtube,
    <br>* McsEngl.first-generation-computer!⇒cmrVtube,
    <br>* McsEngl.tube-computer!⇒cmrVtube,
    <br>* McsEngl.vacuum-tube-computer!⇒cmrVtube,
    <a class="clsHide" href="#idCmrVmtbnam"></a></p>

  <section id="idCmrVmtbrsc">
  <h3 id="idCmrVmtbrscH3">info-resource of cmrVtube
    <a class="clsHide" href="#idCmrVmtbrscH3"></a></h3>
  <p id="idCmrVmtbrscnam">name::
    <br>* McsEngl.cmrVtube'Infrsc,
    <a class="clsHide" href="#idCmrVmtbrscnam"></a></p>
  <p id="idCmrVmtbrscwpa">addressWpg::
    <br>* https://en.wikipedia.org/wiki/Vacuum_tube_computer,
    <br>* https://en.wikipedia.org/wiki/List_of_vacuum_tube_computers,
    <a class="clsHide" href="#idCmrVmtbrscwpa"></a></p>
  </section>

  <section id="idCmrVmtbevg">
  <h3 id="idCmrVmtbevgH3">EVOLUTING of cmrVtube
    <a class="clsHide" href="#idCmrVmtbevgH3"></a></h3>
  <p id="idCmrVmtbevgnam">name::
    <br>* McsEngl.evoluting-of-cmrVtube,
    <br>* McsEngl.cmrVtube'evoluting,
    <a class="clsHide" href="#idCmrVmtbevgnam"></a></p>
  <p id="idCmrVmtbevg1942">{1942}::
    <br>=== Atanasoff-Berry-computer:
    <br>"The Atanasoff–Berry computer (ABC) was the first automatic electronic digital computer, an early electronic digital computing device that has remained somewhat obscure. The ABC's priority is debated among historians of computer technology, because it was neither programmable, nor Turing-complete.
    <br>Conceived in 1937, the machine was built by Iowa State College mathematics and physics professor John Vincent Atanasoff with the help of graduate student Clifford Berry. It was designed only to solve systems of linear equations and was successfully tested in 1942."
    <br>[https://en.wikipedia.org/wiki/Atanasoff%E2%80%93Berry_computer]
    <a class="clsHide" href="#idCmrVmtbevg1942"></a></p>
  <p id="idCmrVmtbevg1939">{1939}::
    <br>=== Atanasoff-Berry-computer-prototype:
    <br>"The Atanasoff–Berry computer, a prototype of which was first demonstrated in 1939, is now credited as the first vacuum tube computer. However it was not a general-purpose computer being able to only solve a system of linear equations and it was also not very reliable."
    <br>[{2014-06-01} https://en.wikipedia.org/wiki/Vacuum_tube_computer]
    <a class="clsHide" href="#idCmrVmtbevg1939"></a></p>
  </section>
  </section>

  <section id="idCmrTrtr">
  <h2 id="idCmrTrtrH2">techCmpr.transistor
    <a class="clsHide" href="#idCmrTrtrH2"></a></h2>
  <p id="idCmrTrtrdsn">description::
    <br>"A transistor computer, now often called a second generation computer,[1] is a computer which uses discrete transistors instead of vacuum tubes. The first generation of electronic computers used vacuum tubes, which generated large amounts of heat, were bulky and unreliable. A second generation of computers, through the late 1950s and 1960s featured circuit boards filled with individual transistors and magnetic core memory. These machines remained the mainstream design into the late 1960s, when integrated circuits started appearing and led to the third-generation machines."
    <br>[https://en.wikipedia.org/wiki/Transistor_computer]
    <a class="clsHide" href="#idCmrTrtrdsn"></a></p>
  <p id="idCmrTrtrnam">name::
    <br>* McsEngl.techCmpr.transistor,
    <br>* McsEngl.second-generation--computer,
    <br>* McsEngl.transistor-computer,
    <br>* McsEngl.transistorized-computer,
    <a class="clsHide" href="#idCmrTrtrnam"></a></p>
  <p id="idCmrTrtrwpa">addressWpg::
    <br>* https://en.wikipedia.org/wiki/List_of_transistorized_computers,
    <a class="clsHide" href="#idCmrTrtrwpa"></a></p>
  </section>

  <section id="idCmrChip">
  <h2 id="idCmrChipH2">techCmpr.integrated-circuit
    <a class="clsHide" href="#idCmrChipH2"></a></h2>
  <p id="idCmrChipdsn">description::
    <br>· integrated-circuit--computer is an-electronic-computer that uses integrated-circuits.
    <a class="clsHide" href="#idCmrChipdsn"></a></p>
  <p id="idCmrChipnam">name::
    <br>* McsEngl.IC-computer!⇒cmrChip,
    <br>* McsEngl.techCmpr.microchip!⇒cmrChip,
    <br>* McsEngl.cmrChip,
    <br>* McsEngl.integrated-circuit--computer!⇒cmrChip,
    <a class="clsHide" href="#idCmrChipnam"></a></p>

  <section id="idCmrChipSpc">
  <h3 id="idCmrChipSpcH3">cmrChip.SPECIFIC
    <a class="clsHide" href="#idCmrChipSpcH3"></a></h3>
  <p id="idCmrChipSpcdsn">description::
    <br>· on CPU:
    <br>* LSI-CPU--computer,
    <br>* SSI-CPU--computer,
    <br>* microprocessor-computer,
    <a class="clsHide" href="#idCmrChipSpcdsn"></a></p>
  <p id="idCmrChipSpcnam">name::
    <br>* McsEngl.cmrChip.specific,
    <a class="clsHide" href="#idCmrChipSpcnam"></a></p>
  </section>

  <section id="idCmrChipMrpr">
  <h3 id="idCmrChipMrprH3">cmrChip.microprocessor
    <a class="clsHide" href="#idCmrChipMrprH3"></a></h3>
  <p id="idCmrChipMrprdsn">description::
    <br>· microprocessor-computer is a-chip-computer with one <a class="clsPreview" href="#idCmrpcsrMcr">microprocessor</a> as CPU.
    <a class="clsHide" href="#idCmrChipMrprdsn"></a></p>
  <p id="idCmrChipMrprnam">name::
    <br>* McsEngl.techCmpr.microprocessor!⇒cmrMicroprocessor,
    <br>* McsEngl.cmrChip.microprocessor!⇒cmrMicroprocessor,
    <br>* McsEngl.microcomputer!⇒cmrMicroprocessor,
    <br>* McsEngl.microprocessor-computer!⇒cmrMicroprocessor,
    <a class="clsHide" href="#idCmrChipMrprnam"></a></p>
  <p id="idCmrChipMrprwpa">addressWpg::
    <br>* https://en.wikipedia.org/wiki/Microcomputer,
    <br>* https://en.wikipedia.org/wiki/Lists_of_microcomputers,
    <a class="clsHide" href="#idCmrChipMrprwpa"></a></p>
  </section>
  </section>

  <section id="idCmrSoc">
  <h2 id="idCmrSocH2">techCmpr.SoC
    <a class="clsHide" href="#idCmrSocH2"></a></h2>
  <p id="idCmrSocdsn">description::
    <br>"A system on a chip or system on chip is an integrated circuit (also known as a "chip") that integrates all components of a computer or other electronic system. These components typically (but not always) include a central processing unit (CPU), memory, input/output ports and secondary storage – all on a single substrate or microchip, the size of a coin. It may contain digital, analog, mixed-signal, and often radio frequency signal processing functions, depending on the application."
    <br>[https://en.wikipedia.org/wiki/System_on_a_chip]
    <a class="clsHide" href="#idCmrSocdsn"></a></p>
  <p id="idCmrSocnam">name::
    <br>* McsEngl.SoC-computer!⇒cmrOnchip,
    <br>* McsEngl.techCmpr.system-on-chip!⇒cmrOnchip,
    <br>* McsEngl.cmrOnchip,
    <a class="clsHide" href="#idCmrSocnam"></a></p>
  </section>
  </section>
</section>

<section id="idCmrScdnPgm">
  <h1 id="idCmrScdnPgmH1">techCmpr.specifics-division.program
    <a class="clsHide" href="#idCmrScdnPgmH1"></a></h1>
  <p id="idCmrScdnPgmdsn">description::
    <br>· if they are-controlled with <a class="clsPreview" href="../dirTchInf/McsTchInf000006.last.html#idLagCpgmalgPgm">a-program</a> or not:
    <br>* programable-computer,
    <br>* programableNo-computer,
    <a class="clsHide" href="#idCmrScdnPgmdsn"></a></p>
  <p id="idCmrScdnPgmnam">name::
    <br>* McsEngl.techCmpr.specifics-division.program,
    <a class="clsHide" href="#idCmrScdnPgmnam"></a></p>

  <section id="idCmrPgml">
  <h2 id="idCmrPgmlH2">techCmpr.programable
    <a class="clsHide" href="#idCmrPgmlH2"></a></h2>
  <p id="idCmrPgmldsn">description::
    <br>· programable-computer is a-computer which it is-controlled by <a class="clsPreview" href="../dirTchInf/McsTchInf000006.last.html#idLagCpgmalgPgm">a-program</a>.
    <a class="clsHide" href="#idCmrPgmldsn"></a></p>
  <p id="idCmrPgmlnam">name::
    <br>* McsEngl.techCmpr.programable,
    <br>* McsEngl.program-controlled--computer,
    <br>* McsEngl.programable-computer,
    <a class="clsHide" href="#idCmrPgmlnam"></a></p>
  <p id="idCmrPgmlSpc">specific::
    <br>* stored-program--programable-computer,
    <br>* stored-program.no--programable-computer,
    <a class="clsHide" href="#idCmrPgmlSpc"></a></p>

  <section id="idCmrPgmlStrd">
  <h3 id="idCmrPgmlStrdH3">techCmpr.stored-program programable-computer
    <a class="clsHide" href="#idCmrPgmlStrdH3"></a></h3>
  <p id="idCmrPgmlStrddsn">description::
    <br>"A stored-program computer is a computer that stores program instructions in electronic memory. This contrasts with machines where the program instructions are stored on plugboards or similar mechanisms."
    <br>[https://en.wikipedia.org/wiki/Stored-program_computer]
    <a class="clsHide" href="#idCmrPgmlStrddsn"></a></p>
  <p id="idCmrPgmlStrdnam">name::
    <br>* McsEngl.stored-program--programable-computer,
    <a class="clsHide" href="#idCmrPgmlStrdnam"></a></p>
  </section>

  <section id="idCmrPgmlStrdN">
  <h3 id="idCmrPgmlStrdNH3">techCmpr.stored-program.no programable-computer
    <a class="clsHide" href="#idCmrPgmlStrdNH3"></a></h3>
  <p id="idCmrPgmlStrdNdsn">description::
    <br>"Early computers such as the ENIAC had to be physically rewired to perform different tasks, which caused these machines to be called "fixed-program computers". Since the term "CPU" is generally defined as a device for software (computer program) execution, the earliest devices that could rightly be called CPUs came with the advent of the stored-program computer."
    <br>[https://en.wikipedia.org/wiki/Central_processing_unit]
    <a class="clsHide" href="#idCmrPgmlStrdNdsn"></a></p>
  <p id="idCmrPgmlStrdNnam">name::
    <br>* McsEngl.fixed-program--computer,
    <br>* McsEngl.stored-program.no--programable-computer,
    <a class="clsHide" href="#idCmrPgmlStrdNnam"></a></p>
  </section>
  </section>

  <section id="idCmrPgmlN">
  <h2 id="idCmrPgmlNH2">techCmpr.programableNo
    <a class="clsHide" href="#idCmrPgmlNH2"></a></h2>
  <p id="idCmrPgmlNdsn">description::
    <br>· programableNo-computer is a-computer which it is-NOT-controlled by <a class="clsPreview" href="../dirTchInf/McsTchInf000006.last.html#idLagCpgmalgPgm">a-program</a>.
    <a class="clsHide" href="#idCmrPgmlNdsn"></a></p>
  <p id="idCmrPgmlNnam">name::
    <br>* McsEngl.techCmpr.programableNo,
    <br>* McsEngl.programableNo-computer,
    <a class="clsHide" href="#idCmrPgmlNnam"></a></p>
  </section>
</section>

<section id="idCmrScdnOs">
  <h1 id="idCmrScdnOsH1">techCmpr.specifics-division.Os
    <a class="clsHide" href="#idCmrScdnOsH1"></a></h1>
  <p id="idCmrScdnOsdsn">description::
    <br>· division on if has <a class="clsPreview" href="../dirTchInf/McsTchInf000006.last.html#idLpgOs">operating-system</a>:
    <br>* Os-techCmpr,
    <br>* OsNo-techCmpr,
    <a class="clsHide" href="#idCmrScdnOsdsn"></a></p>
  <p id="idCmrScdnOsnam">name::
    <br>* McsEngl.techCmpr.specifics-division.Os,
    <a class="clsHide" href="#idCmrScdnOsnam"></a></p>

  <section id="idCmrOs">
  <h2 id="idCmrOsH2">techCmpr.Os
    <a class="clsHide" href="#idCmrOsH2"></a></h2>
  <p id="idCmrOsdsn">description::
    <br>· Os-computer is <a class="clsPreview" href="#idOverview">a-computer</a> WITH <a class="clsPreview" href="../dirTchInf/McsTchInf000006.last.html#idLpgOs">an-operating-system</a>.
    <br>==
    <br>"The first operating system used for real work was GM-NAA I/O, produced in 1956 by General Motors' Research division for its IBM 704."
    <br>[https://en.wikipedia.org/wiki/History_of_operating_systems#Mainframes]    <a class="clsHide" href="#idCmrOsdsn"></a></p>
  <p id="idCmrOsnam">name::
    <br>* McsEngl.Os-computer!⇒cmrOs,
    <br>* McsEngl.techCmpr.Os!⇒cmrOs,
    <br>* McsEngl.cmrOs,
    <br>* McsEngl.operating-system--computer!⇒cmrOs,
    <a class="clsHide" href="#idCmrOsnam"></a></p>
  </section>

  <section id="idCmrOsN">
  <h2 id="idCmrOsNH2">techCmpr.OsNo
    <a class="clsHide" href="#idCmrOsNH2"></a></h2>
  <p id="idCmrOsNdsn">description::
    <br>· OsNo-computer is <a class="clsPreview" href="#idOverview">a-computer</a> WITHOUT <a class="clsPreview" href="../dirTchInf/McsTchInf000006.last.html#idLpgOs">an-operating-system</a>.
    <a class="clsHide" href="#idCmrOsNdsn"></a></p>
  <p id="idCmrOsNnam">name::
    <br>* McsEngl.OsNo-computer!⇒cmrOsNo,
    <br>* McsEngl.techCmpr.OsNo!⇒cmrOsNo,
    <br>* McsEngl.cmrOsNo,
    <br>* McsEngl.operating-system.no--computer!⇒cmrOsNo,
    <a class="clsHide" href="#idCmrOsNnam"></a></p>
  </section>
</section>

<section id="idCmrScdnDlif">
  <h1 id="idCmrScdnDlifH1">techCmpr.specifics-division.digital-info
    <a class="clsHide" href="#idCmrScdnDlifH1"></a></h1>
  <p id="idCmrScdnDlifdsn">description::
    <br>* digital-computer,
    <br>* digitalNo-computer,
    <a class="clsHide" href="#idCmrScdnDlifdsn"></a></p>
  <p id="idCmrScdnDlifnam">name::
    <br>* McsEngl.techCmpr.specifics-division.digital-info,
    <a class="clsHide" href="#idCmrScdnDlifnam"></a></p>

  <section id="idCmrDgtl">
  <h2 id="idCmrDgtlH2">techCmpr.digital
    <a class="clsHide" href="#idCmrDgtlH2"></a></h2>
  <p id="idCmrDgtldsn">description::
    <br>· digital-computer is a-computer that process digital-information (information represented with discrete quantities) eg binary, trinary, ...
    <a class="clsHide" href="#idCmrDgtldsn"></a></p>
  <p id="idCmrDgtlnam">name::
    <br>* McsEngl.cmp.digital,
    <br>* McsEngl.digital-computer,
    <a class="clsHide" href="#idCmrDgtlnam"></a></p>
  </section>

  <section id="idCmrDgtlN">
  <h2 id="idCmrDgtlNH2">techCmpr.digitalNo (analog)
    <a class="clsHide" href="#idCmrDgtlNH2"></a></h2>
  <p id="idCmrDgtlNdsn">description::
    <br>· analog-computer is a-computer that process analog-information (information represented with continuous quantities) eg distance, area, time, ...
    <a class="clsHide" href="#idCmrDgtlNdsn"></a></p>
  <p id="idCmrDgtlNnam">name::
    <br>* McsEngl.analog-computer,
    <br>* McsEngl.techCmpr.digitalNo,
    <a class="clsHide" href="#idCmrDgtlNnam"></a></p>
  </section>
</section>

<section id="idCmrScdnmnfg">
  <h1 id="idCmrScdnmnfgH1">techCmpr.specifics-division.main-functing
    <a class="clsHide" href="#idCmrScdnmnfgH1"></a></h1>
  <p id="idCmrScdnmnfgdsn">description::
    <br>· on <a class="clsPreview" href="#idCmrdngMnfg">main-functing</a>:
    <br>* general-purpose--computer,
    <br>* general-purpose.no--computer,
    <a class="clsHide" href="#idCmrScdnmnfgdsn"></a></p>
  <p id="idCmrScdnmnfgnam">name::
    <br>* McsEngl.techCmpr.specifics-division.main-functing,
    <a class="clsHide" href="#idCmrScdnmnfgnam"></a></p>

  <section id="idCmrGlps">
  <h2 id="idCmrGlpsH2">techCmpr.general-purpose
    <a class="clsHide" href="#idCmrGlpsH2"></a></h2>
  <p id="idCmrGlpsdsn">description::
    <br>· general-purpose--computer is a-computer with <a class="clsPreview" href="#idCmrdngMnfg">main-function</a> ANY info-processing task.
    <a class="clsHide" href="#idCmrGlpsdsn"></a></p>
  <p id="idCmrGlpsnam">name::
    <br>* McsEngl.techCmpr.general-purpose,
    <br>* McsEngl.general-purpose--computer,
    <br>* McsEngl.Turing-complete--computer,
    <a class="clsHide" href="#idCmrGlpsnam"></a></p>
  <p id="idCmrGlpswpa">addressWpg::
    <br>* Rudd-Canaday, Early Turing-complete Computers, http://www.ruddcanaday.com/post-ww2-computers/,
    <a class="clsHide" href="#idCmrGlpswpa"></a></p>
  </section>

  <section id="idCmrGlpsNo">
  <h2 id="idCmrGlpsNoH2">techCmpr.general-purpose.no
    <a class="clsHide" href="#idCmrGlpsNoH2"></a></h2>
  <p id="idCmrGlpsNodsn">description::
    <br>· special-purpose--computer is a-computer with <a class="clsPreview" href="#idCmrdngMnfg">main-function</a> a-specific task.
    <a class="clsHide" href="#idCmrGlpsNodsn"></a></p>
  <p id="idCmrGlpsNonam">name::
    <br>* McsEngl.cmp.general-purpose.no,
    <br>* McsEngl.special-purpose--computer,
    <a class="clsHide" href="#idCmrGlpsNonam"></a></p>
  </section>
</section>

<section id="idCmrScdnRlt">
  <h1 id="idCmrScdnRltH1">techCmpr.specifics-division.reality
    <a class="clsHide" href="#idCmrScdnRltH1"></a></h1>
  <p id="idCmrScdnRltdsn">description::
    <br>· on reality:
    <br>* real-computer:
    <br>* real.physical-computer,
    <br>* real.virtual-computer,
    <br>* realNo-computer,
    <a class="clsHide" href="#idCmrScdnRltdsn"></a></p>
  <p id="idCmrScdnRltnam">name::
    <br>* McsEngl.techCmpr.specifics-division.reality,
    <a class="clsHide" href="#idCmrScdnRltnam"></a></p>

  <section id="idCmrReal">
  <h2 id="idCmrRealH2">techCmpr.real
    <a class="clsHide" href="#idCmrRealH2"></a></h2>
  <p id="idCmrRealdsn">description::
    <br>· real-computer is <a class="clsPreview" href="#idOverview">a-computer</a> that works.
    <a class="clsHide" href="#idCmrRealdsn"></a></p>
  <p id="idCmrRealnam">name::
    <br>* McsEngl.techCmpr.real!⇒cmrReal,
    <br>* McsEngl.cmrReal,
    <br>* McsEngl.real-computer!⇒cmrReal,
    <a class="clsHide" href="#idCmrRealnam"></a></p>
  <p id="idCmrRealSpc">specific::
    <br>=== on-hardware:
    <br>* physical-computer,
    <br>* virtual-computer,
    <a class="clsHide" href="#idCmrRealSpc"></a></p>
  </section>

  <section id="idCmrRealN">
  <h2 id="idCmrRealNH2">techCmpr.realNo (<a class="clsPreview" href="idCmpr003">link</a>)
    <a class="clsHide" href="#idCmrRealNH2"></a></h2>
  </section>

  <section id="idCmrPhcl">
  <h2 id="idCmrPhclH2">techCmpr.physical
    <a class="clsHide" href="#idCmrPhclH2"></a></h2>
  <p id="idCmrPhcldsn">description::
    <br>· physical-computer is <a class="clsPreview" href="#idCmrReal">a-real-computer</a> implemented in <a class="clsPreview" href="#idCmratt001">hardware</a>.
    <br>· a-physical-machine\a\ works with <a class="clsPreview" href="filMcsCmr.last.html#idLmchnalgcode">machine-code</a> today with <a class="clsPreview" href="filMcsCmr.last.html#idLbnralgcode">binary-code</a> which includes an-instruction-set, it\a\ has memory-areas and it\a\ is operating-system dependent.
    <a class="clsHide" href="#idCmrPhcldsn"></a></p>
  <p id="idCmrPhclnam">name::
    <br>* McsEngl.techCmpr.physical!⇒cmrPhysical,
    <br>* McsEngl.cmrPhysical,
    <br>* McsEngl.physical-computer!⇒cmrPhysical,
    <a class="clsHide" href="#idCmrPhclnam"></a></p>
  </section>

  <section id="idCmrVrtl">
  <h2 id="idCmrVrtlH2">techCmpr.virtual
    <a class="clsHide" href="#idCmrVrtlH2"></a></h2>
  <p id="idCmrVrtldsn">description::
    <br>· virtual-computer\a\ is <a class="clsPreview" href="#idCmrReal">a-real-computer</a> implemented in <a class="clsPreview" href="#idCmratt002">software</a>.
    <br>· it\a\ works with <a class="clsPreview" href="../dirTchInf/McsTchInf000006.last.html#idLbnralgcode">binary-code</a>, it\a\ has memory managed with the-code, but it\a\ is independent of operating-systems.
    <a class="clsHide" href="#idCmrVrtldsn"></a></p>
  <p id="idCmrVrtlnam">name::
    <br>* McsEngl.techCmpr.virtual!⇒cmrVirtual,
    <br>* McsEngl.cmrVirtual,
    <br>* McsEngl.virtual-computer!⇒cmrVirtual,
    <br>* McsEngl.virtual-machine!⇒cmrVirtual,
    <a class="clsHide" href="#idCmrVrtlnam"></a></p>
  <p id="idCmrVrtlSpc">specific::
    <br>* register-vm,
    <br>* stack-vm,
    <a class="clsHide" href="#idCmrVrtlSpc"></a></p>
  </section>
</section>

<section id="idCmrScdnSize">
  <h1 id="idCmrScdnSizeH1">techCmpr.specifics-division.size
    <a class="clsHide" href="#idCmrScdnSizeH1"></a></h1>
  <p id="idCmrScdnSizedsn">description::
    <br>· on size:
    <br>* large-techCmpr,
    <br>* desktop-techCmpr,
    <br>* small-techCmpr,
    <a class="clsHide" href="#idCmrScdnSizedsn"></a></p>
  <p id="idCmrScdnSizenam">name::
    <br>* McsEngl.techCmpr.specifics-division.size,
    <a class="clsHide" href="#idCmrScdnSizenam"></a></p>

  <section id="idCmrLrg">
  <h2 id="idCmrLrgH2">techCmpr.large
    <a class="clsHide" href="#idCmrLrgH2"></a></h2>
  <p id="idCmrLrgdsn">description::
    <br>· large-computer I call <a class="clsPreview" href="#idOverview">a-computer</a> bigger than <a class="clsPreview" href="#idCmrDktp">a-desktop</a>.
    <a class="clsHide" href="#idCmrLrgdsn"></a></p>
  <p id="idCmrLrgnam">name::
    <br>* McsEngl.techCmpr.large,
    <br>* McsEngl.cmrLarge,
    <br>* McsEngl.large-computer,
    <a class="clsHide" href="#idCmrLrgnam"></a></p>
  </section>

  <section id="idCmrDktp">
  <h2 id="idCmrDktpH2">techCmpr.desktop
    <a class="clsHide" href="#idCmrDktpH2"></a></h2>
  <p id="idCmrDktpdsn">description::
    <br>· desktop-computer is a-computer that we use at a-single location on or near tables.
    <a class="clsHide" href="#idCmrDktpdsn"></a></p>
  <p id="idCmrDktpnam">name::
    <br>* McsEngl.techCmpr.desktop,
    <br>* McsEngl.cmrDesktop,
    <br>* McsEngl.desktop-computer,
    <a class="clsHide" href="#idCmrDktpnam"></a></p>
  </section>

  <section id="idCmrSml">
  <h2 id="idCmrSmlH2">techCmpr.small
    <a class="clsHide" href="#idCmrSmlH2"></a></h2>
  <p id="idCmrSmldsn">description::
    <br>· small-computer I call <a class="clsPreview" href="#idOverview">a-computer</a> smaller than <a class="clsPreview" href="#idCmrDktp">a-desktop</a> we can-carry with us.
    <a class="clsHide" href="#idCmrSmldsn"></a></p>
  <p id="idCmrSmlnam">name::
    <br>* McsEngl.techCmpr.small,
    <br>* McsEngl.cmrSmall,
    <br>* McsEngl.small-computer,
    <a class="clsHide" href="#idCmrSmlnam"></a></p>
  <p id="idCmrSmlSpc">specific::
    <br>* laptop-computer,
    <br>* tablet-computer,
    <br>* fablet-computer,
    <br>* smartphone,
    <a class="clsHide" href="#idCmrSmlSpc"></a></p>
  </section>
</section>

<section id="idCmr003">
  <h1 id="idCmr003H1">techCmpr.abstract-003
    <a class="clsHide" href="#idCmr003H1"></a></h1>
  <p id="idCmr003dsn">description::
    <br>"Abstract machines are mathematical models of computation. They are used to study the properties of computational systems and to design new ones."
    <br>[{2023-10-16 retrieved} https://bard.google.com/chat/ed26e14d8b9ca61b]
    <br>
    <br>· realNo-computer\a\ is <a class="clsPreview" href="#idOverview">a-computer</a> that does-not-work in reality.
    <br>· it\a\ is simpler than a-real, usually auto-manages its\a\ memory, and it\a\ is independent of <a class="clsPreview" href="../dirTchInf/McsTchInf000006.last.html#idLpgOs">operating-systems</a>.
    <br>
    <br>"overview of abstract-machine:
    <br>An abstract machine is a theoretical model of a computer system. It is a simplified representation of a real computer, ignoring many of the details of the hardware and focusing on the essential elements of computation. Abstract machines are often used in computer science education and research to help understand the fundamental concepts of computing.
    <br>
    <br>Abstract machines are typically defined by a set of states, a set of operations, and a set of rules for transitioning between states. The states represent the different configurations of the machine during a computation. The operations represent the different actions that the machine can take, such as reading from memory, writing to memory, and performing arithmetic operations. The rules specify how the machine transitions from one state to another based on the current state and the operation being performed.
    <br>
    <br>Abstract machines can be used to model a variety of different types of computer systems, including CPUs, GPUs, and even entire computer networks. By modeling a computer system as an abstract machine, it is possible to study the system's behavior without having to worry about the specific details of the hardware implementation.
    <br>
    <br>Here is a simple example of an abstract machine:
    <br>* **States:**
    <br>    * Running
    <br>    * Halted
    <br>* **Operations:**
    <br>    * Add
    <br>    * Subtract
    <br>    * Multiply
    <br>    * Divide
    <br>    * Read from memory
    <br>    * Write to memory
    <br>* **Rules:**
    <br>    * If the machine is in the Running state and the Add operation is performed, the machine transitions to the Running state and the contents of the accumulator register are incremented by the value in the memory location specified by the operand.
    <br>    * If the machine is in the Running state and the Subtract operation is performed, the machine transitions to the Running state and the contents of the accumulator register are decremented by the value in the memory location specified by the operand.
    <br>    * ... (similar rules for the other operations)
    <br>    * If the machine is in the Running state and the Halt operation is performed, the machine transitions to the Halted state.
    <br>
    <br>This abstract machine can be used to model a simple CPU that can perform basic arithmetic operations. The accumulator register represents the CPU's register file, and the memory locations represent the CPU's memory. The instructions in a program can be translated into the operations of the abstract machine, and the program can then be executed by simulating the abstract machine.
    <br>
    <br>Abstract machines are a powerful tool for understanding the fundamental concepts of computing. They can be used to model a wide variety of different computer systems, and they can be used to study the behavior of these systems without having to worry about the specific details of the hardware implementation.
    <br>
    <br>Here are some of the benefits of using abstract machines:
    <br>* They can help us to understand the fundamental concepts of computing without having to worry about the specific details of the hardware implementation.
    <br>* They can be used to model a wide variety of different computer systems, from CPUs to GPUs to entire computer networks.
    <br>* They can be used to study the behavior of computer systems without having to write and execute real programs.
    <br>* They can be used to design new computer systems and algorithms.
    <br>
    <br>Abstract machines are an essential tool for computer scientists and engineers. They are used in a variety of different applications, including education, research, and software development."
    <br>[{2023-10-16 retrieved} https://bard.google.com/chat/78055073257d0fba]
    <a class="clsHide" href="#idCmr003dsn"></a></p>
  <p id="idCmr003nam">name::
    <br>* McsEngl.abstract-computer!⇒cmprAbstract,
    <br>* McsEngl.abstract-machine!⇒cmprAbstract,
    <br>* McsEngl.cmprAbstract,
    <br>* McsEngl.hypothetical-computer!⇒cmprAbstract,
    <br>* McsEngl.imaginary-computer!⇒cmprAbstract,
    <br>* McsEngl.sciCmpr'abstract-machine,
    <br>* McsEngl.techCmpr.003-abstract!⇒cmprAbstract,
    <br>* McsEngl.techCmpr.realNo!⇒cmprAbstract,
    <br>* McsEngl.theoritical-computer!⇒cmprAbstract,
    <a class="clsHide" href="#idCmr003nam"></a></p>
  <p id="idCmr003dsnL">descriptionLong::
    <br>"overview of abstract-machine:
    <br>An abstract machine is a theoretical concept in computer science and computational theory. It serves as a model or framework to understand the execution of programs, particularly in the context of programming languages and their implementation. Abstract machines provide a level of abstraction that helps researchers and programmers analyze and reason about the behavior of programs without being tied to the specifics of a physical computer or a particular programming language.
    <br>
    <br>Here's an overview of abstract machines:
    <br>1. **Purpose**:
    <br>   Abstract machines are designed to provide a simplified, high-level representation of a computer system to study and analyze various aspects of program execution. They help in understanding program behavior, program optimization, and language semantics.
    <br>
    <br>2. **Abstraction Level**:
    <br>   Abstract machines abstract away the low-level details of physical computers, such as hardware architecture, instruction set, and memory management. They provide a more high-level and coherent model of computation.
    <br>
    <br>3. **Variety of Abstract Machines**:
    <br>   There are several types of abstract machines, each designed for specific purposes. Some well-known abstract machines include:
    <br>   - **Turing Machine**: A mathematical model of computation that is often used to prove theoretical concepts and study computability.
    <br>   - **Lambda Calculus**: A formal system for expressing computation, particularly useful for understanding functional programming languages.
    <br>   - **Abstract Syntax Trees (ASTs)**: These are used in compilers to represent the syntactic structure of a program before code generation.
    <br>   - **Virtual Machines**: These are used to execute code written in a particular high-level programming language, often with an interpreter or a Just-In-Time (JIT) compiler.
    <br>   - **Register Machines**: Abstract models used for studying optimization techniques and instruction-level execution.
    <br>
    <br>4. **Execution and Interpretation**:
    <br>   Abstract machines typically involve an interpreter that interprets a program's code according to the rules defined by the machine's model. This interpretation process can be more flexible and forgiving than physical hardware execution, making it a valuable tool for language design and implementation.
    <br>
    <br>5. **Language Semantics and Compilation**:
    <br>   Abstract machines are crucial for understanding the semantics of programming languages. Compiler designers often use abstract machines to optimize code generation for specific languages, as well as to translate high-level language constructs into lower-level instructions.
    <br>
    <br>6. **Research and Education**:
    <br>   Abstract machines are widely used in research and computer science education to study programming language design, semantics, and execution. They help students and researchers experiment with different programming paradigms and gain insights into how programs work at a fundamental level.
    <br>
    <br>7. **Examples**:
    <br>   - The Stack Machine: A simple abstract machine that uses a stack data structure to execute instructions, commonly used in some programming language interpreters.
    <br>   - The Java Virtual Machine (JVM): An abstract machine designed to run Java bytecode, which is a common example of a virtual machine used in practice.
    <br>
    <br>In summary, abstract machines are valuable tools in computer science and programming for understanding, analyzing, and optimizing the execution of programs. They provide a bridge between the high-level abstractions of programming languages and the low-level execution details of physical computers."
    <br>[{2023-10-16 retrieved} https://chat.openai.com/c/b06521ce-b53f-4adf-b70c-36b024247396]
    <a class="clsHide" href="#idCmr003dsnL"></a></p>

  <section id="idCmr003inpt">
  <h2 id="idCmr003inptH2">input of cmprAbstract
    <a class="clsHide" href="#idCmr003inptH2"></a></h2>
  <p id="idCmr003inptdsn">description::
    <br>· data give to machine
    <a class="clsHide" href="#idCmr003inptdsn"></a></p>
  <p id="idCmr003inptnam">name::
    <br>* McsEngl.cmprAbstract'input,
    <a class="clsHide" href="#idCmr003inptnam"></a></p>
  </section>

  <section id="idCmr003otpt">
  <h2 id="idCmr003otptH2">output of cmprAbstract
    <a class="clsHide" href="#idCmr003otptH2"></a></h2>
  <p id="idCmr003otptdsn">description::
    <br>· data the-machine give to us.
    <a class="clsHide" href="#idCmr003otptdsn"></a></p>
  <p id="idCmr003otptnam">name::
    <br>* McsEngl.cmprAbstract'output,
    <a class="clsHide" href="#idCmr003otptnam"></a></p>
  </section>

  <section id="idCmr003stat">
  <h2 id="idCmr003statH2">state of cmprAbstract
    <a class="clsHide" href="#idCmr003statH2"></a></h2>
  <p id="idCmr003statdsn">description::
    <br>* Running
    <br>* Halted
    <a class="clsHide" href="#idCmr003statdsn"></a></p>
  <p id="idCmr003statnam">name::
    <br>* McsEngl.cmprAbstract'state,
    <a class="clsHide" href="#idCmr003statnam"></a></p>
  </section>

  <section id="idCmr003oprn">
  <h2 id="idCmr003oprnH2">operation of cmprAbstract
    <a class="clsHide" href="#idCmr003oprnH2"></a></h2>
  <p id="idCmr003oprndsn">description::
    <br>* Add
    <br>* Subtract
    <br>* Multiply
    <br>* Divide
    <br>* Read from memory
    <br>* Write to memory
    <a class="clsHide" href="#idCmr003oprndsn"></a></p>
  <p id="idCmr003oprnnam">name::
    <br>* McsEngl.cmprAbstract'operation,
    <a class="clsHide" href="#idCmr003oprnnam"></a></p>
  </section>

  <section id="idCmr003irsc">
  <h2 id="idCmr003irscH2">info-resource of cmprAbstract
    <a class="clsHide" href="#idCmr003irscH2"></a></h2>
  <p id="idCmr003irscdsn">description::
    <br>·
    <a class="clsHide" href="#idCmr003irscdsn"></a></p>
  <p id="idCmr003irscnam">name::
    <br>* McsEngl.cmprAbstract.Infrsc,
    <a class="clsHide" href="#idCmr003irscnam"></a></p>
  </section>

  <section id="idCmr003gst">
  <h2 id="idCmr003gstH2">GENERIC-SPECIFIC-TREE of cmprAbstract
    <a class="clsHide" href="#idCmr003gstH2"></a></h2>
  <p id="idCmr003gstgtr">generic-tree-of-cmprAbstract::
    <br>* ,
    <br>* ... entity,
    <br>* McsEngl.cmprAbstract'generic-tree,
    <a class="clsHide" href="#idCmr003gstgtr"></a></p>
  <p id="idCmr003gststr">specific-tree-of-cmprAbstract::
    <br>* ,
    <br>"types of abstract-machines:
    <br>Abstract machines can be classified into two main types: deterministic and non-deterministic.
    <br>
    <br>* **Deterministic abstract machines** are machines that always produce the same output for the same input. This means that the machine's state transitions are determined entirely by the current state and the operation being performed.
    <br>* **Non-deterministic abstract machines** are machines that can produce different outputs for the same input. This means that the machine's state transitions are not entirely determined by the current state and the operation being performed.
    <br>
    <br>Here are some examples of different types of abstract machines:
    <br>* **Finite state machines (FSMs)** are deterministic abstract machines that are used to model simple sequential systems. FSMs have a finite number of states and a finite number of operations. The next state of the machine is determined by the current state and the input symbol.
    <br>* **Mealy machines** are deterministic abstract machines that are similar to FSMs, but they also produce an output symbol at each state transition.
    <br>* **Pushdown automata (PDAs)** are deterministic abstract machines that have a stack in addition to their memory. PDAs can use the stack to store information that can be used to make decisions about future state transitions.
    <br>* **Turing machines** are non-deterministic abstract machines that are capable of modeling any computable function. Turing machines have an infinite tape and a head that can read and write symbols on the tape. The head can also move left and right on the tape.
    <br>
    <br>Abstract machines are also used to model the execution of computer programs. For example, the stack machine is an abstract machine that is used to model the execution of programs written in stack-based programming languages, such as Forth and PostScript.
    <br>
    <br>Abstract machines are a powerful tool for understanding the fundamental concepts of computing. They can be used to model a variety of different computer systems and algorithms. Abstract machines are also used in the design and implementation of real computer systems and software."
    <br>[{2023-10-16 retrieved} https://bard.google.com/chat/78055073257d0fba]
    <br>
    <br>* McsEngl.cmprAbstract.specific-tree,
    <a class="clsHide" href="#idCmr003gststr"></a></p>
  </section>

  <section id="idCmr003Dtnc">
  <h2 id="idCmr003DtncH2">cmprAbstract.deterministic
    <a class="clsHide" href="#idCmr003DtncH2"></a></h2>
  <p id="idCmr003Dtncdsn">description::
    <br>* **Deterministic abstract machines** are machines that always produce the same output for the same input. This means that the machine's state transitions are determined entirely by the current state and the operation being performed.
    <br>[{2023-10-16 retrieved} https://bard.google.com/chat/78055073257d0fba]
    <a class="clsHide" href="#idCmr003Dtncdsn"></a></p>
  <p id="idCmr003Dtncnam">name::
    <br>* McsEngl.cmprAbstract.deterministic,
    <br>* McsEngl.deterministic-cmprAbstract,
    <a class="clsHide" href="#idCmr003Dtncnam"></a></p>
  </section>

  <section id="idCmr003DtncN">
  <h2 id="idCmr003DtncNH2">cmprAbstract.deterministicNo
    <a class="clsHide" href="#idCmr003DtncNH2"></a></h2>
  <p id="idCmr003DtncNdsn">description::
    <br>**Non-deterministic abstract machines** are machines that can produce different outputs for the same input. This means that the machine's state transitions are not entirely determined by the current state and the operation being performed.
    <br>[{2023-10-16 retrieved} https://bard.google.com/chat/78055073257d0fba]
    <a class="clsHide" href="#idCmr003DtncNdsn"></a></p>
  <p id="idCmr003DtncNnam">name::
    <br>* McsEngl.cmprAbstract.deterministicNo,
    <br>* McsEngl.deterministicNo-cmprAbstract,
    <br>* McsEngl.non-deterministic-cmprAbstract,
    <a class="clsHide" href="#idCmr003DtncNnam"></a></p>
  </section>

  <section id="idCmr003Turg">
  <h2 id="idCmr003TurgH2">cmprAbstract.turing
    <a class="clsHide" href="#idCmr003TurgH2"></a></h2>
  <p id="idCmr003Turgdsn">description::
    <br>Turing machines: Turing machines are the most fundamental type of abstract machine. They can be used to model any computational system.
    <br>[{2023-10-16 retrieved} https://bard.google.com/chat/ed26e14d8b9ca61b]
    <a class="clsHide" href="#idCmr003Turgdsn"></a></p>
  <p id="idCmr003Turgnam">name::
    <br>* McsEngl.cmprAbstract.turing,
    <br>* McsEngl.turing-cmprAbstract,
    <a class="clsHide" href="#idCmr003Turgnam"></a></p>
  </section>

  <section id="idCmr003Trgnd">
  <h2 id="idCmr003TrgndH2">cmprAbstract.turing-non-deterministic
    <a class="clsHide" href="#idCmr003TrgndH2"></a></h2>
  <p id="idCmr003Trgnddsn">description::
    <br>Non-deterministic Turing machines: Non-deterministic Turing machines are a more powerful type of Turing machine that can be used to model concurrent and parallel computation.
    <br>[{2023-10-16 retrieved} https://bard.google.com/chat/ed26e14d8b9ca61b]
    <a class="clsHide" href="#idCmr003Trgnddsn"></a></p>
  <p id="idCmr003Trgndnam">name::
    <br>* McsEngl.cmprAbstract.turing-non-deterministic,
    <br>* McsEngl.turing-non-deterministic-cmprAbstract,
    <a class="clsHide" href="#idCmr003Trgndnam"></a></p>
  </section>

  <section id="idCmr003Stck">
  <h2 id="idCmr003StckH2">cmprAbstract.stack
    <a class="clsHide" href="#idCmr003StckH2"></a></h2>
  <p id="idCmr003Stckdsn">description::
    <br>Stack machines: Stack machines are a simpler type of abstract machine that uses a stack to store data.
    <br>[{2023-10-16 retrieved} https://bard.google.com/chat/ed26e14d8b9ca61b]
    <a class="clsHide" href="#idCmr003Stckdsn"></a></p>
  <p id="idCmr003Stcknam">name::
    <br>* McsEngl.cmprAbstract.stack,
    <br>* McsEngl.stack-cmprAbstract,
    <a class="clsHide" href="#idCmr003Stcknam"></a></p>
  </section>

  <section id="idCmr003Fnst">
  <h2 id="idCmr003FnstH2">cmprAbstract.finite-state
    <a class="clsHide" href="#idCmr003FnstH2"></a></h2>
  <p id="idCmr003Fnstdsn">description::
    <br>Finite state machines: Finite state machines are the simplest type of abstract machine. They can be used to model systems with a finite number of states.
    <br>[{2023-10-16 retrieved} https://bard.google.com/chat/ed26e14d8b9ca61b]
    <a class="clsHide" href="#idCmr003Fnstdsn"></a></p>
  <p id="idCmr003Fnstnam">name::
    <br>* McsEngl.cmprAbstract.finite-state,
    <br>* McsEngl.finite-state-cmprAbstract,
    <a class="clsHide" href="#idCmr003Fnstnam"></a></p>
  </section>

  <section id="idCmr003Psda">
  <h2 id="idCmr003PsdaH2">cmprAbstract.push-down-automata
    <a class="clsHide" href="#idCmr003PsdaH2"></a></h2>
  <p id="idCmr003Psdadsn">description::
    <br>Pushdown automata: Pushdown automata are a type of abstract machine that uses a stack to store data. They are used to model systems with a finite number of states and a pushdown stack.
    <br>[{2023-10-16 retrieved} https://bard.google.com/chat/ed26e14d8b9ca61b]
    <a class="clsHide" href="#idCmr003Psdadsn"></a></p>
  <p id="idCmr003Psdanam">name::
    <br>* McsEngl.cmprAbstract.push-down-automata,
    <br>* McsEngl.push-down-automata-cmprAbstract,
    <a class="clsHide" href="#idCmr003Psdanam"></a></p>
  </section>

  <section id="idCmr003Tgan">
  <h2 id="idCmr003TganH2">cmprAbstract.alternating-turing
    <a class="clsHide" href="#idCmr003TganH2"></a></h2>
  <p id="idCmr003Tgandsn">description::
    <br>Alternating Turing machines: Alternating Turing machines are a type of non-deterministic Turing machine that can be used to model quantum computation.
    <br>[{2023-10-16 retrieved} https://bard.google.com/chat/ed26e14d8b9ca61b]
    <a class="clsHide" href="#idCmr003Tgandsn"></a></p>
  <p id="idCmr003Tgannam">name::
    <br>* McsEngl.cmprAbstract.alternating-turing,
    <br>* McsEngl.alternating-turing-cmprAbstract,
    <a class="clsHide" href="#idCmr003Tgannam"></a></p>
  </section>

  <section id="idCmr003Rgtr">
  <h2 id="idCmr003RgtrH2">cmprAbstract.register
    <a class="clsHide" href="#idCmr003RgtrH2"></a></h2>
  <p id="idCmr003Rgtrdsn">description::
    <br>Register machines: Register machines are a type of abstract machine that uses a finite number of registers to store data.
    <br>[{2023-10-16 retrieved} https://bard.google.com/chat/ed26e14d8b9ca61b]
    <a class="clsHide" href="#idCmr003Rgtrdsn"></a></p>
  <p id="idCmr003Rgtrnam">name::
    <br>* McsEngl.cmprAbstract.register,
    <br>* McsEngl.register-cmprAbstract,
    <a class="clsHide" href="#idCmr003Rgtrnam"></a></p>
  </section>

  <section id="idCmr003Rmacs">
  <h2 id="idCmr003RmacsH2">cmprAbstract.random-access
    <a class="clsHide" href="#idCmr003RmacsH2"></a></h2>
  <p id="idCmr003Rmacsdsn">description::
    <br>Random access machines: Random access machines are a type of abstract machine that can access any memory location in a constant amount of time.
    <br>[{2023-10-16 retrieved} https://bard.google.com/chat/ed26e14d8b9ca61b]
    <a class="clsHide" href="#idCmr003Rmacsdsn"></a></p>
  <p id="idCmr003Rmacsnam">name::
    <br>* McsEngl.cmprAbstract.random-access,
    <br>* McsEngl.random-access-cmprAbstract,
    <a class="clsHide" href="#idCmr003Rmacsnam"></a></p>
  </section>

  <section id="idCmr003Tgsm">
  <h2 id="idCmr003TgsmH2">cmprAbstract.tag-system
    <a class="clsHide" href="#idCmr003TgsmH2"></a></h2>
  <p id="idCmr003Tgsmdsn">description::
    <br>Tag systems: Tag systems are a type of abstract machine that uses a set of tags to represent data.
    <br>[{2023-10-16 retrieved} https://bard.google.com/chat/ed26e14d8b9ca61b]
    <a class="clsHide" href="#idCmr003Tgsmdsn"></a></p>
  <p id="idCmr003Tgsmnam">name::
    <br>* McsEngl.cmprAbstract.tag-system,
    <br>* McsEngl.tag-system-cmprAbstract,
    <a class="clsHide" href="#idCmr003Tgsmnam"></a></p>
  </section>

  <section id="idCmr003Ldcl">
  <h2 id="idCmr003LdclH2">cmprAbstract.lambda-calculus
    <a class="clsHide" href="#idCmr003LdclH2"></a></h2>
  </section>

  <section id="idCmr003Sorc">
  <h2 id="idCmr003SorcH2">cmprAbstract.source
    <a class="clsHide" href="#idCmr003SorcH2"></a></h2>
  <p id="idCmr003Sorcdsn">description::
   <br>· source-computer is <a class="clsPreview" href="#idCmr003">abstract-computer</a> that understands source-language.
    <a class="clsHide" href="#idCmr003Sorcdsn"></a></p>
  <p id="idCmr003Sorcnam">name::
    <br>* McsEngl.cmprAbstract.source,
    <br>* McsEngl.source-cmprAbstract,
    <a class="clsHide" href="#idCmr003Sorcnam"></a></p>
  </section>
</section>

<section id="idCmr001">
  <h1 id="idCmr001H1">techCmpr.binary-001
    <a class="clsHide" href="#idCmr001H1"></a></h1>
  <p id="idCmr001dsn">description::
    <br>· binary-computer is <a class="clsPreview" href="#idCmrDgtl">a-digital-computer</a> that processes binary-info.
    <a class="clsHide" href="#idCmr001dsn"></a></p>
  <p id="idCmr001nam">name::
    <br>* McsEngl.binary-computer!⇒cmrBnr,
    <br>* McsEngl.techCmpr.001-binary!⇒cmrBnr,
    <br>* McsEngl.techCmpr.binary!⇒cmrBnr,
    <br>* McsEngl.cmrBnr,
    <br>* McsEngl.computer.binary!⇒cmrBnr,
    <a class="clsHide" href="#idCmr001nam"></a></p>

  <section id="idCmr001hdwr">
  <h2 id="idCmr001hdwrH2">hardware of cmrBnr
    <a class="clsHide" href="#idCmr001hdwrH2"></a></h2>
  </section>

  <section id="idCmr001stwr">
  <h2 id="idCmr001stwrH2">software of cmrBnr
    <a class="clsHide" href="#idCmr001stwrH2"></a></h2>
  </section>

  <section id="idCmr001pglg">
  <h2 id="idCmr001pglgH2">programing-language (<a class="clsPreview" href="../dirTchInf/McsTchInf000006.last.html#idOverview">link</a>) of cmrBnr
    <a class="clsHide" href="#idCmr001pglgH2"></a></h2>
  </section>
</section>

<section id="idCmrQtm">
  <h1 id="idCmrQtmH1">techCmpr.quantum-002
    <a class="clsHide" href="#idCmrQtmH1"></a></h1>
  <p id="idCmrQtmdsn">description::
    <br>· <span class="clsColorRed">quantum-computer</span> is a-digital-computer that uses more that 2-digits to encode information.
    <a class="clsHide" href="#idCmrQtmdsn"></a></p>
  <p id="idCmrQtmnam">name::
    <br>* McsEngl.cmprQtm!⇒cmprQntm,
    <br>* McsEngl.cmprQntm!=quantum-computer,
    <br>* McsEngl.techCmpr.002-quantum!⇒cmprQntm,
    <br>* McsEngl.techCmpr.quantum!⇒cmprQntm,
    <br>* McsEngl.quantum-computer!⇒cmprQntm,
    <a class="clsHide" href="#idCmrQtmnam"></a></p>

  <section id="idCmrQtmqubt">
  <h2 id="idCmrQtmqubtH2">qubit of cmprQntm
    <a class="clsHide" href="#idCmrQtmqubtH2"></a></h2>
  <p id="idCmrQtmqubtdsn">description::
    <br>">qubit:
    <br>A qubit, short for "quantum bit," is the basic unit of quantum information in quantum computing and quantum information theory. Unlike classical bits, which can exist in one of two states (0 or 1), qubits can exist in multiple states simultaneously, thanks to the principles of quantum superposition.
    <br>
    <br>The fundamental properties of qubits include:
    <br>1. **Superposition:** A qubit can exist in a superposition of states, meaning it can represent both 0 and 1 at the same time.
    <br>2. **Entanglement:** Qubits can be entangled, which means the state of one qubit is directly related to the state of another, regardless of the distance between them. Changes to one qubit will instantaneously affect its entangled partner.
    <br>3. **Quantum Measurement:** When a qubit is measured, it collapses into one of its possible states (0 or 1) with certain probabilities. The act of measurement disturbs the superposition.
    <br>
    <br>These properties allow quantum computers to perform certain calculations much more efficiently than classical computers. Quantum computers are still in the early stages of development, and researchers are working on addressing various technical challenges, such as maintaining coherence and minimizing errors in quantum computations.
    <br>[{2023-12-05 retrieved} https://chat.openai.com/c/4e57dbfe-2a0c-49c1-b4d4-691d42f621a2]
    <a class="clsHide" href="#idCmrQtmqubtdsn"></a></p>
  <p id="idCmrQtmqubtnam">name::
    <br>* McsEngl.cmprQntm'qubit,
    <br>* McsEngl.qubit,
    <a class="clsHide" href="#idCmrQtmqubtnam"></a></p>
  </section>

  <section id="idCmrQtmcrct">
  <h2 id="idCmrQtmcrctH2">circuit of cmprQntm
    <a class="clsHide" href="#idCmrQtmcrctH2"></a></h2>
  <p id="idCmrQtmcrctdsn">description::
    <br>">quantum circuit of quantum-algorithms:
    <br>A quantum circuit is a graphical representation of a sequence of quantum gates and measurements that are applied to a set of qubits. Quantum circuits are used to describe quantum algorithms, which are algorithms that run on quantum computers.
    <br>
    <br>Quantum circuits are similar to classical circuits, but they have some important differences. In a classical circuit, each gate operates on a single bit. In a quantum circuit, each gate can operate on multiple qubits, and the gates can take advantage of the superposition and entanglement properties of quantum mechanics.
    <br>
    <br>The basic elements of a quantum circuit are:
    <br>* Qubits: Qubits are the basic units of quantum information. They can be in a superposition of states, which means that they can be both 0 and 1 at the same time.
    <br>* Quantum gates: Quantum gates are operations that manipulate the state of qubits. There are many different types of quantum gates, but some of the most common ones include the Hadamard gate, the Pauli X gate, and the Pauli Z gate.
    <br>* Measurements: Measurements are operations that collapse the state of a qubit to a single value. Measurements are typically used to read the output of a quantum algorithm.
    <br>
    <br>Quantum circuits are used to describe a wide variety of quantum algorithms. Some of the most well-known quantum algorithms include Shor's algorithm, which can be used to factor large integers, and Grover's algorithm, which can be used to search for an item in an unsorted list.
    <br>
    <br>Quantum circuits are a powerful tool for designing and analyzing quantum algorithms. They allow us to visualize the steps of an algorithm and to understand how it works. Quantum circuits are also used to synthesize quantum circuits, which is the process of converting a quantum circuit into a sequence of instructions that can be executed on a quantum computer.
    <br>
    <br>I hope this helps!"
    <br>[{2023-12-05 retrieved} https://bard.google.com/chat/6a03d9618c9d9a22]
    <a class="clsHide" href="#idCmrQtmcrctdsn"></a></p>
  <p id="idCmrQtmcrctnam">name::
    <br>* McsEngl.cmprQntm'circuit!⇒quciruit,
    <br>* McsEngl.quantum-circuit!⇒quciruit,
    <br>* McsEngl.quciruit!=quantum-circuit,
    <a class="clsHide" href="#idCmrQtmcrctnam"></a></p>

  <section id="idCmrQtmgate">
  <h3 id="idCmrQtmgateH3">gate of quciruit
    <a class="clsHide" href="#idCmrQtmgateH3"></a></h3>
  <p id="idCmrQtmgatedsn">description::
    <br>">quantum-gate:
    <br>A quantum gate is a fundamental building block in quantum computing. In classical computing, information is processed using bits, which can be either 0 or 1. In quantum computing, quantum bits or qubits can exist in multiple states simultaneously, thanks to the principles of superposition and entanglement.
    <br>
    <br>Quantum gates are analogous to classical logic gates but operate on quantum bits, allowing the manipulation of quantum information. These gates are reversible transformations that perform specific operations on qubits. The most basic quantum gates include:
    <br>1. **X Gate (NOT Gate):** Flips the state of a qubit, similar to the classical NOT gate.
    <br>2. **Hadamard Gate (H Gate):** Creates a superposition of the 0 and 1 states, useful for creating quantum parallelism.
    <br>3. **CNOT Gate (Controlled NOT Gate):** Performs a NOT operation on the target qubit if the control qubit is in the state |1|.
    <br>4. **SWAP Gate:** Exchanges the states of two qubits.
    <br>5. **Toffoli Gate (CCNOT Gate):** Similar to the CNOT gate but controlled by two qubits. It performs a NOT operation on the target qubit if both control qubits are in the state |1|.
    <br>
    <br>These gates, along with others, are combined to create quantum circuits. Quantum algorithms manipulate qubits using these gates to perform complex computations, taking advantage of the unique properties of quantum mechanics. It's important to note that quantum gates are reversible, in contrast to classical gates, reflecting the reversible nature of quantum computations."
    <br>[{2023-12-05 retrieved} https://chat.openai.com/c/6bde6866-b887-4bf5-b4da-7eeb02ff7d0f]
    <a class="clsHide" href="#idCmrQtmgatedsn"></a></p>
  <p id="idCmrQtmgatenam">name::
    <br>* McsEngl.quciruit'gate!⇒qugate,
    <br>* McsEngl.quantum-gate!⇒qugate,
    <br>* McsEngl.qugate!=quantum-gate,
    <a class="clsHide" href="#idCmrQtmgatenam"></a></p>
  </section>
  </section>

  <section id="idCmrQtmalgo">
  <h2 id="idCmrQtmalgoH2">algorithm of cmprQntm
    <a class="clsHide" href="#idCmrQtmalgoH2"></a></h2>
  <p id="idCmrQtmalgodsn">description::
    <br>">quantum algorithm vs binary-algorithm:
    <br>Both quantum algorithms and binary algorithms are designed to solve problems, but they have different approaches and capabilities.
    <br>
    <br>**Binary algorithms** are the traditional algorithms used by classical computers. They operate on bits, which can be either 0 or 1. Binary algorithms work by manipulating bits in a sequential manner, one step at a time. This makes them well-suited for problems that can be broken down into a series of simple steps.
    <br>
    <br>**Quantum algorithms**, on the other hand, are designed for quantum computers. Quantum computers use qubits, which can be 0, 1, or both at the same time. This unique property of qubits, called superposition, allows quantum algorithms to perform calculations on multiple inputs simultaneously. This makes them well-suited for problems that are too complex for classical computers to solve efficiently.
    <br>
    <br>**Here is a table summarizing the key differences between quantum algorithms and binary algorithms:**
    <br>| Feature | Binary Algorithm | Quantum Algorithm |
    <br>| Basic unit of information | Bit | Qubit |
    <br>| Computation | Manipulates bits sequentially | Manipulates qubits in parallel |
    <br>| Strength | Efficient for problems that can be broken down into simple steps | Efficient for problems that are too complex for classical computers |
    <br>| Applications | Wide range of applications, including web browsing, word processing, and gaming | Limited range of applications, but with the potential to revolutionize fields such as drug discovery, materials science, and artificial intelligence |
    <br>
    <br>**Here are some examples of quantum algorithms:**
    <br>* **Shor's algorithm:** This algorithm can factor large numbers into their prime factors exponentially faster than classical algorithms. This has important implications for cryptography, as it could be used to break many of the encryption algorithms that are currently used to secure online communications.
    <br>* **Grover's algorithm:** This algorithm can search for an element in an unsorted list with a square root improvement over classical algorithms. This has applications in a variety of fields, including artificial intelligence and data mining.
    <br>* **Quantum simulation:** Quantum computers can be used to simulate complex systems, such as molecules and quantum field theories. This has applications in a variety of fields, including drug discovery, materials science, and fundamental physics.
    <br>
    <br>Quantum algorithms are still in their early stages of development, but they have the potential to revolutionize many industries. As quantum computers become more powerful and more widely available, we can expect to see even more innovative quantum algorithms being developed."
    <br>[{2023-12-05 retrieved} https://bard.google.com/chat/29eb0e97e91e1e1c]
    <a class="clsHide" href="#idCmrQtmalgodsn"></a></p>
  <p id="idCmrQtmalgonam">name::
    <br>* McsEngl.algo.quantum!⇒qualgo
    <br>* McsEngl.algoQutm!⇒qualgo,
    <br>* McsEngl.cmprQntm'algo!⇒qualgo,
    <br>* McsEngl.qualgo!=quantum-algorithm,
    <br>* McsEngl.quantum-algorithm!⇒qualgo,
    <a class="clsHide" href="#idCmrQtmalgonam"></a></p>

  <section id="idCmrQtmalgoGrvr">
  <h3 id="idCmrQtmalgoGrvrH3">qualgo.Grover
    <a class="clsHide" href="#idCmrQtmalgoGrvrH3"></a></h3>
  <p id="idCmrQtmalgoGrvrdsn">description::
    <br>">Grover's algorithm:
    <br>Grover's algorithm, also known as the quantum search algorithm, is a quantum algorithm that significantly outperforms classical algorithms for solving unstructured search problems. Unstructured search problems involve finding an element that satisfies a specified condition within a given set. In classical computing, the best search algorithms require an average of O(N) operations to find the desired element, where N is the size of the set. However, Grover's algorithm can solve the same problem with only O(sqrt(N)) operations, demonstrating a quadratic speedup.
    <br>
    <br>Grover's algorithm relies on the principles of superposition and interference, which are fundamental concepts in quantum mechanics. Superposition allows a quantum system to exist in multiple states simultaneously, while interference occurs when different quantum states interact, creating patterns that can be used to amplify the desired state.
    <br>
    <br>The algorithm works by first preparing an equal superposition of all possible solutions. Then, it applies a series of operations that increase the amplitude of the correct solution while decreasing the amplitudes of the incorrect solutions. This process effectively amplifies the probability of finding the desired element.
    <br>
    <br>Grover's algorithm has significant implications for various fields, including cryptography, database search, and artificial intelligence. It has the potential to revolutionize these areas by providing faster and more efficient solutions to complex problems.
    <br>
    <br>Here's a simplified breakdown of Grover's algorithm:
    <br>1. **Initialization:** Initialize the quantum register in an equal superposition of all possible solutions.
    <br>2. **Oracle Operation:** Apply an oracle operation that marks the desired solution with a unique phase shift.
    <br>3. **Diffusion Operation:** Apply a diffusion operation that amplifies the amplitudes of states closer to the marked solution while decreasing the amplitudes of states farther away.
    <br>4. **Iteration:** Repeat steps 2 and 3 until the desired solution has a sufficiently high probability of being measured.
    <br>5. **Measurement:** Measure the quantum register to obtain the final solution.
    <br>
    <br>Grover's algorithm demonstrates the power of quantum computing and its potential to solve problems that are intractable for classical computers. It is a significant milestone in the development of quantum algorithms and has opened up new avenues for research and innovation."
    <br>[{2023-12-05 retrieved} https://bard.google.com/chat/91cf0f3e50d355f4]
    <a class="clsHide" href="#idCmrQtmalgoGrvrdsn"></a></p>
  <p id="idCmrQtmalgoGrvrnam">name::
    <br>* McsEngl.Grover's-algorithm,
    <br>* McsEngl.qualgo.Grover,
    <br>* McsEngl.quantum-search-algorithm,
    <a class="clsHide" href="#idCmrQtmalgoGrvrnam"></a></p>
  </section>

  <section id="idCmrQtmalgoShor">
  <h3 id="idCmrQtmalgoShorH3">qualgo.Shor
    <a class="clsHide" href="#idCmrQtmalgoShorH3"></a></h3>
  <p id="idCmrQtmalgoShordsn">description::
    <br>">Shor's algorithm:
    <br>Shor's algorithm is a quantum algorithm for integer factorization, developed by Peter Shor in 1994. It is one of the first and most important quantum algorithms to be discovered, and it has had a profound impact on the field of cryptography.
    <br>
    <br>Integer factorization is the process of finding the prime factors of an integer. This is a very difficult problem for classical computers to solve, and it is one of the reasons why RSA encryption is so secure. However, Shor's algorithm can factor integers in polynomial time, which means that it can factor very large integers much faster than any known classical algorithm.
    <br>
    <br>Shor's algorithm is based on the concept of quantum periodicity. It works by first finding the order of a randomly chosen integer modulo the integer to be factored. The order is then used to find the period of a certain quantum function. This period is then used to find the prime factors of the integer.
    <br>
    <br>Shor's algorithm is a significant breakthrough in the field of quantum computing. It has shown that quantum computers can solve problems that are intractable for classical computers, and it has opened up new possibilities for cryptography and other fields.
    <br>
    <br>Here is a more detailed explanation of Shor's algorithm:
    <br>1. **Quantum Fourier Transform (QFT):** Shor's algorithm begins with the application of the Quantum Fourier Transform (QFT) to the integer to be factored. The QFT is a quantum circuit that maps a given input state to its superposition of all possible output states.
    <br>2. **Modular Exponentiation:** Next, the algorithm performs modular exponentiation using a randomly chosen integer 'a'. This involves calculating the value of 'a' raised to the power of 'n' modulo 'N', where 'N' is the integer to be factored.
    <br>3. **Order Finding:** The order of 'a' modulo 'N' is then determined. The order is the smallest positive integer 'r' such that 'a^r ≡ 1 (mod N)'. This can be done using a quantum subroutine that finds the period of the function 'f(x) = a^x mod N'.
    <br>4. **Period Finding:** The period finding subroutine uses a quantum circuit that applies the QFT and modular exponentiation iteratively to find the period of the function 'f(x) = a^x mod N'.
    <br>5. **Factoring:** Once the period 'r' is known, the prime factors of 'N' can be determined using a greatest common divisor (GCD) algorithm. The GCD of 'r' and 'N-1' is either 'N' itself or a prime factor of 'N'.
    <br>
    <br>Shor's algorithm has significant implications for cryptography, as it threatens the security of RSA encryption. RSA relies on the difficulty of integer factorization, and Shor's algorithm breaks this assumption. While quantum computers are still in their early stages of development, Shor's algorithm has motivated research into post-quantum cryptography, which aims to develop encryption schemes that are secure even against quantum computers."
    <br>[{2023-12-05 retrieved} https://bard.google.com/chat/6a03d9618c9d9a22]
    <a class="clsHide" href="#idCmrQtmalgoShordsn"></a></p>
  <p id="idCmrQtmalgoShornam">name::
    <br>* McsEngl.Shor's-algorithm,
    <br>* McsEngl.qualgo.Shor,
    <a class="clsHide" href="#idCmrQtmalgoShornam"></a></p>
  </section>
  </section>

  <section id="idCmrQtmrscF">
  <h2 id="idCmrQtmrscFH2">info-resource of cmprQntm
    <a class="clsHide" href="#idCmrQtmrscFH2"></a></h2>
  <p id="idCmrQtmrscFdsn">description::
    <br>* {2021-06-16} https://www.weforum.org/agenda/2021/06/quantum-revolution-is-almost-here-we-need-to-make-sure-it-benefits-the-many-not-the-few,
    <br>* {2020-12-03} Physicists in China challenge Google’s ‘quantum advantage’: Photon-based quantum computer does a calculation that ordinary computers might never be able to do, https://www.nature.com/articles/d41586-020-03434-7,
    <a class="clsHide" href="#idCmrQtmrscFdsn"></a></p>
  <p id="idCmrQtmrscFnam">name::
    <br>* McsEngl.cmprQntm'Infrsc,
    <a class="clsHide" href="#idCmrQtmrscFnam"></a></p>
  </section>

  <section id="idCmrQtmqith">
  <h2 id="idCmrQtmqithH2">quantum-information-theory of cmprQntm
    <a class="clsHide" href="#idCmrQtmqithH2"></a></h2>
  <p id="idCmrQtmqithdsn">description::
    <br>">quantum information theory evolution:
    <br>The evolution of quantum information theory (QIT) has been a remarkable journey, marked by groundbreaking discoveries and transformative applications. It has emerged as a vibrant and rapidly developing field that has revolutionized our understanding of information and its processing.
    <br>
    <br>**Early Foundations**
    <br>The roots of QIT can be traced back to the early 20th century with the development of quantum mechanics. In 1935, Erwin Schrödinger introduced the concept of quantum entanglement, which highlights the profound interconnectedness of quantum systems. This concept laid the foundation for quantum cryptography and quantum teleportation, two of the most celebrated applications of QIT.
    <br>
    <br>**Classic Breakthroughs**
    <br>In the 1980s, Charles Bennett and Gilles Brassard invented quantum key distribution (QKD), a secure communication protocol that utilizes quantum entanglement to establish a shared secret key between two parties. This breakthrough demonstrated the potential of quantum mechanics to revolutionize cryptography and provide unbreakable communication.
    <br>In the 1990s, Artur Ekert proposed quantum teleportation, a process that allows for the transfer of quantum information from one location to another without physically sending the quantum state itself. This remarkable feat showcased the ability of quantum mechanics to outperform classical communication in certain scenarios.
    <br>
    <br>**Emerging Applications**
    <br>QIT has continued to flourish in the 21st century, with numerous advancements and emerging applications. Quantum computation, the pursuit of building computers that harness quantum mechanics for superior computational power, has made significant progress. Quantum simulations, which employ quantum systems to model complex physical phenomena, have opened up new avenues for research in various fields.
    <br>The field of quantum sensing, which utilizes the unique properties of quantum systems to enhance sensing capabilities, has also seen remarkable progress. Quantum imaging has demonstrated the ability to achieve unprecedented resolution and sensitivity, while quantum metrology has enabled precise measurement of physical parameters.
    <br>
    <br>**Challenges and Opportunities**
    <br>Despite its remarkable progress, QIT still faces significant challenges. Building and maintaining quantum systems is a complex and expensive endeavor. Entanglement, a key resource in QIT, can be challenging to generate and maintain over long distances. Practical implementations of QIT protocols also face technological hurdles.
    <br>However, these challenges have not deterred the growing community of QIT researchers and practitioners. The potential benefits of QIT, such as unbreakable cryptography, ultra-fast computation, and enhanced sensing, are so profound that the field continues to attract enthusiastic and talented individuals.
    <br>
    <br>**Future Outlook**
    <br>As research in QIT intensifies, we can expect to see further breakthroughs and the development of practical applications that transform our world. QIT is poised to revolutionize industries such as finance, healthcare, and materials science, leading to innovation and advancements that were once unimaginable.
    <br>
    <br>The evolution of QIT is a testament to the power of human ingenuity and the pursuit of knowledge. As we delve deeper into the mysteries of quantum mechanics, we are unlocking new possibilities for information processing and technological advancement, shaping the future of our world."
    <br>[{2023-12-05 retrieved} https://bard.google.com/chat/0ac03f750439e0d6]
    <a class="clsHide" href="#idCmrQtmqithdsn"></a></p>
  <p id="idCmrQtmqithnam">name::
    <br>* McsEngl.QIT!=quantum-information-theory,
    <br>* McsEngl.cmprQntm'quantum-information-theory,
    <a class="clsHide" href="#idCmrQtmqithnam"></a></p>

  <section id="idCmrQtmqinf">
  <h3 id="idCmrQtmqinfH3">quantum-information of cmprQntm
    <a class="clsHide" href="#idCmrQtmqinfH3"></a></h3>
  <p id="idCmrQtmqinfdsn">description::
    <br>">quantum information vs information:
    <br>Quantum information and classical information are two different concepts that arise from the principles of quantum mechanics and classical physics, respectively. Let's explore the key differences between quantum information and classical information:
    <br>
    <br>1. **Nature of Information:**
    <br>   - **Classical Information:** In classical information theory, information is represented using classical bits. Classical bits can exist in one of two states: 0 or 1.
    <br>   - **Quantum Information:** In quantum information theory, information is represented using quantum bits or qubits. Qubits can exist in multiple states simultaneously, thanks to the principles of superposition. This allows quantum computers to perform certain calculations much more efficiently than classical computers for specific tasks.
    <br>
    <br>2. **Superposition:**
    <br>   - **Classical Information:** Classical bits exist in one of two states at any given time (0 or 1).
    <br>   - **Quantum Information:** Qubits can exist in a superposition of states, meaning they can be in multiple states at once. This property allows quantum computers to process information in parallel, potentially solving certain problems faster than classical computers.
    <br>
    <br>3. **Entanglement:**
    <br>   - **Classical Information:** Classical bits are independent of each other. The state of one bit does not affect the state of another.
    <br>   - **Quantum Information:** Qubits can be entangled, which means the state of one qubit is directly related to the state of another, no matter how far apart they are. This phenomenon can be used for quantum communication and quantum teleportation.
    <br>
    <br>4. **Measurement:**
    <br>   - **Classical Information:** Measurements in classical information are deterministic. The act of measuring a classical bit reveals its state with certainty.
    <br>   - **Quantum Information:** Measurements in quantum information can be probabilistic. When a qubit is measured, it "collapses" into one of its possible states with a certain probability, influenced by its superposition.
    <br>
    <br>5. **Uncertainty Principle:**
    <br>   - **Classical Information:** Classical physics follows the laws of classical mechanics, where the position and momentum of particles can be precisely determined.
    <br>   - **Quantum Information:** Quantum mechanics introduces the uncertainty principle, stating that certain pairs of properties (like position and momentum) cannot both be precisely determined simultaneously. This fundamental aspect of quantum physics has implications for the precision of measurements in quantum information.
    <br>
    <br>In summary, while classical information is based on classical physics and binary bits, quantum information leverages the unique principles of quantum mechanics, including superposition, entanglement, and probabilistic measurement, to process information in ways that classical systems cannot. Quantum information has the potential to revolutionize computing, communication, and cryptography by exploiting these quantum phenomena."
    <br>[{2023-12-05 retrieved} https://chat.openai.com/c/43b02188-904b-4070-841c-1ee222c490ef]
    <a class="clsHide" href="#idCmrQtmqinfdsn"></a></p>
  <p id="idCmrQtmqinfnam">name::
    <br>* McsEngl.info.quantum!⇒quinfo,
    <br>* McsEngl.quantum-info!⇒quinfo,
    <br>* McsEngl.quantum-information!⇒quinfo,
    <br>* McsEngl.quinfo!=quantum-info,
    <a class="clsHide" href="#idCmrQtmqinfnam"></a></p>
  </section>
  </section>

  <section id="idCmrQtmevlg">
  <h2 id="idCmrQtmevlgH2">computing (<a class="clsPreview" href="../dirEdu/McsEdu000007.last.html#idSCmpr008">link</a>) of cmprQntm
    <a class="clsHide" href="#idCmrQtmevlgH2"></a></h2>
  </section>

  <section id="idCmrQtmevlg">
  <h2 id="idCmrQtmevlgH2">evoluting of cmprQntm
    <a class="clsHide" href="#idCmrQtmevlgH2"></a></h2>
  <p id="idCmrQtmevlgdsn">description::
    <br>">evolution of quantum-computing:
    <br>The evolution of quantum computing is a fascinating and rapidly advancing field that has seen significant progress over the years. Quantum computing is fundamentally different from classical computing, as it harnesses the principles of quantum mechanics to perform calculations. Here's an overview of its evolution:
    <br>
    <br>1. Early Theoretical Foundations (1980s):
    <br>   - In the 1980s, renowned physicist Richard Feynman proposed the concept of quantum computers as a way to efficiently simulate quantum systems.
    <br>   - David Deutsch and others developed the theoretical underpinnings of quantum computation, introducing the concept of quantum algorithms.
    <br>
    <br>2. Shor's Algorithm and Grover's Algorithm (1990s):
    <br>   - Peter Shor's algorithm, in 1994, demonstrated the potential of quantum computing by factoring large numbers exponentially faster than classical computers, posing a significant threat to modern encryption.
    <br>   - Lov Grover developed Grover's algorithm, which provides a quadratic speedup for searching unsorted databases.
    <br>
    <br>3. Experimental Realization (Late 1990s - Early 2000s):
    <br>   - The first quantum algorithms were implemented using NMR (nuclear magnetic resonance) technology and ion-trap techniques, marking the experimental realization of quantum computation.
    <br>   - IBM and other organizations made early strides in building quantum computers, but they were very limited in terms of qubit count and error rates.
    <br>
    <br>4. Quantum Hardware Advancements (2010s):
    <br>   - Several companies, such as IBM, Google, Rigetti, and others, started to develop quantum hardware, gradually increasing the number of qubits and improving error correction and control techniques.
    <br>   - Superconducting qubits and trapped ions became the leading technologies for building quantum processors.
    <br>
    <br>5. Quantum Supremacy (2019):
    <br>   - In 2019, Google claimed to have achieved quantum supremacy by demonstrating that their 53-qubit quantum processor, Sycamore, could perform a specific task faster than the world's most advanced classical supercomputers.
    <br>
    <br>6. Quantum Software and Algorithms:
    <br>   - Researchers continued to develop quantum algorithms for various applications, including cryptography, optimization, and machine learning.
    <br>   - The development of quantum programming languages, such as Qiskit, Cirq, and Quipper, made it easier to work with quantum computers.
    <br>
    <br>7. Growing Ecosystem:
    <br>   - The quantum computing ecosystem expanded with more startups, academic research, and corporate interest, resulting in a diverse range of quantum hardware and software offerings.
    <br>
    <br>8. Quantum Cloud Services (Late 2010s - Present):
    <br>   - Companies like IBM, Amazon (Braket), Microsoft (Azure Quantum), and others began offering quantum computing services through the cloud, making quantum resources more accessible.
    <br>
    <br>9. Quantum Error Correction (Ongoing):
    <br>   - Quantum error correction codes and techniques are continually being researched and developed to mitigate the effects of qubit errors, improving the overall stability of quantum computers.
    <br>
    <br>10. Future Outlook:
    <br>    - Quantum computing is expected to continue evolving, with the goal of solving complex problems in fields like drug discovery, materials science, and cryptography.
    <br>    - Achieving fault-tolerant quantum computing with error rates low enough for practical applications remains a significant challenge, but ongoing research is making progress in this direction.
    <br>
    <br>The evolution of quantum computing is a dynamic and rapidly progressing field, with the potential to revolutionize various industries by solving problems that are currently beyond the reach of classical computers."
    <br>[{2023-11-05 retrieved} ]
    <a class="clsHide" href="#idCmrQtmevlgdsn"></a></p>
  <p id="idCmrQtmevlg2020">{2020}::
    <br>2020: IBM demonstrates that its 65-qubit quantum processor can perform calculations beyond the reach of any classical computer
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg2020"></a></p>

  <p id="idCmrQtmevlg2019">{2019}::
    <br>2019: Google announces that it has achieved quantum supremacy by performing a calculation on a 53-qubit quantum processor that would take a classical supercomputer thousands of years to complete
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg2019"></a></p>

  <p id="idCmrQtmevlg2007">{2007}::
    <br>2007: D-Wave Systems claims to have built the first commercial quantum computer, but its validity is disputed by many experts
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg2007"></a></p>

  <p id="idCmrQtmevlg2001">{2001}::
    <br>2001: IBM researchers implement Grover’s algorithm using NMR techniques and achieve a modest speedup over classical algorithms
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg2001"></a></p>

  <p id="idCmrQtmevlg2000">{2000}::
    <br>2000: David DiVincenzo proposes five criteria for building a practical quantum computer, known as the DiVincenzo criteria
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg2000"></a></p>

  <p id="idCmrQtmevlg1997">{1997}::
    <br>1997: Isaac Chuang, Neil Gershenfeld, and Mark Kubinec demonstrate the first implementation of Shor’s algorithm using nuclear magnetic resonance (NMR) techniques
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1997"></a></p>

  <p id="idCmrQtmevlg1996">{1996}::
    <br>1996: Lov Grover invents an algorithm that can search an unsorted database in square root time using a quantum computer, known as Grover’s algorithm
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1996"></a></p>

  <p id="idCmrQtmevlg1994">{1994}::
    <br>1994: Peter Shor discovers an algorithm that can factor large numbers in polynomial time using a quantum computer, known as Shor’s algorithm
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1994"></a></p>

  <p id="idCmrQtmevlg1992">{1992}::
    <br>1992: David Deutsch and Richard Jozsa extend their algorithm to handle multiple inputs, known as the Deutsch-Jozsa algorithm
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1992"></a></p>

  <p id="idCmrQtmevlg1991">{1991}::
    <br>1991: Artur Ekert proposes another protocol for quantum key distribution based on quantum entanglement, known as the E91 protocol
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1991"></a></p>

  <p id="idCmrQtmevlg1985">{1985}::
    <br>1985: David Deutsch and Richard Jozsa devise an algorithm that can solve a specific problem faster than any classical algorithm, known as the Deutsch-Jozsa algorithm
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1985"></a></p>

  <p id="idCmrQtmevlg1984">{1984}::
    <br>1984: Charles Bennett and Gilles Brassard develop a protocol for quantum key distribution, which allows two parties to securely exchange cryptographic keys using quantum states
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1984"></a></p>

  <p id="idCmrQtmevlg1982">{1982}::
    <br>1982: David Deutsch generalizes Benioff’s model and proposes the concept of a universal quantum computer
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1982"></a></p>

  <p id="idCmrQtmevlg1981">{1981}::
    <br>1981: Richard Feynman suggests that simulating quantum systems would require a new type of computer based on quantum mechanics
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1981"></a></p>

  <p id="idCmrQtmevlg1980">{1980}::
    <br>1980: Paul Benioff proposes a model of a quantum Turing machine, a theoretical device that can perform any computation using quantum mechanical principles
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1980"></a></p>

  <p id="idCmrQtmevlg1973">{1973}::
    <br>1973: Alexander Holevo proves that n qubits cannot carry more than n classical bits of information, known as Holevo’s theorem or Holevo’s bound
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1973"></a></p>

  <p id="idCmrQtmevlg1965">{1965}::
    <br>1965: John Bell proves that quantum entanglement cannot be explained by any local hidden variable theory, known as Bell’s theorem
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1965"></a></p>

  <p id="idCmrQtmevlg1961">{1961}::
    <br>1961: Rolf Landauer shows that erasing a bit of information dissipates a minimum amount of energy, known as Landauer’s principle
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1961"></a></p>

  <p id="idCmrQtmevlg1957">{1957}::
    <br>1957: Hugh Everett proposes the many-worlds interpretation of quantum mechanics, which suggests that every possible outcome of a quantum measurement actually occurs in a parallel universe
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1957"></a></p>

  <p id="idCmrQtmevlg1944">{1944}::
    <br>1944: John von Neumann publishes Mathematical Foundations of Quantum Mechanics, a rigorous mathematical framework for quantum theory
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1944"></a></p>

  <p id="idCmrQtmevlg1935">{1935}::
    <br>1935: Erwin Schrödinger develops a thought experiment involving a cat that is simultaneously dead and alive, and coins the term “quantum entanglement”
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1935"></a></p>

  <p id="idCmrQtmevlg1935">{1935}::
    <br>1935: Albert Einstein, Boris Podolsky, and Nathan Rosen publish a paper highlighting the counterintuitive nature of quantum superposition and arguing that quantum mechanics is incomplete
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1935"></a></p>

  <p id="idCmrQtmevlg1930">{1930}::
    <br>1930: Paul Dirac publishes The Principles of Quantum Mechanics, a standard textbook on quantum theory
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1930"></a></p>

  <p id="idCmrQtmevlg19251927">{1925..1927}::
    <br>1925..1927: Niels Bohr and Werner Heisenberg develop the Copenhagen interpretation, one of the earliest and most common interpretations of quantum mechanics
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg19251927"></a></p>

  <p id="idCmrQtmevlg1925">{1925}::
    <br>1925: Werner Heisenberg, Max Born, and Pascual Jordan formulate matrix mechanics, the first formulation of quantum mechanics
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1925"></a></p>

  <p id="idCmrQtmevlg1924">{1924}::
    <br>1924: Max Born uses the term quantum mechanics for the first time
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1924"></a></p>

  <p id="idCmrQtmevlg1905">{1905}::
    <br>1905: Albert Einstein explains the photoelectric effect and suggests that light consists of quantum particles or photons
    <br>[{2023-09-15 retrieved} https://twitter.com/PhysInHistory/status/1702696371893993821]
    <a class="clsHide" href="#idCmrQtmevlg1905"></a></p>
  <p id="idCmrQtmevlgnam">name::
    <br>* McsEngl.evoluting-of-cmprQntm,
    <br>* McsEngl.cmprQntm'evoluting,
    <a class="clsHide" href="#idCmrQtmevlgnam"></a></p>
  </section>
</section>

<section id="idCmr004">
  <h1 id="idCmr004H1">techCmpr.neuromorphic
    <a class="clsHide" href="#idCmr004H1"></a></h1>
  <p id="idCmr004dsn">description::
    <br>">neuromorphic computer:
    <br>Neuromorphic computing is a revolutionary approach to computing that is inspired by the structure and function of the human brain. Neuromorphic computers, also known as brain-inspired computers, are designed to mimic the way in which the brain processes information, using artificial neurons and synapses to perform computations. This approach has the potential to overcome many of the limitations of traditional computing architectures, such as their energy inefficiency and inability to handle real-time tasks.
    <br>**Key Features of Neuromorphic Computing:**
    <br>1. **Parallel Processing:** Neuromorphic computers are designed to process information in a parallel fashion, similar to the way the brain does. This allows them to handle complex tasks much more efficiently than traditional computers, which are limited by their serial processing architecture.
    <br>2. **Energy Efficiency:** Neuromorphic computing is inherently more energy efficient than traditional computing due to its parallel processing nature. Neuromorphic chips can consume orders of magnitude less power than traditional CPUs and GPUs, making them ideal for applications where power consumption is a critical concern.
    <br>3. **Adaptive Learning:** Neuromorphic computers can learn and adapt to new situations, just like the human brain. This is because they are equipped with artificial neurons that can adjust their connections and behavior based on the information they receive. This ability to learn makes neuromorphic computers well-suited for tasks such as pattern recognition, anomaly detection, and autonomous decision-making.
    <br>**Applications of Neuromorphic Computing:**
    <br>Neuromorphic computing has the potential to revolutionize a wide range of industries, including:
    <br>1. **Robotics:** Neuromorphic computers can be used to create more intelligent and agile robots that can interact with the world in more natural ways.
    <br>2. **Healthcare:** Neuromorphic computers can be used to develop new medical devices, such as prosthetics and brain-computer interfaces.
    <br>3. **Autonomous Vehicles:** Neuromorphic computers can be used to power fully autonomous vehicles that can navigate safely and efficiently in real-world environments.
    <br>4. **Sensory Networks:** Neuromorphic computers can be used to develop distributed sensor networks that can gather and process information from the physical world.
    <br>5. **Artificial Intelligence:** Neuromorphic computing can be used to develop new AI algorithms that are more efficient, scalable, and energy-efficient than traditional algorithms.
    <br>**Challenges and Future of Neuromorphic Computing:**
    <br>Despite its promise, neuromorphic computing faces a number of challenges, including:
    <br>1. **Complexity:** Building neuromorphic computers that can match the complexity of the human brain is a complex and challenging task.
    <br>2. **Scalability:** Scaling neuromorphic computers to large sizes while maintaining performance and efficiency is another major challenge.
    <br>3. **Software Development:** Developing software for neuromorphic computers is a new and challenging field, requiring new programming languages and algorithms.
    <br>Despite these challenges, the potential benefits of neuromorphic computing are so great that researchers are continuing to invest significant resources in developing this new technology. As neuromorphic computing continues to mature, it is likely to have a profound impact on the way we compute, interact with the world, and even understand ourselves.
    <br>I hope this helps!"
    <br>[{2024-01-25 retrieved} https://bard.google.com/chat/6213801919cd9565]
    <a class="clsHide" href="#idCmr004dsn"></a></p>
  <p id="idCmr004nam">name::
    <br>* McsEngl.cmprNuro!=neuromorphic-computer,
    <br>* McsEngl.neuromorphic-computer!⇒cmprNuro,
    <br>* McsEngl.techCmpr.004-neuromorphic!⇒cmprNuro,
    <br>* McsEngl.techCmpr.neuromorphic!⇒cmprNuro,
    <a class="clsHide" href="#idCmr004nam"></a></p>

  <section id="idCmr004evlg">
  <h2 id="idCmr004evlgH2">evoluting of cmprNuro
    <a class="clsHide" href="#idCmr004evlgH2"></a></h2>
  <p id="idCmr004evlgdsn">description::
    <br>">timeline of neuromorphic computers:
    <br>Here's a timeline of key milestones in the development of neuromorphic computing:
    <br>**Early Concepts and Inspiration (1943-1950)**
    <br>1943: Warren McCulloch and Walter Pitts introduce the McCulloch-Pitts neuron model, a simplified mathematical representation of a biological neuron.
    <br>1949: Donald Hebb proposes the Hebbian learning rule, a fundamental principle for how synapses, the connections between neurons, are strengthened or weakened during learning.
    <br>1950: Alan Turing publishes his seminal paper, "Computing Machinery and Intelligence," which introduces the Turing test, a benchmark for assessing machine intelligence.
    <br>**Early Neuromorphic Hardware Development (1950s-1980s)**
    <br>1957: Leon Chua proposes the Chua's circuit, an electronic circuit that can exhibit chaotic behavior similar to the dynamics of biological neurons.
    <br>1969: Marvin Minsky and Seymour Papert publish their book, "Perceptrons," which critiques the limitations of early neural networks and sparks a debate about the feasibility of artificial intelligence.
    <br>1970s: Carver Mead develops the concept of "neuromorphic engineering," advocating for the design of electronic circuits inspired by the structure and function of the brain.
    <br>1980s: John Hopfield introduces the Hopfield network, a type of neural network that can be used for associative memory and pattern recognition.
    <br>**Rise of Neuromorphic Computing in the 21st Century (2000s-present)**
    <br>2001: IBM researchers develop the "Spiking Neural Network (SNN)" simulator, enabling researchers to simulate networks of spiking neurons in silico.
    <br>2006: HP Labs introduces the "NeuroRAM," a non-volatile memory architecture inspired by the neural structure of the brain.
    <br>2011: Intel announces the development of the "Loihi" neuromorphic chip, one of the first commercial neuromorphic processors.
    <br>2012: IBM unveils the "TrueNorth" neuromorphic chip, a highly parallel chip with over 500 million artificial neurons.
    <br>2016: Hewlett Packard Enterprise (HPE) introduces the "Neuromorphic Adaptive Processor (NAP)" chip, designed for real-time sensory processing.
    <br>2017: Intel releases the "Pohoiki Springs" neuromorphic research chip, capable of simulating over 100 billion synapses.
    <br>2020: IBM and Samsung collaborate on the development of the "Neuromorphic Research Chip (NRC)" based on the Spiking Neural Network Architecture (SNN).
    <br>**Current Trends and Future Directions**
    <br>Researchers are continuing to develop more powerful and efficient neuromorphic chips, focusing on improving energy efficiency, scalability, and the ability to handle complex tasks. The applications of neuromorphic computing are expanding into areas such as robotics, artificial intelligence, autonomous systems, and healthcare. As neuromorphic technology matures, it has the potential to revolutionize computing and have a profound impact on various industries.
    <br>I hope this timeline provides a comprehensive overview of the development of neuromorphic computing. The field is rapidly evolving, and we can expect to see even more exciting breakthroughs in the years to come."
    <br>[{2024-01-25 retrieved} https://bard.google.com/chat/6213801919cd9565]
    <a class="clsHide" href="#idCmr004evlgdsn"></a></p>
  <p id="idCmr004evlgnam">name::
    <br>* McsEngl.evoluting-of-cmprNuro,
    <br>* McsEngl.cmprNuro'evoluting,
    <a class="clsHide" href="#idCmr004evlgnam"></a></p>
  </section>
</section>

<section id="idCmrMdrn2010s">
  <h1 id="idCmrMdrn2010sH1">techCmpr.modern2010s
    <a class="clsHide" href="#idCmrMdrn2010sH1"></a></h1>
  <p id="idCmrMdrn2010sdsn">description::
    <br>· modern2010s-computer I call <a class="clsPreview" href="#idCmr001">a-binary</a>, <a class="clsPreview" href="#idCmrPhcl">physical</a>, <a class="clsPreview" href="#idCmrGlps">general-purpose</a>, microprocessor-computer of <a href="https://en.wikipedia.org/wiki/2010s">2010s</a>.
    <a class="clsHide" href="#idCmrMdrn2010sdsn"></a></p>
  <p id="idCmrMdrn2010snam">name::
    <br>* McsEngl.techCmpr.modern2010s!⇒cmrModern2010s,
    <br>* McsEngl.cmrModern2010s,
    <br>* McsEngl.modern2010s-computer!⇒cmrModern2010s,
    <a class="clsHide" href="#idCmrMdrn2010snam"></a></p>
</section>

<section id="idCmrPhone">
  <h1 id="idCmrPhoneH1">techCmpr.smartphone
    <a class="clsHide" href="#idCmrPhoneH1"></a></h1>
  <p id="idCmrPhonenam">name::
    <br>* McsEngl.cmrPhone,
    <br>* McsEngl.techCmpr.phone!⇒cmrPhone,
    <br>* McsEngl.techCmpr.smartphone!⇒cmrPhone,
    <br>* McsEngl.smartphone!⇒cmrPhone,
    <a class="clsHide" href="#idCmrPhonenam"></a></p>
  <p id="idCmrPhonedsn">description::
    <br>· smartphone is a-small-computer which is also a-cellphone and a-pocket-computer.
    <a class="clsHide" href="#idCmrPhonedsn"></a></p>

  <section id="idCmrPhonehlth">
  <h2 id="idCmrPhonehlthH2">health-issue of cmrPhone
    <a class="clsHide" href="#idCmrPhonehlthH2"></a></h2>
  <p id="idCmrPhonehlthnam">name::
    <br>* McsEngl.cmrPhone'health-issue,
    <a class="clsHide" href="#idCmrPhonehlthnam"></a></p>
  <p id="idCmrPhonehlthwpa">addressWpg::
    <br>* https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4350886/,
    <a class="clsHide" href="#idCmrPhonehlthwpa"></a></p>

  <section id="idCmrPhoneSar">
  <h3 id="idCmrPhoneSarH3">SAR of cmrPhone
    <a class="clsHide" href="#idCmrPhoneSarH3"></a></h3>
  <p id="idCmrPhoneSarnam">name::
    <br>* McsEngl.cmrPhone'SAR,
    <br>* McsEngl.SAR-of-cmrPhone,
    <br>* McsEngl.specific-absorption-rate--of-cmrPhone,
    <br>====== langoGreek:
    <br>* McsElln.ειδικός-ρυθμός-απορρόφισης-ακτινοβολίας!=Sar,
    <a class="clsHide" href="#idCmrPhoneSarnam"></a></p>
  <p id="idCmrPhoneSardsn">description::
    <br>"There is considerable confusion and misunderstanding about the meaning of the maximum reported Specific Absorption Rate (SAR) values for cell phones (and other wireless devices). SAR is a measure of the rate of RF (radiofrequency) energy absorption by the body from the source being measured – in this case, a cell phone. SAR provides a straightforward means for measuring the RF exposure characteristics of cell phones to ensure that they are within the safety guidelines set by the FCC.
    <br>Many people mistakenly assume that using a cell phone with a lower reported SAR value necessarily decreases a user’s exposure to RF emissions, or is somehow “safer” than using a cell phone with a high SAR value. While SAR values are an important tool in judging the maximum possible exposure to RF energy from a particular model of cell phone, a single SAR value does not provide sufficient information about the amount of RF exposure under typical usage conditions to reliably compare individual cell phone models. Rather, the SAR values collected by the FCC are intended only to ensure that the cell phone does not exceed the FCC’s maximum permissible exposure levels even when operating in conditions which result in the device’s highest possible – but not its typical - RF energy absorption for a user.
    <br>... ALL cell phones must meet the FCC’s RF exposure standard, which is set at a level well below that at which laboratory testing indicates, and medical and biological experts generally agree, adverse health effects could occur. For users who are concerned with the adequacy of this standard or who otherwise wish to further reduce their exposure, the most effective means to reduce exposure are to hold the cell phone away from the head or body and to use a speakerphone or hands-free accessory. These measures will generally have much more impact on RF energy absorption than the small difference in SAR between individual cell phones, which, in any event, is an unreliable comparison of RF exposure to consumers, given the variables of individual use."
    <br>[https://www.fcc.gov/consumers/guides/specific-absorption-rate-sar-cell-phones-what-it-means-you]
    <br>===
    <br>there are a few helpful things you can do to reduce the SAR value of your mobile phone right now.
    <br>* Reduce SAR value by using earphone,
    <br>* Lower SAR value by using speakerphone,
    <br>* Use your phone as short as possible,
    <br>* Use special materia headphone,
    <br>* Avoiding use phone while its signal is weak,
    <br>[https://www.gearbest.com/blog/how-to/how-to-reduce-the-sar-value-of-your-cell-phone-2272]
    <a class="clsHide" href="#idCmrPhoneSardsn"></a></p>
  <p id="idCmrPhoneSarwpa">addressWpg::
    <br>* https://www.fcc.gov/consumers/guides/specific-absorption-rate-sar-cell-phones-what-it-means-you,
    <br>* https://www.gearbest.com/blog/how-to/how-to-reduce-the-sar-value-of-your-cell-phone-2272,
    <a class="clsHide" href="#idCmrPhoneSarwpa"></a></p>
  </section>
  </section>
</section>

<section id="idCmrCgnv">
  <h1 id="idCmrCgnvH1">techCmpr.cognitive
    <a class="clsHide" href="#idCmrCgnvH1"></a></h1>
  <p id="idCmrCgnvdsn">description::
    <br>"A cognitive computer is a computer that hardwires artificial intelligence and machine-learning algorithms into an integrated circuit (printed circuit board) that closely reproduces the behavior of the human brain.[1] It generally adopts a neuromorphic engineering approach. Synonyms are neuromorphic chip and cognitive chip.[2][3]
    <br>An example of an cognitive computer implemented using neural networks and deep learning techniques is IBM's Watson machine.[4] A subsequent development by IBM is the 2014 TrueNorth microchip architecture,[5] which is designed to be closer in structure to the human brain than the von Neumann architecture used in conventional computers.[1] In 2017 Intel also announced its own version of a cognitive chip in "Loihi", which it intended to be available to university and research labs in 2018. Intel, Qualcomm, and others are improving neuromorphic processors steadily, Intel with its Pohoiki Beach and Springs systems.[6][7]"
    <br>[{2023-04-04 retrieved} https://en.wikipedia.org/wiki/Cognitive_computer]
    <a class="clsHide" href="#idCmrCgnvdsn"></a></p>
  <p id="idCmrCgnvnam">name::
    <br>* McsEngl.cognitive-chip,
    <br>* McsEngl.cognitive-techCmpr,
    <br>* McsEngl.techCmpr.cognitive,
    <br>* McsEngl.neuromorphic-chip,
    <a class="clsHide" href="#idCmrCgnvnam"></a></p>
</section>

<section id="idMeta">
  <h1 id="idMetaH1">meta-info
    <a class="clsHide" href="#idMetaH1"></a></h1>
  <p id="idMetaCounter" class="clsCenter">this webpage was-visited
    <span class="clsColorRed">
    <script src="../../dirPgm/dirCntr/counter.php?page=McsTchInf000003"></script>
    </span>
    times since {2019-07-14}</p>
  <!-- the content of page-path paragraph is displayed as it is on top of toc -->
  <p id="idMetaWebpage_path"><span class="clsB clsColorGreen">page-wholepath</span>:
    <a class="clsPreview" href="../../#idOverview">synagonism.net</a> /
    <a class="clsPreview" href="../Mcs000000.last.html#idOverview">worldviewSngo</a> /
    <a class="clsPreview" href="../dirTchInf/McsTchInf000000.last.html#idOverview">dirTchInf</a> /
    techCmpr
    </p>
  <p id="idMetaP1">SEARCH::
    <br>· this page uses '<span class="clsColorRed">locator-names</span>', names that when you find them, you find the-LOCATION of the-concept they denote.
    <br>⊛ <strong>GLOBAL-SEARCH</strong>:
    <br>· clicking on <span class="clsColorGreenBg">the-green-BAR of a-page</span> you have access to the-global--locator-names of my-site.
    <br>· use the-prefix '<span class="clsColorRed">techCmpr</span>' for <a class="clsPreview" href="../dirCor/filMcs.last.html#idOverview">structured-concepts</a> related to current concept 'computer-machine'.    <br>⊛ <strong>LOCAL-SEARCH</strong>:
    <br>· TYPE <span class="clsColorRed">CTRL+F "McsEngl.words-of-concept's-name"</span>, to go to the-LOCATION of the-concept.
    <br>· a-preview of the-description of a-global-name makes reading fast.
    <a class="clsHide" href="#idMetaP1"></a></p>
  <p id="idFooterP1">footer::
    <br>• author: <a class="clsPreview" href="../../#idAboutme">Kaseluris.Nikos.1959</a>
    <br>• email:
    <br> &nbsp;<img src="../../misc/img/mail.png" alt="imgMail">
    <br>• twitter: <a href="https://twitter.com/synagonism">@synagonism</a>
    <br>• steemit: <a href="https://steemit.com/synagonism">https://steemit.com/@synagonism</a>
    <a class="clsHide" href="#idFooterP1"></a></p>
  <!--                              -->
  <p id="idMetaVersion">webpage-versions::
    <br>• version.last.dynamic: <a class="clsPreview" href="../dirTchInf/McsTchInf000003.last.html">McsTchInf000003.last.html</a>,
    <br>• version.1-0-0.2021-04-08: (0-11) <a href="../../dirMiwMcs/dirTchInf/filMcsCmr.1-0-0.2021-04-08.html">../../dirMiwMcs/dirTchInf/filMcsCmr.1-0-0.2021-04-08.html</a>,
    <br>• version.0-1-0.2019-07-14 draft creation,
    <a class="clsHide" href="#idMetaVersion"></a></p>
</section>

<section id="idSupport">
  <h1 id="idSupportH1">support (<a class="clsPreview" href="../../#idSupport">link</a>)</h1>
  <p></p>
</section>


<script type="module">
  import * as oMcsh from '../Mcsmgr/mMcsh.js'
</script>
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-N8T0MHWLS1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-N8T0MHWLS1');
</script>
</body>
</html>