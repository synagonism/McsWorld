<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Mcs.lagKnlg-(McsTchInf000039.0-1-0.2023-10-23 draft) knowledge-language</title>
  <meta name="keywords" content="knowledge-language, lagKnlg, ModelConceptSensorial, McsHitp, Synagonism">
  <link rel="stylesheet" href="../Mcsmgr/mHitp.css">
</head>

<body>
<header id="idHeader">
  <p></p>
  <h1 id="idHeaderH1">knowledge-language
    <br>senso-concept-Mcs (lagKnlg)
    </h1>
  <p id="idHeadercrd">McsHitp-creation:: {2023-10-23}
    <a class="clsHide" href="#idHeadercrd"></a></p>
</header>

<section id="idOverview">
  <h1 id="idOverviewH1">overview of lagKnlg
    <a class="clsHide" href="#idOverviewH1"></a></h1>
  <p id="idDescription">description::
    <br>· knowledge-language is <a class="clsPreview" href="../dirTchInf/McsTchInf000005.last.html#idOverview">a-computer-language</a> that represents and manages conceptual-systems from <a class="clsPreview" href="../dirLag/McsLag000007.last.html#idLHmnmipt1">mind-views</a> or <a class="clsPreview" href="../dirLag/McsLag000007.last.html#idLHmnmopt">logo-views</a>.
    <a class="clsHide" href="#idDescription"></a></p>
  <p id="idName">name::
    <br>* McsEngl.McsTchInf000039.last.html//dirTchInf//dirMcs!⇒lagKnlg,
    <br>* McsEngl.dirTchInf/McsTchInf000039.last.html!⇒lagKnlg,
    <br>* McsEngl.knowledge-language!⇒lagKnlg,
    <br>* McsEngl.lagKnlg,
    <br>* McsEngl.lagKnlg!=McsTchInf000039,
    <br>* McsEngl.lagKnlg!=knowledge-language,
    <br>====== langoGreek:
    <br>* McsElln.γλώσσα-γνώσης!=lagKnlg,
    <a class="clsHide" href="#idName"></a></p>
</section>

<section id="idLKnlgrprl">
  <h1 id="idLKnlgrprlH1">relation-to-programing-language of lagKnlg
    <a class="clsHide" href="#idLKnlgrprlH1"></a></h1>
  <p id="idLKnlgrprldsn">description::
    <br>"knowledge-representation-language vs programming-language:
    <br>Knowledge representation languages (KRLs) and programming languages serve different purposes and have distinct characteristics. Here's a comparison between the two:
    <br>
    <br>1. Purpose:
    <br>   - Knowledge Representation Language (KRL): KRLs are designed to represent and manipulate knowledge or information in a form that is understandable to both humans and machines. They are used in artificial intelligence (AI) and knowledge-based systems to model, store, and reason about information.
    <br>   - Programming Language: Programming languages are used to write instructions and algorithms that tell a computer how to perform specific tasks. They are used for developing software, applications, and systems.
    <br>
    <br>2. Abstraction:
    <br>   - KRLs typically abstract away from low-level implementation details and focus on expressing concepts, facts, and relationships.
    <br>   - Programming languages often deal with low-level details and are used to specify step-by-step procedures for solving problems.
    <br>
    <br>3. Syntax and Semantics:
    <br>   - KRLs often have a more natural language-like syntax and semantics to facilitate easy understanding by domain experts.
    <br>   - Programming languages have syntax and semantics that are designed for precise and unambiguous execution by a computer.
    <br>
    <br>4. Human Readability:
    <br>   - KRLs aim for human readability and comprehension, as they are often used for knowledge sharing, expert systems, and knowledge representation.
    <br>   - Programming languages are primarily meant for machine execution, and their syntax may be more complex and less human-friendly.
    <br>
    <br>5. Inference and Reasoning:
    <br>   - KRLs are designed to support various forms of reasoning and inference, such as deduction, induction, and abduction, which are essential in AI and expert systems.
    <br>   - Programming languages do not inherently provide reasoning capabilities and are focused on algorithm execution.
    <br>
    <br>6. Examples:
    <br>   - Examples of KRLs include RDF (Resource Description Framework), OWL (Web Ontology Language), and Prolog (a logic programming language often used for knowledge representation).
    <br>   - Examples of programming languages include Python, Java, C++, and JavaScript.
    <br>
    <br>7. Use Cases:
    <br>   - KRLs are used in applications like semantic web, expert systems, natural language processing, and knowledge-based systems.
    <br>   - Programming languages are used for developing a wide range of software applications, including web development, mobile apps, desktop applications, and system software.
    <br>
    <br>In summary, KRLs and programming languages are distinct in their purposes and design. KRLs are primarily used for representing and manipulating knowledge in a human-readable format, while programming languages are used to instruct computers to perform specific tasks. While there may be some overlap and integration in certain applications (such as using KRLs to define knowledge bases for AI systems), they remain fundamentally different in their roles and functionalities."
    <br>[{2023-10-23 retrieved} https://chat.openai.com/c/7b4ed7ec-2f8e-4d0b-888c-7ee3aed90417]
    <a class="clsHide" href="#idLKnlgrprldsn"></a></p>
  <p id="idLKnlgrprlnam">name::
    <br>* McsEngl.lagCpgm'relation-to-knowledge-language,
    <br>* McsEngl.lagKnlg'relation-to-programing-language,
    <a class="clsHide" href="#idLKnlgrprlnam"></a></p>
  <p id="idLKnlgrprldsnL">descriptionLong::
    <br>"knowledge-representation-language vs programming-language:
    <br>**Knowledge representation languages (KRLs)** are formal languages used to represent knowledge in a way that can be understood and processed by computers. KRLs are used in a variety of artificial intelligence applications, such as expert systems, natural language processing, and robotics.
    <br>
    <br>**Programming languages**, on the other hand, are used to write programs that perform specific tasks. Programming languages are more general-purpose than KRLs, and can be used to develop a wide range of applications, from web browsers to video games.
    <br>
    <br>**Key differences between KRLs and programming languages:**
    <br>* **Purpose:** KRLs are designed specifically to represent knowledge, while programming languages are designed to write programs.
    <br>* **Expressiveness:** KRLs are typically more expressive than programming languages, meaning that they can represent a wider range of knowledge concepts.
    <br>* **Ease of use:** Programming languages are generally easier to use than KRLs, as they are designed to be programmed by humans.
    <br>* **Performance:** KRLs can be slower than programming languages, as they need to perform additional reasoning tasks.
    <br>
    <br>**Examples of KRLs:**
    <br>* OWL (Web Ontology Language)
    <br>* RDF (Resource Description Framework)
    <br>* Prolog
    <br>* Description logics
    <br>* Frames
    <br>
    <br>**Examples of programming languages:**
    <br>* Python
    <br>* Java
    <br>* C/C++
    <br>* JavaScript
    <br>* Go
    <br>
    <br>**Which one to use?**
    <br>The choice of whether to use a KRL or a programming language depends on the specific application. If the goal is to represent a large amount of knowledge and perform complex reasoning tasks, then a KRL is a good choice. If the goal is to develop a specific application, such as a web browser or a video game, then a programming language is a better choice.
    <br>
    <br>Here are some specific examples of when to use a KRL or a programming language:
    <br>* **Use a KRL:**
    <br>    * To develop an expert system that can diagnose diseases or recommend products.
    <br>    * To build a natural language processing system that can understand and generate human language.
    <br>    * To develop a robotic system that can plan and execute actions in the real world.
    <br>* **Use a programming language:**
    <br>    * To develop a web browser that displays web pages.
    <br>    * To build a video game that allows users to interact with a virtual world.
    <br>    * To develop a mobile app that helps users manage their tasks.
    <br>
    <br>In some cases, it may be beneficial to use a combination of a KRL and a programming language. For example, a KRL can be used to represent the knowledge of an expert system, and a programming language can be used to implement the reasoning engine.
    <br>
    <br>Ultimately, the best way to choose between a KRL and a programming language is to consider the specific requirements of the application."
    <br>[{2023-10-23 retrieved} https://bard.google.com/chat/1217e0651f4ac5a6]
    <a class="clsHide" href="#idLKnlgrprldsnL"></a></p>
</section>

<section id="idLKnlgrscF">
  <h1 id="idLKnlgrscFH1">info-resource of lagKnlg
    <a class="clsHide" href="#idLKnlgrscFH1"></a></h1>
  <p id="idLKnlgrscwpa">addressWpg::
    <br>*
    <a class="clsHide" href="#idLKnlgrscwpa"></a></p>
  <p id="idLKnlgrscnam">name::
    <br>* McsEngl.lagKnlg'Infrsc,
    <a class="clsHide" href="#idLKnlgrscnam"></a></p>
</section>

<section id="idLKnlgdngF">
  <h1 id="idLKnlgdngFH1">DOING of lagKnlg
    <a class="clsHide" href="#idLKnlgdngFH1"></a></h1>
  <p id="idLKnlgdngdsn">description::
    <br>*
    <a class="clsHide" href="#idLKnlgdngdsn"></a></p>
  <p id="idLKnlgdngnam">name::
    <br>* McsEngl.lagKnlg'doing,
    <a class="clsHide" href="#idLKnlgdngnam"></a></p>
</section>

<section id="idLKnlgevgF">
  <h1 id="idLKnlgevgFH1">evoluting of lagKnlg
    <a class="clsHide" href="#idLKnlgevgFH1"></a></h1>
  <p id="idLKnlgevgFdsn">description::
    <br>"evolution of knowledge-representation-languages:
    <br>The evolution of knowledge representation languages (KRLs) can be divided into four broad phases:
    <br>
    <br>**Phase 1: Early KRLs (1960s-1970s)**
    <br>Early KRLs were focused on representing simple facts and relationships. They were often based on Lisp or Prolog, and they used a variety of different representations, such as logical expressions, frames, and rules.
    <br>Some examples of early KRLs include:
    <br>* **SHRDLU** (1970): A language for representing and reasoning about the physical world.
    <br>* **ELIZA** (1966): A language for representing and reasoning about human natural language.
    <br>* **MYCIN** (1972): A language for representing and reasoning about medical knowledge.
    <br>
    <br>**Phase 2: Ontologies and Description Logics (1980s-1990s)**
    <br>In the 1980s and 1990s, there was a growing interest in using KRLs to represent ontologies, which are formal representations of knowledge about a particular domain. This led to the development of new KRLs based on description logics, which are a family of formal logics that are well-suited for representing ontologies.
    <br>Some examples of KRLs from this phase include:
    <br>* **LOOM** (1987): One of the first ontological KRLs.
    <br>* **KL-ONE** (1985): Another early ontological KRL.
    <br>* **SHOE** (1994): A KRL based on description logics that was designed for representing ontologies in a variety of domains.
    <br>
    <br>**Phase 3: The Web Ontology Language (OWL) (2000s)**
    <br>In the 2000s, the Web Ontology Language (OWL) was developed as a standard KRL for representing ontologies on the Web. OWL is based on description logics, and it provides a rich set of features for representing different types of knowledge, such as classes, individuals, properties, and relationships.
    <br>OWL is now the most widely used KRL for representing ontologies in a variety of domains, including bioinformatics, medicine, and engineering.
    <br>
    <br>**Phase 4: Modern KRLs (2010s-present)**
    <br>In recent years, there has been a growing interest in developing new KRLs that are more expressive and powerful than OWL. Some of these new KRLs are based on new formal logics, such as modal logics and temporal logics. Others are based on new machine learning techniques, such as deep learning.
    <br>Some examples of modern KRLs include:
    <br>* **SWRL** (2004): A KRL that combines OWL with rules.
    <br>* **SPIN** (2011): A KRL that allows users to add new semantics to OWL ontologies.
    <br>* **RDFS++** (2012): A KRL that extends OWL with new features for representing temporal and spatial knowledge.
    <br>* **WebReason** (2016): A KRL that is based on modal logic and allows users to reason about counterfactuals and possible worlds.
    <br>
    <br>The evolution of KRLs has been driven by a number of factors, including the need to represent more complex knowledge, the need to reason about knowledge in more sophisticated ways, and the need to integrate knowledge from different sources.
    <br>
    <br>Modern KRLs are still under development, but they have the potential to revolutionize the way we represent and reason about knowledge in AI systems."
    <br>[{2023-10-23 retrieved} https://bard.google.com/chat/3c669bacca1bb3be]
    <br>
    <br>"evolution of knowledge-representation-languages:
    <br>The evolution of knowledge representation languages is a fascinating journey that has played a significant role in the development of artificial intelligence and related fields. These languages are designed to capture and model knowledge in a way that can be used by computers for reasoning and problem-solving. Here is an overview of the key milestones and stages in the evolution of knowledge representation languages:
    <br>
    <br>1. Early Symbolic Notation (1950s-1960s):
    <br>   - In the early days of AI research, knowledge representation involved symbolic notations. Researchers used formal logic, such as first-order logic and propositional logic, to represent knowledge.
    <br>   - Researchers also utilized early programming languages to represent knowledge, which were often ad hoc and lacked formal semantics.
    <br>
    <br>2. Frame-Based Systems (late 1960s-1970s):
    <br>   - Frame-based knowledge representation systems, such as Minsky's "frames," introduced the idea of organizing knowledge in structured entities called frames. These frames contained slots and fillers for organizing and storing information.
    <br>
    <br>3. Semantic Networks (1960s-1980s):
    <br>   - Semantic networks represented knowledge using nodes and links to connect concepts and their relationships. This approach made it easier to model hierarchical and associative relationships between concepts.
    <br>
    <br>4. Rule-Based Systems (1970s-1980s):
    <br>   - Rule-based systems used production rules to represent knowledge in the form of "if-then" statements. These systems were particularly useful for expert systems and rule-based reasoning.
    <br>
    <br>5. Description Logics (1980s-present):
    <br>   - Description logics are a family of formal knowledge representation languages that are based on first-order logic and set theory. They underpin modern ontology languages and are used in the Semantic Web and ontology modeling.
    <br>
    <br>6. Ontology Languages (late 1990s-present):
    <br>   - Ontologies, represented using languages like OWL (Web Ontology Language), RDF (Resource Description Framework), and RDFS (Resource Description Framework Schema), have gained prominence for representing knowledge in a structured, machine-readable format. These ontologies are used for semantic web applications and knowledge organization.
    <br>
    <br>7. CycL (1984-present):
    <br>   - CycL is a knowledge representation language associated with the Cyc project, which aims to capture common-sense knowledge in a machine-readable format. It employs a rich, formalized language for representing a wide range of knowledge.
    <br>
    <br>8. RDF and Linked Data (2000s-present):
    <br>   - RDF and linked data principles have become fundamental for representing and connecting knowledge on the web. They allow for the creation of knowledge graphs and the integration of data from diverse sources.
    <br>
    <br>9. Neural Networks and Embeddings (2010s-present):
    <br>   - In recent years, deep learning techniques, particularly neural network-based embeddings, have played a significant role in learning and representing knowledge from large datasets. Embeddings like Word2Vec, GloVe, and BERT capture semantic relationships between words and concepts.
    <br>
    <br>The evolution of knowledge representation languages reflects the ongoing quest to make computers understand and manipulate human knowledge more effectively. Modern knowledge representation often involves a combination of these approaches, and research continues to explore ways to make knowledge representation more efficient and adaptable for various AI applications."
    <br>[{2023-10-23 retrieved} https://chat.openai.com/c/d4587416-de37-4dd4-8641-a1bdd7b9a0ab]
    <a class="clsHide" href="#idLKnlgevgFdsn"></a></p>
  <p id="idLKnlgevgnam">name::
    <br>* McsEngl.lagKnlg'evoluting,
    <a class="clsHide" href="#idLKnlgevgnam"></a></p>
  <p id="idLKnlgevg20231023">{2023-10-23}-McsHitp-creation::
    <br>· creation of current <a class="clsPreview" href="../dirTchInf/McsTchInf000009.last.html#idMcsHitp">concept</a>.
    <a class="clsHide" href="#idLKnlgevg20231023"></a></p>
</section>

<section id="idLKnlgpctF">
  <h1 id="idLKnlgwptFH1">PARENT-CHILD-TREE of lagKnlg
    <a class="clsHide" href="#idLKnlgpctFH1"></a></h1>
  <p id="idLKnlgptr">parent-tree-of-lagKnlg::
    <br>* ,
    <br>* McsEngl.lagKnlg'parent-tree,
    <a class="clsHide" href="#idLKnlgptr"></a></p>
  <p id="idLKnlgctr">child-tree-of-lagKnlg::
    <br>* ,
    <br>* McsEngl.lagKnlg'child-tree,
    <a class="clsHide" href="#idLKnlgctr"></a></p>
</section>

<section id="idLKnlgwptF">
  <h1 id="idLKnlgwptFH1">WHOLE-PART-TREE of lagKnlg
    <a class="clsHide" href="#idLKnlgwptFH1"></a></h1>
  <p id="idLKnlgwtr">whole-tree-of-lagKnlg::
    <br>* ,
    <br>* ... <a class="clsPreview" href="../dirCor/McsCor000003.last.html#idEntwtr">Sympan</a>.
    <br>* McsEngl.lagKnlg'whole-tree,
    <a class="clsHide" href="#idLKnlgwtr"></a></p>
  <p id="idLKnlgptr">part-tree-of-lagKnlg::
    <br>* ,
    <br>* McsEngl.lagKnlg'part-tree,
    <a class="clsHide" href="#idLKnlgptr"></a></p>
</section>

<section id="idLKnlggstF">
  <h1 id="idLKnlggstFH1">GENERIC-SPECIFIC-TREE of lagKnlg
    <a class="clsHide" href="#idLKnlggstFH1"></a></h1>
  <p id="idLKnlggtr">generic-tree-of-lagKnlg::
    <br>* ,
    <br>* ... <a class="clsPreview" href="../dirCor/McsCor000003.last.html#idOverview">entity</a>.
    <br>* McsEngl.lagKnlg'generic-tree,
    <a class="clsHide" href="#idLKnlggtr"></a></p>
  <p id="idLKnlgstr">specific-tree-of-lagKnlg::
    <br>* concept-lagKnlg,
    <br>* logo-lagKnlg,
    <br>
    <br>* McsEngl.lagKnlg.specific-tree,
    <a class="clsHide" href="#idLKnlgstr"></a></p>
</section>

<section id="idLKnlg001">
  <h1 id="idLKnlg001H1">lagKnlg.concept (link)
    <a class="clsHide" href="#idLKnlg001H1"></a></h1>
</section>

<section id="idLKnlg002">
  <h1 id="idLKnlg002H1">lagKnlg.logo
    <a class="clsHide" href="#idLKnlg002H1"></a></h1>
  <p id="idLKnlg002dsn">description::
    <br>· logo-lagKnlg is knowledge-language that maps logo to "meaning".
    <br>· meaning-language is a-computer-language that represents <a class="clsPreview" href="../dirLag/McsLag000007.last.html#idLHmnmipt1">human-meaning</a> FROM human-logo-(text, speech).
    <br>· <a class="clsPreview" href="../dirTchInf/McsTchInf000007.last.html#idOverview">concept-language</a> maps mind-concept-systems to "meaning".
    <a class="clsHide" href="#idLKnlg002dsn"></a></p>
  <p id="idLKnlg002nam">name::
    <br>* McsEngl.formal-meaning-representation-language!⇒lagLgkl,
    <br>* McsEngl.lagCmpr.014-meaning!⇒lagLgkl,
    <br>* McsEngl.lagCmpr.meaning!⇒lagLgkl,
    <br>* McsEngl.lagKnlg.002-logo!⇒lagLgkl,
    <br>* McsEngl.lagKnlg.logo!⇒lagLgkl,
    <br>* McsEngl.lagLgkl!=LoGo--Knowledge-Language,
    <br>* McsEngl.lagMeaning!⇒lagLgkl,
    <br>* McsEngl.lagMeng!⇒lagLgkl,
    <br>* McsEngl.lagMeng!=meaning-lagCmpr!⇒lagLgkl,
    <br>* McsEngl.logo--knowledge-language!⇒lagLgkl,
    <br>* McsEngl.logo-lagKnlg!⇒lagLgkl,
    <br>* McsEngl.meaning-language!⇒lagLgkl,
    <br>* McsEngl.meaning-representation-language!⇒lagLgkl,
    <a class="clsHide" href="#idLKnlg002nam"></a></p>

  <section id="idLKnlg002scpg">
  <h2 id="idLKnlg002scpgH2">semantic-parsing of lagLgkl
    <a class="clsHide" href="#idLKnlg002scpgH2"></a></h2>
  <p id="idLKnlg002scpgdsn">description::
    <br>"Semantic parsing is the task of converting a natural language utterance to a logical form: a machine-understandable representation of its meaning.[1] Semantic parsing can thus be understood as extracting the precise meaning of an utterance. Applications of semantic parsing include machine translation,[2] question answering,[1][3] ontology induction,[4] automated reasoning,[5] and code generation.[6][7] The phrase was first used in the 1970s by Yorick Wilks as the basis for machine translation programs working with only semantic representations.[8]"
    <br>[{2023-04-02 retrieved} https://en.wikipedia.org/wiki/Semantic_parsing]
    <a class="clsHide" href="#idLKnlg002scpgdsn"></a></p>
  <p id="idLKnlg002scpgnam">name::
    <br>* McsEngl.lagLgkl'semantic-parsing,
    <br>* McsEngl.semantic-parsing,
    <a class="clsHide" href="#idLKnlg002scpgnam"></a></p>
  </section>

  <section id="idLKnlg002gst">
  <h2 id="idLKnlg002gstH2">GENERIC-SPECIFIC-TREE of lagLgkl
    <a class="clsHide" href="#idLKnlg002gstH2"></a></h2>
  <p id="idLKnlg002gstgtr">generic-tree-of-lagLgkl::
    <br>* knowledge-language,
    <br>* ... entity,
    <br>* McsEngl.lagLgkl'generic-tree,
    <a class="clsHide" href="#idLKnlg002gstgtr"></a></p>
  <p id="idLKnlg002gststr">specific-tree-of-lagLgkl::
    <br>* ,
    <br>* McsEngl.lagLgkl.specific-tree,
    <a class="clsHide" href="#idLKnlg002gststr"></a></p>
  </section>

  <section id="idLKnlg002Amr">
  <h2 id="idLKnlg002AmrH2">lagLgkl.Abstract-Meaning-Representation
    <a class="clsHide" href="#idLKnlg002AmrH2"></a></h2>
  <p id="idLKnlg002Amrdsn">description::
    <br>"Abstract Meaning Representation (AMR)[1][2] is a semantic representation language. AMR graphs are rooted, labeled, directed, acyclic graphs (DAGs), comprising whole sentences. They are intended to abstract away from syntactic representations, in the sense that sentences which are similar in meaning should be assigned the same AMR, even if they are not identically worded. By nature, the AMR language is biased towards English – it is not meant to function as an international auxiliary language.
    <br>Abstract Meaning Representations have originally been introduced by Langkilde and Knight (1998)[3] as a derivation from the Penman Sentence Plan Language,[4] they are thus continuing a long tradition in Natural Language Generation and this has been their original domain of application. AMRs have re-gained attention since Banarescu et al. (2013),[1] in particular, this includes the extension to novel tasks such as machine translation and natural language understanding. The modern (post-2010) AMR format preserves the syntax and many syntactic conceptions of the original AMR format but has been thoroughly revised to better align with PropBank. Moreover, AMR has been extended with formal conventions for metadata and conventions for entity linking (here, linking with Wikipedia entries).
    <br>Existing AMR technology includes tools and libraries for parsing,[5] visualization,[6] and surface generation[7] as well as a considerable number of publicly available data sets. Many of these resources are collected at the AMR homepage[8] at ISI/USC where AMR technology has been originally developed."
    <br>[{2023-04-02 retrieved} https://en.wikipedia.org/wiki/Abstract_Meaning_Representation]
    <a class="clsHide" href="#idLKnlg002Amrdsn"></a></p>
  <p id="idLKnlg002Amrnam">name::
    <br>* McsEngl.AMR!=Abstract-Meaning-Representation-lagLgkl,
    <br>* McsEngl.lagLgkl.Abstract-Meaning-Representation,
    <a class="clsHide" href="#idLKnlg002Amrnam"></a></p>
  </section>
</section>

<section id="idMeta">
  <h1 id="idMetaH1">meta-info
    <a class="clsHide" href="#idMetaH1"></a></h1>
  <p id="idMetaCounter" class="clsCenter">this page was-visited
    <span class="clsColorRed">
    <script src="../../dirPgm/dirCntr/counter.php?page=McsTchInf000039"></script>
    </span>
    times since {2023-10-23}</p>
  <!-- the content of page-path paragraph is displayed as it is on top of toc -->
  <p id="idMetaWebpage_path"><span class="clsB clsColorGreen">page-wholepath</span>:
    <a class="clsPreview" href="../../index.html#idOverview">synagonism.net</a> /
    <a class="clsPreview" href="../Mcs000000.last.html#idOverview">worldviewSngo</a> /
    <a class="clsPreview" href="../dirTchInf/McsTchInf000000.last.html#idOverview">dirTchInf</a> /
    lagKnlg
    </p>
  <p id="idMetaP1">SEARCH::
    <br>· this page uses '<span class="clsColorRed">locator-names</span>', names that when you find them, you find the-LOCATION of the-concept they denote.
    <br>⊛ <strong>GLOBAL-SEARCH</strong>:
    <br>· clicking on <span class="clsColorGreenBg">the-green-BAR of a-page</span> you have access to the-global--locator-names of my-site.
    <br>· use the-prefix '<span class="clsColorRed">lagKnlg</span>' for <a class="clsPreview" href="../dirCor/McsCor000002.last.html#idOverview">senso-concepts</a> related to current concept 'knowledge-language'.
    <br>⊛ <strong>LOCAL-SEARCH</strong>:
    <br>· TYPE <span class="clsColorRed">CTRL+F "McsLang.words-of-concept's-name"</span>, to go to the-LOCATION of the-concept.
    <br>· a-preview of the-description of a-global-name makes reading fast.
    <a class="clsHide" href="#idMetaP1"></a></p>
  <p id="idFooterP1">footer::
    <br>• author: <a class="clsPreview" href="../dirHmn/McsHmn000003.last.html#idOverview">Kaseluris.Nikos.1959</a>
    <br>• email:
    <br> &nbsp;<img src="../../dirRsc/dirImg/mail.png">
    <br>• edit on github: https://github.com/synagonism/McsWorld/blob/master/dirMcs/dirTchInf/McsTchInf000039.last.html,
    <br>• comments on <a class="clsPreview" href="../dirTchInf/McsTchInf000000.last.html#idComment">Disqus</a>,
    <br>• twitter: <a href="https://twitter.com/synagonism">@synagonism</a>,
    <a class="clsHide" href="#idFooterP1"></a></p>
  <p id="idMetaVersion">webpage-versions::
    <br>• version.last.dynamic: <a lass="clsPreview" href="../dirTchInf/McsTchInf000039.last.html">McsTchInf000039.last.html</a>,
    <br>• version.draft.creation: McsTchInf000039.0-1-0.2023-10-23.last.html,
    <a class="clsHide" href="#idMetaVersion"></a></p>
</section>

<section id="idSupport">
  <h1 id="idSupportH1">support (<a class="clsPreview" href="../../index.html#idSupport">link</a>)</h1>
  <p></p>
</section>

<script type="module">
  import * as omMcsh from '../Mcsmgr/mMcsh.js'
</script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-19285371-5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-19285371-5');
</script>
<!--   -->
</body>
</html>