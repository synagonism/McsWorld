<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Mcs.sciCmpr-(McsEdu000007.0-13-0.2023-11-05 draft) science.computer</title>
  <meta name="keywords" content="science.computer, sciCmpr, ModelConceptSensorial, McsHitp, Synagonism">
  <link rel="stylesheet" href="../Mcsmgr/mHitp.css">
</head>

<body>
<header id="idHeader">
  <p></p>
  <h1 id="idHeaderH1">science.computer
    <br>senso-concept-Mcs (sciCmpr)
    </h1>
  <p id="idHeadercrd">McsHitp-creation:: {2023-08-22}
    <a class="clsHide" href="#idHeadercrd"></a></p>
</header>

<section id="idOverview">
  <h1 id="idOverviewH1">overview of sciCmpr
    <a class="clsHide" href="#idOverviewH1"></a></h1>
  <p id="idDescription">description::
    <br>· "Computer science is the study of computation, information, and automation.[1][2][3] Computer science spans theoretical disciplines (such as algorithms, theory of computation, and information theory) to applied disciplines (including the design and implementation of hardware and software).[4][5][6] Though more often considered an academic discipline, computer science is closely related to computer programming.[7]
    <br>Algorithms and data structures are central to computer science.[8] The theory of computation concerns abstract models of computation and general classes of problems that can be solved using them. The fields of cryptography and computer security involve studying the means for secure communication and for preventing security vulnerabilities. Computer graphics and computational geometry address the generation of images. Programming language theory considers different ways to describe computational processes, and database theory concerns the management of repositories of data. Human–computer interaction investigates the interfaces through which humans and computers interact, and software engineering focuses on the design and principles behind developing software. Areas such as operating systems, networks and embedded systems investigate the principles and design behind complex systems. Computer architecture describes the construction of computer components and computer-operated equipment. Artificial intelligence and machine learning aim to synthesize goal-orientated processes such as problem-solving, decision-making, environmental adaptation, planning and learning found in humans and animals. Within artificial intelligence, computer vision aims to understand and process image and video data, while natural language processing aims to understand and process textual and linguistic data.
    <br>The fundamental concern of computer science is determining what can and cannot be automated.[2][9][3][10][11] The Turing Award is generally recognized as the highest distinction in computer science.[12][13]"
    <br>[{2023-08-22 retrieved} https://en.wikipedia.org/wiki/Computer_science]
    <a class="clsHide" href="#idDescription"></a></p>
  <p id="idName">name::
    <br>* McsEngl.McsEdu000007.last.html//dirEdu//dirMcs!⇒sciCmpr,
    <br>* McsEngl.dirEdu/McsEdu000007.last.html!⇒sciCmpr,
    <br>* McsEngl.computer-science!⇒sciCmpr,
    <br>* McsEngl.computics!⇒sciCmpr,
    <br>* McsEngl.computing-science!⇒sciCmpr,
    <br>* McsEngl.datalogy!⇒sciCmpr,
    <br>* McsEngl.informatics!⇒sciCmpr,
    <br>* McsEngl.science.computer!⇒sciCmpr,
    <br>* McsEngl.sciCmpr,
    <br>* McsEngl.sciCmpr!=McsEdu000007,
    <br>* McsEngl.sciCmpr!=science.computer,
    <br>* McsEngl.sciComputer!⇒sciCmpr,
    <br>====== langoGreek:
    <br>* McsElln.επιστήμη-υπολογιστών!η!=sciCmpr,
    <br>* McsElln.πληροφορική!η!=sciCmpr,
    <a class="clsHide" href="#idName"></a></p>
</section>

<section id="idSCmprabsm">
  <h1 id="idSCmprabsmH1">abstract-machine (<a class="clsPreview" href="../dirTchInf/McsTchInf000003.last.html#idCmr003">link</a>) of sciCmpr
    <a class="clsHide" href="#idSCmprabsmH1"></a></h1>
</section>

<section id="idSCmprcmr">
  <h1 id="idSCmprcmrH1">computer (<a class="clsPreview" href="../dirTchInf/McsTchInf000003.last.html#idOverview">link</a>) of sciCmpr
    <a class="clsHide" href="#idSCmprcmrH1"></a></h1>
</section>

<section id="idSCmprinftch">
  <h1 id="idSCmprinftchH1">info-tech (<a class="clsPreview" href="../dirTchInf/McsTchInf000002.last.html#idOverview">link</a>) of sciCmpr
    <a class="clsHide" href="#idSCmprinftchH1"></a></h1>
</section>

<section id="idSCmprrtos">
  <h1 id="idSCmprrtosH1">relation-to-other-sciences of sciCmpr
    <a class="clsHide" href="#idSCmprrtosH1"></a></h1>
  <p id="idSCmprrtosdsn">description::
    <br>· "Computer science research also often intersects other disciplines, such as cognitive science, linguistics, mathematics, physics, biology, Earth science, statistics, philosophy, and logic.
    <br>Computer science is considered by some to have a much closer relationship with mathematics than many scientific disciplines, with some observers saying that computing is a mathematical science.[7]"
    <br>[{2023-08-22 retrieved} https://en.wikipedia.org/wiki/Computer_science#Etymology]
    <a class="clsHide" href="#idSCmprrtosdsn"></a></p>
  <p id="idSCmprrtosnam">name::
    <br>* McsEngl.sciCmpr'relation-to-other-sciences,
    <a class="clsHide" href="#idSCmprrtosnam"></a></p>
</section>

<section id="idSCmprrscF">
  <h1 id="idSCmprrscFH1">info-resource of sciCmpr
    <a class="clsHide" href="#idSCmprrscFH1"></a></h1>
  <p id="idSCmprrscwpa">addressWpg::
    <br>*
    <a class="clsHide" href="#idSCmprrscwpa"></a></p>
  <p id="idSCmprrscnam">name::
    <br>* McsEngl.sciCmpr'Infrsc,
    <a class="clsHide" href="#idSCmprrscnam"></a></p>
</section>

<section id="idSCmprdngF">
  <h1 id="idSCmprdngFH1">DOING of sciCmpr
    <a class="clsHide" href="#idSCmprdngFH1"></a></h1>
  <p id="idSCmprdngdsn">description::
    <br>*
    <a class="clsHide" href="#idSCmprdngdsn"></a></p>
  <p id="idSCmprdngnam">name::
    <br>* McsEngl.sciCmpr'doing,
    <a class="clsHide" href="#idSCmprdngnam"></a></p>
</section>

<section id="idSCmprevgF">
  <h1 id="idSCmprevgFH1">evoluting of sciCmpr
    <a class="clsHide" href="#idSCmprevgFH1"></a></h1>
  <p id="idSCmprevgnam">name::
    <br>* McsEngl.evoluting-of-sciCmpr,
    <br>* McsEngl.sciCmpr'evoluting,
    <a class="clsHide" href="#idSCmprevgnam"></a></p>
  <p id="idSCmprevg20230822">{2023-08-22}::
    <br>=== McsHitp-creation:
    <br>· creation of current <a class="clsPreview" href="../dirTchInf/McsTchInf000009.last.html#idMcsHitp">concept</a>.
    <br>
    <br>"evolution of computer-science:
    <br>The field of computer science has undergone significant evolution and development since its inception. Here's a broad overview of the evolution of computer science:
    <br>
    <br>1. **Early Mechanical Computing (1600s-1800s):** The earliest developments in computing can be traced back to inventors and mathematicians like Blaise Pascal and Charles Babbage, who designed mechanical calculating machines. Babbage's "Analytical Engine" is often considered the first general-purpose computer, although it was never built.
    <br>
    <br>2. **Theoretical Foundations (1930s-1940s):** The theoretical foundations of computer science were laid in the 1930s and 1940s. Alan Turing developed the concept of the Turing machine, a theoretical model of computation, and Alonzo Church introduced Lambda calculus. These theoretical concepts became crucial in the design and analysis of algorithms.
    <br>
    <br>3. **First Electronic Computers (1940s):** The mid-20th century saw the development of the first electronic computers. The ENIAC, UNIVAC, and other early machines were massive and expensive, primarily used for scientific and military purposes. The stored-program concept, which allowed computers to be reprogrammed for different tasks, was also introduced during this time.
    <br>
    <br>4. **Programming Languages (1950s-1960s):** This era saw the development of high-level programming languages, such as Fortran and COBOL, which made it easier for people to write software. John McCarthy's creation of LISP also marked the beginning of artificial intelligence research.
    <br>
    <br>5. **Minicomputers and Microprocessors (1960s-1970s):** The introduction of smaller, more affordable computers like the PDP-8 and the advent of microprocessors in the early 1970s allowed for personal computing to become a reality. This era marked a shift from mainframe computing to a more decentralized computing model.
    <br>
    <br>6. **The Rise of the Personal Computer (1980s):** The 1980s saw the explosion of the personal computer industry with the introduction of machines like the IBM PC and the Apple Macintosh. Graphical user interfaces (GUIs) and the mouse were also developed during this time.
    <br>
    <br>7. **Internet and World Wide Web (1990s):** The 1990s brought the widespread adoption of the internet and the creation of the World Wide Web by Tim Berners-Lee. This revolutionized communication and information access and laid the foundation for many aspects of modern computing.
    <br>
    <br>8. **Mobile and Smart Devices (2000s-Present):** The 2000s saw the rise of smartphones and other smart devices. Mobile computing became a dominant force in computing, and platforms like iOS and Android emerged. Cloud computing also became increasingly important.
    <br>
    <br>9. **Big Data and Machine Learning (2000s-Present):** The processing of massive amounts of data and the development of machine learning and artificial intelligence techniques have become central in fields like data science and analytics. This era also saw the emergence of technologies like deep learning and neural networks.
    <br>
    <br>10. **Blockchain and Quantum Computing (Emerging):** Emerging technologies like blockchain and quantum computing are poised to reshape the field of computer science. Blockchain has the potential to revolutionize security and trust in digital transactions, while quantum computing promises to solve complex problems that are infeasible for classical computers.
    <br>
    <br>11. **Ethical and Societal Concerns (Ongoing):** As computer science continues to evolve, there is a growing emphasis on ethical and societal considerations, including issues related to data privacy, security, and the responsible use of AI.
    <br>
    <br>The field of computer science continues to evolve at a rapid pace, with ongoing advancements in hardware, software, and theoretical concepts. It plays a critical role in shaping our modern world and is likely to remain at the forefront of technological innovation in the future."
    <br>[{2023-10-14 retrieved} https://chat.openai.com/c/b09d9dc5-4ccf-4762-8527-20d49acf2322]
    <br>
    <br>"evolution of computer-science:
    <br>The evolution of computer science can be traced back to the early days of mathematics and engineering. Early devices such as the abacus and the slide rule were used to perform basic calculations. In the 17th century, Gottfried Wilhelm Leibniz invented the binary number system, which is the foundation of all modern computers.
    <br>
    <br>In the 19th century, Charles Babbage designed a mechanical computer called the Analytical Engine. This machine was never built, but it was the first device to incorporate all of the essential elements of a modern computer, including a central processing unit, memory, and input/output devices.
    <br>
    <br>The first electronic digital computer was built in 1946 by J. Presper Eckert and John Mauchly at the University of Pennsylvania. This machine, called the ENIAC, was massive, weighing over 30 tons and containing over 18,000 vacuum tubes.
    <br>
    <br>In the 1950s, transistors replaced vacuum tubes in computers, making them smaller, more reliable, and more efficient. The invention of the integrated circuit in 1958 led to the development of even smaller and more powerful computers.
    <br>
    <br>In the 1960s, computer science began to emerge as a distinct academic discipline. The first computer science department was established at Purdue University in 1962.
    <br>
    <br>The 1970s saw the development of the microprocessor, which is the central processing unit of a personal computer. The first microprocessor was the Intel 4004, which was released in 1971.
    <br>
    <br>In the 1980s, personal computers became widely available and affordable. This led to a revolution in the way that people work, learn, and communicate.
    <br>
    <br>In the 1990s, the Internet became mainstream. This gave people access to a vast amount of information and resources. It also led to the development of new forms of communication and collaboration.
    <br>
    <br>In the 21st century, computer science has continued to evolve at a rapid pace. New technologies such as artificial intelligence, machine learning, and big data have revolutionized many industries.
    <br>
    <br>Computer science is today one of the most important and dynamic fields of study. It has a profound impact on all aspects of our lives.
    <br>
    <br>Here are some of the key trends in the evolution of computer science:
    <br>Miniaturization: Computers have become increasingly smaller and more powerful over time. This is due to advances in semiconductor technology, which has allowed for the development of smaller and more efficient transistors and integrated circuits.
    <br>Increased connectivity: Computers are now more connected than ever before. This is due to the development of the Internet and other networking technologies. Computers can now be used to communicate and collaborate with people all over the world.
    <br>Artificial intelligence: Artificial intelligence (AI) is a field of computer science that deals with the creation of intelligent agents, which are systems that can reason, learn, and act autonomously. AI has made significant progress in recent years and is now being used in a wide range of applications, including self-driving cars, medical diagnosis, and fraud detection.
    <br>Big data: Big data refers to the collection and analysis of large and complex datasets. Big data is being used to improve decision-making in many industries, including healthcare, finance, and marketing.
    <br>
    <br>Computer science is a rapidly evolving field, and it is difficult to predict what the future holds. However, it is clear that computer science will continue to play an increasingly important role in our lives.
    <br>
    <br>Sources
    <br>viralgotech.com/what-is-artificial-intelligence/
    <br>r3plica.academy/docs/how-to-start-a-career-in-ai/
    <br>[{2023-10-14 retrieved} https://bard.google.com/chat/a2c65d4f031accdb]
    <a class="clsHide" href="#idSCmprevg20230822"></a></p>

  <p id="idSCmprevgi1019601970">{1960..1970i10}-sciCmpr-distinct-branch::
    <br>"Computer science began to be established as a distinct academic discipline in the 1950s and early 1960s.[7][34]"
    <br>[{2023-08-22 retrieved} https://en.wikipedia.org/wiki/Computer_science]
    <br>* McsEngl.{science'1960..1970i10}-sciCmpr-distinct-branch,
    <a class="clsHide" href="#idSCmprevgi1019601970"></a></p>

  <p id="idSCmprevg1962">{1962}-sciCmpr-first-department::
    <br>"The first computer science department in the United States was formed at Purdue University in 1962.[35]"
    <br>[{2023-08-22 retrieved} https://en.wikipedia.org/wiki/Computer_science]
    <br>* McsEngl.{science'1962}-sciCmpr-first-department,
    <a class="clsHide" href="#idSCmprevg1962"></a></p>

  <p id="idSCmprevg1953">{1953}-sciCmpr-first-degree-program::
    <br>"The world's first computer science degree program, the Cambridge Diploma in Computer Science, began at the University of Cambridge Computer Laboratory in 1953."
    <br>[{2023-08-22 retrieved} https://en.wikipedia.org/wiki/Computer_science]
    <br>* McsEngl.{science'1953}-sciCmpr-first-degre-program,
    <a class="clsHide" href="#idSCmprevg1953"></a></p>

  <p id="idSCmprevg1946">{1946}-sciCmpr-first-academic-course::
    <br>"Columbia-University offering one of the first academic-credit courses in computer science in 1946.[33]"
    <br>[{2023-08-22 retrieved} https://en.wikipedia.org/wiki/Computer_science]
    <br>* McsEngl.{science'1946}-sciCmpr-first-academic-course,
    <a class="clsHide" href="#idSCmprevg1946"></a></p>
</section>

<section id="idSCmprpctF">
  <h1 id="idSCmprwptFH1">PARENT-CHILD-TREE of sciCmpr
    <a class="clsHide" href="#idSCmprpctFH1"></a></h1>
  <p id="idSCmprpctnam">name::
    <br>* McsEngl.sciCmpr'parent-child-tree,
    <br>* McsEngl.sciCmpr'child-parent-tree,
    <a class="clsHide" href="#idSCmprpctnam"></a></p>
  <p id="idSCmprptr">parent-tree-of-sciCmpr::
    <br>* mathematics, physics,
    <br>"The history of computer science began long before the modern discipline of computer science, usually appearing in forms like mathematics or physics."
    <br>[{2023-08-22 retrieved} https://en.wikipedia.org/wiki/History_of_computer_science]
    <a class="clsHide" href="#idSCmprptr"></a></p>
  <p id="idSCmprctr">child-tree-of-sciCmpr::
    <br>*
    <a class="clsHide" href="#idSCmprctr"></a></p>
</section>

<section id="idSCmprwptF">
  <h1 id="idSCmprwptFH1">WHOLE-PART-TREE of sciCmpr
    <a class="clsHide" href="#idSCmprwptFH1"></a></h1>
  <p id="idSCmprwptnam">name::
    <br>* McsEngl.sciCmpr'part-whole-tree,
    <br>* McsEngl.sciCmpr'whole-part-tree,
    <a class="clsHide" href="#idSCmprwptnam"></a></p>
  <p id="idSCmprwtr">whole-tree-of-sciCmpr::
    <br>*
    <br>* ... <a class="clsPreview" href="../dirCor/McsCor000003.last.html#idEntwtr">Sympan</a>.
    <a class="clsHide" href="#idSCmprwtr"></a></p>
  <p id="idSCmprptr">part-tree-of-sciCmpr::
    <br>*
    <a class="clsHide" href="#idSCmprptr"></a></p>
</section>

<section id="idSCmprgstF">
  <h1 id="idSCmprgstFH1">GENERIC-SPECIFIC-TREE of sciCmpr
    <a class="clsHide" href="#idSCmprgstFH1"></a></h1>
  <p id="idSCmprgstnam">name::
    <br>* McsEngl.sciCmpr'generic-specific-tree,
    <br>* McsEngl.sciCmpr'specific-generic-tree,
    <a class="clsHide" href="#idSCmprgstnam"></a></p>
  <p id="idSCmprgtr">generic-tree-of-sciCmpr::
    <br>* ,
    <br>* ... <a class="clsPreview" href="../dirCor/McsCor000003.last.html#idOverview">entity</a>.
    <a class="clsHide" href="#idSCmprgtr"></a></p>
  <p id="idSCmprstr">specific-tree-of-sciCmpr::
    <br>* algorithm,
    <br>* artificial intelligence,
    <br>* computational geography,
    <br>* computer architecture,
    <br>* computer graphics,
    <br>* computer security,
    <br>* computer vision,
    <br>* cryptography,
    <br>* database theory,
    <br>* data structure,
    <br>* embedded system,
    <br>* human computer interaction,
    <br>* information theory,
    <br>* machine learning,
    <br>* natural language processing,
    <br>* network,
    <br>* operating system,
    <br>* programing language theory,
    <br>* software engineering,
    <br>* theory of computation,
    <a class="clsHide" href="#idSCmprstr"></a></p>
</section>

<section id="idSCmpr007">
  <h1 id="idSCmpr007H1">sciCmpr.theoritical-computer-science
    <a class="clsHide" href="#idSCmpr007H1"></a></h1>
  <p id="idSCmpr007dsn">description::
    <br>"theoritical-computer-science vs computer-science:
    <br>Theoretical computer science and computer science are related fields, but they focus on different aspects of the broader domain of computing and have distinct goals and areas of emphasis. Here's a comparison of theoretical computer science and computer science:
    <br>
    <br>**Computer Science**:
    <br>1. **Practical Applications:** Computer science primarily deals with the practical aspects of computing, such as the design, development, and implementation of software and hardware systems. It is concerned with solving real-world problems through the use of computers.
    <br>
    <br>2. **Programming and Software Development:** Computer science encompasses areas like software engineering, programming languages, algorithms, data structures, and software development methodologies. It aims to produce functional, efficient, and reliable software applications.
    <br>
    <br>3. **Networking and Systems:** Computer scientists work on designing and maintaining computer networks, operating systems, and distributed computing systems. They ensure that computer systems function effectively in the real world.
    <br>
    <br>4. **Human-Computer Interaction (HCI):** HCI is a subfield of computer science that focuses on how humans interact with computers and software. It aims to make computer systems more user-friendly and intuitive.
    <br>
    <br>5. **Database Management:** Computer scientists work on the design, management, and optimization of databases. This includes topics like database modeling, query languages, and data storage.
    <br>
    <br>6. **Security:** Cybersecurity is a critical aspect of computer science. It involves protecting computer systems and networks from unauthorized access, data breaches, and cyberattacks.
    <br>
    <br>7. **Artificial Intelligence:** Computer science includes the study of AI, machine learning, and data science. Researchers in this field work on developing intelligent algorithms and systems that can perform tasks such as image recognition, natural language processing, and data analysis.
    <br>
    <br>**Theoretical Computer Science**:
    <br>1. **Mathematical Foundations:** Theoretical computer science is rooted in mathematical concepts and formal logic. It focuses on the development and analysis of mathematical models to understand the fundamental properties and limitations of computation.
    <br>
    <br>2. **Algorithms and Complexity Theory:** Theoretical computer science explores the theoretical aspects of algorithms and their efficiency. Complexity theory classifies problems into complexity classes like P, NP, and NP-complete and investigates the inherent difficulty of solving computational problems.
    <br>
    <br>3. **Automata Theory:** This field studies abstract machines and automata to understand the capabilities and limitations of computation. Topics include finite automata, pushdown automata, and Turing machines.
    <br>
    <br>4. **Formal Languages and Compiler Theory:** Theoretical computer science deals with the formal languages used in programming and the theory of compilers that translate high-level programming languages into machine code.
    <br>
    <br>5. **Computability Theory:** This area focuses on what can and cannot be computed. It includes the study of Turing machines, computable functions, and the Halting problem.
    <br>
    <br>6. **Cryptography:** Theoretical computer science plays a significant role in the development of cryptographic algorithms and protocols, ensuring the security of digital communication and data.
    <br>
    <br>In summary, computer science is more concerned with the practical applications of computing, including software development, networking, and hardware design. Theoretical computer science, on the other hand, delves into the mathematical foundations and fundamental principles of computation, including algorithm analysis, formal languages, and computability. While the two fields are interconnected and inform each other, they have different objectives and methodologies. Many computer scientists draw upon theoretical computer science principles when developing practical solutions, but not all computer scientists engage in the more theoretical aspects of the field."
    <br>[{2023-10-16 retrieved} https://chat.openai.com/c/e1cf5ea5-324a-411f-ae35-7449bcd41225]
    <a class="clsHide" href="#idSCmpr007dsn"></a></p>
  <p id="idSCmpr007nam">name::
    <br>* McsEngl.sciCmpr.007-theoritical-computer-science,
    <br>* McsEngl.sciCmpr.theoritical-computer-science,
    <br>* McsEngl.theoritical-computer-science,
    <a class="clsHide" href="#idSCmpr007nam"></a></p>

  <section id="idSCmpr007evlg">
  <h2 id="idSCmpr007evlgH2">evoluting of theoritical-computer-science
    <a class="clsHide" href="#idSCmpr007evlgH2"></a></h2>
  <p id="idSCmpr007evlgdsn">description::
    <br>"evolution of theoritical-computer-science:
    <br>Theoretical computer science is a field that has evolved significantly since its inception in the mid-20th century. It encompasses a wide range of topics, including algorithms, automata theory, computational complexity, formal languages, and more. Here is an overview of the evolution of theoretical computer science:
    <br>
    <br>1. Automata Theory (mid-20th century):
    <br>   - The field of theoretical computer science began with the development of automata theory, which was introduced by Alan Turing in the 1930s and extended by others, including Alonzo Church and Emil Post.
    <br>   - This theory laid the foundation for understanding the limits and capabilities of computation through the formalization of abstract machines and the concept of computability.
    <br>
    <br>2. Formal Language Theory (1950s):
    <br>   - Noam Chomsky's hierarchy of formal languages (Chomsky hierarchy) provided a framework for classifying languages based on their generative power.
    <br>   - Regular, context-free, context-sensitive, and recursively enumerable languages were defined, leading to the development of grammars and parsing algorithms.
    <br>
    <br>3. Algorithm Analysis (mid-20th century):
    <br>   - The development of algorithm analysis and design techniques, with landmark work by Donald Knuth in "The Art of Computer Programming," helped identify efficient algorithms and their complexity.
    <br>
    <br>4. Complexity Theory (1960s and 1970s):
    <br>   - Complexity theory, spearheaded by Stephen Cook and Leonid Levin, led to the definition of NP-completeness and the P vs. NP problem, which remains one of the most famous unsolved questions in computer science.
    <br>
    <br>5. Data Structures and Search Algorithms (1960s and 1970s):
    <br>   - Dijkstra's algorithm, various data structures like AVL trees and hash tables, and other search algorithms were developed, contributing to efficient data manipulation and retrieval.
    <br>
    <br>6. Formal Logic and Proof Theory:
    <br>   - Theoretical computer science incorporated concepts from formal logic and proof theory to study the correctness of algorithms and the verification of software.
    <br>
    <br>7. Computational Complexity (1980s and 1990s):
    <br>   - The field of computational complexity theory expanded significantly, studying the inherent difficulty of problems and classifying them into complexity classes like P, NP, and many others.
    <br>
    <br>8. Randomized Algorithms (1980s and 1990s):
    <br>   - The development of randomized algorithms and the study of probabilistic complexity classes brought new perspectives on algorithm design.
    <br>
    <br>9. Quantum Computing (1990s and beyond):
    <br>   - Theoretical computer science has ventured into quantum computing, exploring the potential advantages of quantum algorithms and quantum complexity classes.
    <br>
    <br>10. Cryptography (1970s and beyond):
    <br>    - The study of cryptographic algorithms, their security properties, and the development of new cryptographic schemes have been crucial in the digital age.
    <br>
    <br>11. Machine Learning and Computational Learning Theory (1990s and beyond):
    <br>    - Theoretical computer science has influenced machine learning with the development of computational learning theory, which provides a foundation for understanding the learnability of concepts by machines.
    <br>
    <br>12. Distributed Computing and Network Algorithms:
    <br>    - The study of distributed systems, networking algorithms, and consensus algorithms has grown in importance as computer systems have become more interconnected.
    <br>
    <br>13. Formal Methods and Software Verification (1990s and beyond):
    <br>    - Formal methods are increasingly being used to prove the correctness of software and hardware systems, improving their reliability and security.
    <br>
    <br>Theoretical computer science continues to evolve with the emergence of new challenges and technologies. It plays a fundamental role in shaping the field of computer science as a whole, enabling the development of efficient algorithms, the study of computational limits, and the foundation of secure and reliable software and systems."
    <br>[{2023-10-20 retrieved} https://chat.openai.com/c/7e63e70f-2df0-4729-8a3a-dd2625ffb476]
    <a class="clsHide" href="#idSCmpr007evlgdsn"></a></p>
  <p id="idSCmpr007evlgnam">name::
    <br>* McsEngl.evoluting-of-theoritical-computer-science,
    <br>* McsEngl.theoritical-computer-science'evoluting,
    <a class="clsHide" href="#idSCmpr007evlgnam"></a></p>
  </section>
</section>

<section id="idSCmpr006">
  <h1 id="idSCmpr006H1">sciCmpr.automata-theory
    <a class="clsHide" href="#idSCmpr006H1"></a></h1>
  <p id="idSCmpr006dsn">description::
    <br>"overview of automata-theory:
    <br>Automata theory is a branch of theoretical computer science that focuses on the study of abstract machines and their computational capabilities. It plays a fundamental role in computer science, particularly in the design and analysis of algorithms, programming languages, and the study of formal languages. Automata theory has applications in various fields, including software engineering, compiler design, artificial intelligence, and natural language processing. Here's an overview of some key concepts and components of automata theory:
    <br>
    <br>1. Automaton: An automaton is an abstract mathematical model that represents a computation or a computational process. There are different types of automata, each with varying degrees of computational power. The most common types of automata include:
    <br>   - Finite Automaton (FA): A simple machine with a finite set of states and transitions between those states. It is often used for pattern matching and simple language recognition.
    <br>   - Pushdown Automaton (PDA): An extension of finite automata with a stack that allows it to recognize context-free languages.
    <br>   - Turing Machine (TM): A more powerful model that can simulate any algorithmic process. It forms the basis for the theory of computation and is used to define what is computationally feasible and infeasible.
    <br>
    <br>2. Formal Languages: Automata theory is closely related to the study of formal languages, which are sets of strings or sequences of symbols. These languages are classified into different types based on their generative power, including regular languages, context-free languages, context-sensitive languages, and recursively enumerable languages.
    <br>
    <br>3. Regular Languages: These languages can be recognized by finite automata and are defined using regular expressions. Regular languages are used in lexical analysis and pattern matching in text processing.
    <br>
    <br>4. Context-Free Languages: These languages can be recognized by pushdown automata. They are used to describe the syntax of programming languages and are vital for parsing and code generation in compilers.
    <br>
    <br>5. Context-Sensitive Languages: These languages are recognized by more powerful automata called linear-bounded automata and are used for representing complex syntax and semantics in programming languages.
    <br>
    <br>6. Decidability and Computability: Automata theory explores the fundamental questions of what can and cannot be computed. Concepts such as decidability, the halting problem, and the Church-Turing thesis play a central role in understanding the limits of computation.
    <br>
    <br>7. Non-determinism and Determinism: Automata can be deterministic, where each state has a unique transition for each input symbol, or non-deterministic, where multiple transitions can be taken from the same state with the same input symbol. Non-deterministic automata are often more expressive and are used to simplify certain types of problems.
    <br>
    <br>8. Pumping Lemma: This is a tool used to prove the non-regularity of languages by demonstrating that any sufficiently long string in the language can be "pumped" to create longer strings not in the language.
    <br>
    <br>Automata theory is a foundation for understanding the theoretical limits of computation and for solving practical problems in the field of computer science. It is an essential part of the curriculum for computer science and engineering students and is applied in various domains, including compiler design, formal verification, and natural language processing."
    <br>[{2023-10-16 retrieved} https://chat.openai.com/c/bb5ddc26-bd11-414c-b3bb-5aaaebd0bc3c]
    <a class="clsHide" href="#idSCmpr006dsn"></a></p>
  <p id="idSCmpr006nam">name::
    <br>* McsEngl.automata-theory,
    <br>* McsEngl.sciCmpr.006-automata-theory,
    <br>* McsEngl.sciCmpr.automata-theory,
    <a class="clsHide" href="#idSCmpr006nam"></a></p>

  <section id="idSCmpr006evlg">
  <h2 id="idSCmpr006evlgH2">evoluting of automata-theory
    <a class="clsHide" href="#idSCmpr006evlgH2"></a></h2>
  <p id="idSCmpr006evlgdsn">description::
    <br>"evolution of automata-theory:
    <br>The field of automata theory has a rich history that has evolved over the years, driven by the contributions of numerous mathematicians, computer scientists, and logicians. Here is a brief overview of the evolution of automata theory:
    <br>
    <br>1. Early Mathematical Concepts (17th-19th centuries):
    <br>   - The roots of automata theory can be traced back to the work of mathematicians like Leonhard Euler and George Boole. Euler's famous Seven Bridges of Königsberg problem laid the foundation for graph theory, which is closely related to automata theory.
    <br>
    <br>2. Logic Machines (19th century):
    <br>   - George Boole's development of Boolean algebra in the mid-19th century laid the groundwork for symbolic logic and digital computation, which is essential for automata theory.
    <br>
    <br>3. Finite Automata (Early 20th century):
    <br>   - David Hilbert's work on decision problems and Gödel's incompleteness theorems in the early 20th century led to a deeper understanding of the limits of formal systems.
    <br>   - In the 1930s, Alonzo Church and Alan Turing independently introduced the notion of a universal machine (Turing machine), which could simulate any algorithmic process. This concept laid the foundation for the theory of computation and automata.
    <br>
    <br>4. Automata and Formal Languages (Mid-20th century):
    <br>   - In the 1950s and 1960s, researchers like Stephen Kleene, John Backus, and Noam Chomsky made significant contributions to the formalization of languages and automata. Chomsky introduced the Chomsky hierarchy, which classifies languages into different types based on their generative power.
    <br>   - Regular expressions and finite automata were introduced as tools to describe and recognize regular languages.
    <br>
    <br>5. Development of Automata Types:
    <br>   - Pushdown automata, introduced by Michael Rabin and Dana Scott in the late 1950s, extended the power of finite automata to recognize context-free languages.
    <br>   - In the 1960s and 1970s, the theory of context-sensitive languages and linear-bounded automata was developed, contributing to the study of more complex languages and grammars.
    <br>
    <br>6. Practical Applications (Late 20th century):
    <br>   - Automata theory found practical applications in computer science, particularly in compiler design and formal methods for software verification.
    <br>   - Regular expressions and finite automata became fundamental tools in text processing and lexical analysis.
    <br>
    <br>7. Complexity Theory and Modern Automata (Late 20th century to present):
    <br>   - Complexity theory, which studies the computational complexity of problems, emerged as a closely related field.
    <br>   - Automata theory continues to evolve with advancements in the study of non-determinism, alternating automata, and automata with memory, among other areas.
    <br>
    <br>8. Automata in Modern Computing (21st century):
    <br>   - Automata theory remains a fundamental part of computer science, with applications in fields like natural language processing, automata-based modeling and verification, and the study of algorithmic complexity.
    <br>
    <br>The evolution of automata theory reflects its significance as a foundation for understanding the theoretical limits of computation, formal languages, and the development of algorithms. It continues to be a dynamic and evolving field, with applications in various domains of computer science and beyond."
    <br>[{2023-10-16 retrieved} https://chat.openai.com/c/bb5ddc26-bd11-414c-b3bb-5aaaebd0bc3c]
    <a class="clsHide" href="#idSCmpr006evlgdsn"></a></p>
  <p id="idSCmpr006evlgnam">name::
    <br>* McsEngl.evoluting-of-automata-theory,
    <br>* McsEngl.automata-theory'evoluting,
    <a class="clsHide" href="#idSCmpr006evlgnam"></a></p>
  </section>
</section>

<section id="idSCmpr005">
  <h1 id="idSCmpr005H1">sciCmpr.algorithms-theory
    <a class="clsHide" href="#idSCmpr005H1"></a></h1>
  <p id="idSCmpr005dsn">description::
    <br>"algorithms theory
    <br>Algorithms theory is the study of the design and analysis of algorithms. It is concerned with developing methods for designing efficient and reliable algorithms for solving computational problems.
    <br>
    <br>Algorithms theory is a subfield of computer science, but it also has close ties to mathematics and other fields. For example, algorithms theory uses mathematical tools such as graph theory and combinatorics to design and analyze algorithms.
    <br>
    <br>Algorithms theory is a broad field, and there are many different topics that are studied within it. Some of the most important topics in algorithms theory include:
    <br>* Algorithm design: Algorithm design is the process of developing a new algorithm for solving a computational problem. There are many different algorithm design techniques, such as divide-and-conquer, greedy algorithms, and dynamic programming.
    <br>* Algorithm analysis: Algorithm analysis is the process of determining the performance of an algorithm. This includes analyzing the algorithm's time complexity, space complexity, and other performance metrics.
    <br>* Data structures: Data structures are ways of organizing data in a computer so that it can be efficiently accessed and manipulated. Algorithms theory is closely related to data structures, because the choice of data structure can have a significant impact on the performance of an algorithm.
    <br>* Computability theory: Computability theory is the study of the limits of computation. It is concerned with determining which problems can be solved by algorithms and which problems cannot be solved by algorithms.
    <br>
    <br>Algorithms theory has a wide range of applications in many different fields. For example, algorithms theory is used to develop algorithms for sorting and searching data, routing traffic in networks, and designing compilers and operating systems.
    <br>
    <br>Here are some specific examples of how algorithms theory is used in different fields:
    <br>* Computer science: Algorithms theory is used in computer science to develop algorithms for a wide range of tasks, such as sorting and searching data, routing traffic in networks, and designing compilers and operating systems.
    <br>* Engineering: Algorithms theory is used in engineering to develop algorithms for tasks such as designing control systems, optimizing manufacturing processes, and processing signals.
    <br>* Biology: Algorithms theory is used in biology to develop algorithms for tasks such as analyzing DNA sequences, predicting protein structure, and modeling the spread of diseases.
    <br>* Finance: Algorithms theory is used in finance to develop algorithms for tasks such as trading stocks, pricing options, and managing risk.
    <br>
    <br>Algorithms theory is a powerful tool that can be used to solve a wide range of problems in many different fields. It is a fundamental subject for anyone who wants to understand the modern world."
    <br>[{2023-10-04 retrieved} https://bard.google.com/chat/6dfe923849366e22]
    <a class="clsHide" href="#idSCmpr005dsn"></a></p>
  <p id="idSCmpr005nam">name::
    <br>* McsEngl.algorithms-theory,
    <br>* McsEngl.sciCmpr.005-algorithms-theory,
    <br>* McsEngl.sciCmpr.algorithms-theory,
    <a class="clsHide" href="#idSCmpr005nam"></a></p>
</section>

<section id="idSCmpr003">
  <h1 id="idSCmpr003H1">sciCmpr.theory-of-computation
    <a class="clsHide" href="#idSCmpr003H1"></a></h1>
  <p id="idSCmpr003dsn">description::
    <br>"In theoretical computer science and mathematics, the theory of computation is the branch that deals with what problems can be solved on a model of computation, using an algorithm, how efficiently they can be solved or to what degree (e.g., approximate solutions versus precise ones). The field is divided into three major branches: automata theory and formal languages, computability theory, and computational complexity theory, which are linked by the question: "What are the fundamental capabilities and limitations of computers?".[1]"
    <br>[{2023-08-27 retrieved} https://en.wikipedia.org/wiki/Theory_of_computation]
    <br>
    <br>"The Theory of Computation is a branch of computer science that deals with the study of algorithms, their computational complexity, and the inherent limits of what can be computed. It encompasses various topics, including automata theory, formal languages, computability theory, and complexity theory. This field explores questions related to what can be computed, how efficiently it can be computed, and what problems are inherently unsolvable by computers."
    <br>[{2023-10-03 retrieved} https://chat.openai.com/c/075fa94a-81a9-4e6c-b94e-b80f45912a30]
    <a class="clsHide" href="#idSCmpr003dsn"></a></p>
  <p id="idSCmpr003nam">name::
    <br>* McsEngl.sciCmpr.003-theory-of-computation,
    <br>* McsEngl.sciCmpr.theory-of-computation,
    <br>* McsEngl.theory-of-computation,
    <br>====== langoGreek:
    <br>* McsElln.θεωρία-υπολογισμού!=theory-of-computation,
    <a class="clsHide" href="#idSCmpr003nam"></a></p>
  <p id="idSCmpr003dsnL">descriptionLong::
    <br>"θεωρία υπολογισμού επισκόπηση
    <br>Η θεωρία υπολογισμού είναι ένα πεδίο της επιστήμης των υπολογιστών που μελετά τις θεμελιώδεις ιδιότητες των υπολογιστικών συστημάτων. Ασχολείται με το πώς μπορούν να αναπτυχθούν και να αξιολογηθούν αποτελεσματικές μέθοδοι για την επίλυση προβλημάτων.
    <br>Η θεωρία υπολογισμού έχει τις ρίζες της στην μαθηματική λογική και τη θεωρία των συνόλων. Η πρώτη σημαντική συνεισφορά στο πεδίο ήταν η απόδειξη του Alan Turing ότι υπάρχει ένας γενικός αλγόριθμος που μπορεί να λύσει οποιοδήποτε προβλήμα που μπορεί να λυθεί με μια ακολουθία αναδρομικών βημάτων. Αυτή η απόδειξη οδήγησε στην ανάπτυξη της θεωρίας της υπολογισιμότητας, η οποία ταξινομεί τα προβλήματα ανάλογα με την πολυπλοκότητά τους.
    <br>Μια άλλη σημαντική συνεισφορά στη θεωρία υπολογισμού ήταν η ανάπτυξη της θεωρίας της πληροφορίας. Η θεωρία της πληροφορίας μελετά τη φύση της πληροφορίας και πώς μπορεί να κωδικοποιηθεί και να μεταδοθεί. Η θεωρία της πληροφορίας έχει εφαρμογές σε μια ποικιλία πεδίων, όπως η κωδικοποίηση δεδομένων, η ψηφιακή επικοινωνία και η τεχνητή νοημοσύνη.
    <br>Η θεωρία υπολογισμού είναι ένα ευρύ και διεπιστημονικό πεδίο. Εφαρμόζεται σε μια ποικιλία πεδίων, όπως η επιστήμη των υπολογιστών, η μαθηματική λογική, η θεωρία των συνόλων, η θεωρία της πληροφορίας, η τεχνητή νοημοσύνη και η επιστήμη των δεδομένων.
    <br>
    <br>Σημαντικά θέματα στη θεωρία υπολογισμού
    <br>* Υπολογισιμότητα: Το ερώτημα εάν ένας αλγόριθμος μπορεί να λύσει ένα πρόβλημα.
    <br>* Πολυπλοκότητα υπολογισμού: Η μέτρηση του κόστους εκτέλεσης ενός αλγορίθμου.
    <br>* Θεωρία της πληροφορίας: Η μελέτη της φύσης της πληροφορίας και πώς μπορεί να κωδικοποιηθεί και να μεταδοθεί.
    <br>* Κωδικοποίηση δεδομένων: Η διαδικασία συμπίεσης δεδομένων για να μειωθεί ο όγκος τους.
    <br>* Τηλεπικοινωνίες: Η μετάδοση δεδομένων από ένα σημείο σε ένα άλλο.
    <br>* Τεχνητή νοημοσύνη: Η ανάπτυξη συστημάτων που μπορούν να σκέφτονται και να ενεργούν όπως οι άνθρωποι.
    <br>* Επιστήμη των δεδομένων: Η συλλογή, η ανάλυση και η ερμηνεία δεδομένων.
    <br>
    <br>Εφαρμογές της θεωρίας υπολογισμού
    <br>Η θεωρία υπολογισμού έχει εφαρμογές σε μια ποικιλία πεδίων, όπως:
    <br>* Επιστήμη των υπολογιστών: Η θεωρία υπολογισμού χρησιμοποιείται για τη μελέτη της αποτελεσματικότητας και της πολυπλοκότητας των αλγορίθμων.
    <br>* Μαθηματική λογική: Η θεωρία υπολογισμού χρησιμοποιείται για τη μελέτη της λογικής και της αποτελεσματικότητας της απόδειξης.
    <br>* Θεωρία των συνόλων: Η θεωρία υπολογισμού χρησιμοποιείται για τη μελέτη της τοπολογίας των συνόλων.
    <br>* Θεωρία της πληροφορίας: Η θεωρία υπολογισμού χρησιμοποιείται για τη μελέτη της κωδικοποίησης και της μετάδοσης πληροφοριών.
    <br>* Τεχνητή νοημοσύνη: Η θεωρία υπολογισμού χρησιμοποιείται για τη μελέτη της νοημοσύνης και της μηχανικής μάθησης.
    <br>* Επιστήμη των δεδομένων: Η θεωρία υπολογισμού χρησιμοποιείται για τη μελέτη της συλλογής, της ανάλυσης και της ερμηνείας δεδομένων.
    <br>
    <br>Σπουδές στη θεωρία υπολογισμού
    <br>Η θεωρία υπολογισμού διδάσκεται στα περισσότερα προγράμματα επιστήμης των υπολογιστών. Οι σπουδαστές στη θεωρία υπολογισμού μαθαίνουν για τα βασικά θέματα του πεδίου, όπως η υπολογισιμότητα, η πολυπλοκότητα υπολογισμού και η θεωρία της πληροφορίας.
    <br>Οι σπουδαστές στη θεωρία υπολογισμού μπορούν να ακολουθήσουν καριέρα στην έρευνα, τη διδασκαλία ή τη βιομηχανία. Οι ερευνητές στη θεωρία υπολογισμού εργάζονται για την ανάπτυξη νέων θεωρημάτων και αλγορίθμων. Οι καθηγητές στη θεωρία υπολογισμού διδάσκουν μαθήματα στο πεδίο. Οι επαγγελματίες στη θεωρία υπολογισμού εργάζονται σε εταιρείες λογισμικού ή σε οργανισμούς που χρησιμοποιούν υπολογιστές."
    <br>[{2023-10-03 retrieved} https://bard.google.com/chat/6eeac4dbe9b6e921]
    <a class="clsHide" href="#idSCmpr003dsnL"></a></p>

  <section id="idSCmpr003cppm">
  <h2 id="idSCmpr003cppmH2">computational-problem
    <a class="clsHide" href="#idSCmpr003cppmH2"></a></h2>
  <p id="idSCmpr003cppmdsn">description::
    <br>"In theoretical computer science, a computational problem is a problem that may be solved by an algorithm."
    <br>[{2023-10-13 retrieved} https://en.wikipedia.org/wiki/Computational_problem]
    <a class="clsHide" href="#idSCmpr003cppmdsn"></a></p>
  <p id="idSCmpr003cppmnam">name::
    <br>* McsEngl.computational-problem,
    <a class="clsHide" href="#idSCmpr003cppmnam"></a></p>
  </section>

  <section id="idSCmpr003evlg">
  <h2 id="idSCmpr003evlgH2">evoluting of theory-of-computatio
    <a class="clsHide" href="#idSCmpr003evlgH2"></a></h2>
  <p id="idSCmpr003evlgdsn">description::
    <br>"evolution of theory-of-computation:
    <br>The theory of computation has evolved over time, with key developments and milestones shaping its progression. Here is an overview of the evolution of the theory of computation:
    <br>
    <br>1. Alan Turing's Machine (1936):
    <br>   - The theory of computation traces its roots to Alan Turing's paper "On Computable Numbers, with an Application to the Entscheidungsproblem" in 1936.
    <br>   - Turing introduced the concept of a theoretical machine, now known as the Turing machine, which served as a mathematical model for computation.
    <br>   - This laid the foundation for the study of algorithms and computability.
    <br>
    <br>2. Church-Turing Thesis (1936):
    <br>   - Alonzo Church and Alan Turing independently formulated the Church-Turing thesis, asserting that any effectively computable function can be computed by a Turing machine.
    <br>   - This thesis provided a basis for defining what is computable and what is not.
    <br>
    <br>3. Development of Automata Theory:
    <br>   - In the late 1930s and 1940s, the theory of automata, including finite automata and pushdown automata, was developed by mathematicians such as Warren McCulloch, Walter Pitts, and John von Neumann.
    <br>   - These developments contributed to the understanding of computation and the formalization of languages and their recognition.
    <br>
    <br>4. Computational Complexity Theory:
    <br>   - The 1960s and 1970s saw the emergence of computational complexity theory, with the work of Stephen Cook, Leonid Levin, and Richard Karp.
    <br>   - Cook's discovery of NP-completeness and Karp's reduction techniques led to the classification of computational problems based on their difficulty.
    <br>
    <br>5. Theory of Formal Languages and Grammars:
    <br>   - The work of Noam Chomsky in the 1950s and 1960s led to the formalization of grammars and the classification of languages into different types, such as regular, context-free, context-sensitive, and recursively enumerable.
    <br>   - This work laid the foundation for parsing and language processing.
    <br>
    <br>6. Formal Logic and Proof Theory:
    <br>   - Mathematical logic, including first-order logic, predicate calculus, and proof theory, has played a crucial role in the theory of computation.
    <br>   - Logicians like Kurt Gödel and Alfred Tarski made significant contributions to formal logic.
    <br>
    <br>7. Quantum Computation:
    <br>   - In the 1980s and 1990s, the field of quantum computation emerged, with pioneers like David Deutsch, Richard Feynman, and Peter Shor.
    <br>   - Quantum computing introduced new paradigms for computation, such as quantum gates and quantum algorithms.
    <br>
    <br>8. Algorithm Analysis and Design:
    <br>   - The study of algorithms and their efficiency has been a fundamental part of the theory of computation.
    <br>   - Key developments in algorithm design include dynamic programming, greedy algorithms, and divide-and-conquer strategies.
    <br>
    <br>9. Theoretical Computer Science:
    <br>   - The theory of computation has evolved into a broader field known as theoretical computer science.
    <br>   - This field encompasses formal methods, automata theory, complexity theory, and more, and it plays a crucial role in computer science and related disciplines.
    <br>
    <br>10. Ongoing Developments:
    <br>    - The theory of computation continues to evolve, with ongoing research into quantum computing, artificial intelligence, machine learning, and new computational paradigms.
    <br>
    <br>The theory of computation remains a dynamic and evolving field, continually adapting to new technologies and challenges in the world of computing and mathematics."
    <br>[{2023-10-20 retrieved} https://chat.openai.com/c/c025a0e7-2969-4f53-89f9-b52d461377c6]
    <a class="clsHide" href="#idSCmpr003evlgdsn"></a></p>
  <p id="idSCmpr003evlgnam">name::
    <br>* McsEngl.evoluting-of-theory-of-computation,
    <br>* McsEngl.theory-of-computation'evoluting,
    <a class="clsHide" href="#idSCmpr003evlgnam"></a></p>
  </section>
</section>

<section id="idSCmpr004">
  <h1 id="idSCmpr004H1">sciCmpr.computability-theory (recursion-theory)
    <a class="clsHide" href="#idSCmpr004H1"></a></h1>
  <p id="idSCmpr004dsn">description::
    <br>"what can and cannot be computed algorithmically"
    <br>"Computability theory, also known as recursion theory, is a branch of mathematical logic, computer science, and the theory of computation that originated in the 1930s with the study of computable functions and Turing degrees. The field has since expanded to include the study of generalized computability and definability. In these areas, computability theory overlaps with proof theory and effective descriptive set theory.
    <br>Basic questions addressed by computability theory include:
    <br>* What does it mean for a function on the natural numbers to be computable?
    <br>* How can nocomputable functions be classified into a hierarchy based on their level of noncomputability?
    <br>Although there is considerable overlap in terms of knowledge and methods, mathematical computability theorists study the theory of relative computability, reducibility notions, and degree structures; those in the computer science field focus on the theory of subrecursive hierarchies, formal methods, and formal languages."
    <br>[{2023-08-27 retrieved} https://en.wikipedia.org/wiki/Computability_theory]
    <a class="clsHide" href="#idSCmpr004dsn"></a></p>
  <p id="idSCmpr004nam">name::
    <br>* McsEngl.computability-theory,
    <br>* McsEngl.recursion-theory,
    <br>* McsEngl.sciCmpr.004-computability-theory,
    <br>* McsEngl.sciCmpr.computability-theory,
    <br>====== langoGreek:
    <br>* McsElln.θεωρία-υπολογισιμότητας!=computability-theory,
    <a class="clsHide" href="#idSCmpr004nam"></a></p>

  <section id="idSCmpr004evlg">
  <h2 id="idSCmpr004evlgH2">evoluting of computability-theory
    <a class="clsHide" href="#idSCmpr004evlgH2"></a></h2>
  <p id="idSCmpr004evlgdsn">description::
    <br>"evolution of computability-theory:
    <br>The evolution of computability theory is a fascinating journey that spans the 20th century and continues to influence the field of computer science. Computability theory, also known as recursion theory, explores the fundamental limits and capabilities of computation, focusing on the notion of what can and cannot be computed algorithmically. Here is a brief overview of its evolution:
    <br>
    <br>1. Early 20th Century: The roots of computability theory can be traced back to the early 20th century. Mathematicians such as David Hilbert and Kurt Gödel were investigating the foundations of mathematics. Gödel's incompleteness theorems (1931) showed that certain mathematical questions are undecidable, providing an early glimpse of the limitations of formal systems.
    <br>
    <br>2. Alan Turing's Contributions (1936): The turning point in the development of computability theory was the work of Alan Turing. In his 1936 paper "On Computable Numbers, with an Application to the Entscheidungsproblem," Turing introduced the concept of the Turing machine. Turing machines are abstract models of computation that capture the essence of algorithmic computation. He demonstrated that there are problems that cannot be solved by any algorithm and that the halting problem (determining whether a given program terminates) is undecidable.
    <br>
    <br>3. Church-Turing Thesis (1936): Alonzo Church independently developed a different formalism for computation, known as the lambda calculus, which was shown to be equivalent in power to the Turing machine. The Church-Turing thesis suggests that any function that is intuitively computable can be computed by a Turing machine or in the lambda calculus. This thesis has played a central role in computability theory, and it's still a foundation of computer science.
    <br>
    <br>4. Post-War Development: After World War II, computability theory continued to evolve. The theory of recursive functions, developed by Stephen Kleene, Emil Post, and others, provided an alternate formalism for computability and contributed to a deeper understanding of algorithmic computation.
    <br>
    <br>5. Emergence of Complexity Theory: In the 1960s and 1970s, complexity theory emerged as a related field to computability theory. Complexity theory deals with the resources required to solve problems, such as time and space. This field explored the classification of problems into complexity classes, like P (problems solvable in polynomial time) and NP (nondeterministic polynomial time), which have significant implications for algorithm design and cryptography.
    <br>
    <br>6. Modern Developments: Computability theory and its related areas continue to evolve. Research in these fields has led to the development of new models of computation, such as quantum computing and DNA computing. Researchers also investigate various problem classes, decision procedures, and complexity bounds.
    <br>
    <br>7. Practical Implications: The theoretical foundations of computability theory have had practical implications in the design and analysis of algorithms, the development of programming languages, and the understanding of the limits of artificial intelligence and computation.
    <br>
    <br>In summary, computability theory has its roots in early 20th-century mathematics and has since become a foundational pillar of computer science. It has helped define the boundaries of what can be computed algorithmically and continues to inspire research and innovation in the field of computation."
    <br>[{2023-10-12 retrieved} https://chat.openai.com/c/f0875d4c-6e4a-4fc0-b868-d94b58d61dd3]
    <a class="clsHide" href="#idSCmpr004evlgdsn"></a></p>
  <p id="idSCmpr004evlgnam">name::
    <br>* McsEngl.evoluting-of-computability-theory,
    <br>* McsEngl.computability-theory'evoluting,
    <a class="clsHide" href="#idSCmpr004evlgnam"></a></p>
  </section>
</section>

<section id="idSCmpr001">
  <h1 id="idSCmpr001H1">sciCmpr.computational-science
    <a class="clsHide" href="#idSCmpr001H1"></a></h1>
  <p id="idSCmpr001dsn">description::
    <br>· "Computational science, also known as scientific computing, technical computing or scientific computation (SC), is a division of science that uses advanced computing capabilities to understand and solve complex physical problems. This includes
    <br>* Algorithms (numerical and non-numerical): mathematical models, computational models, and computer simulations developed to solve sciences (e.g, physical, biological, and social), engineering, and humanities problems
    <br>* Computer hardware that develops and optimizes the advanced system hardware, firmware, networking, and data management components needed to solve computationally demanding problems
    <br>* The computing infrastructure that supports both the science and engineering problem solving and the developmental computer and information science
    <br>In practical use, it is typically the application of computer simulation and other forms of computation from numerical analysis and theoretical computer science to solve problems in various scientific disciplines. The field is different from theory and laboratory experiments, which are the traditional forms of science and engineering. The scientific computing approach is to gain understanding through the analysis of mathematical models implemented on computers. Scientists and engineers develop computer programs and application software that model systems being studied and run these programs with various sets of input parameters. The essence of computational science is the application of numerical algorithms[1] and computational mathematics. In some cases, these models require massive amounts of calculations (usually floating-point) and are often executed on supercomputers or distributed computing platforms.[verification needed]"
    <br>[{2023-08-23 retrieved} https://en.wikipedia.org/wiki/Computational_science]
    <a class="clsHide" href="#idSCmpr001dsn"></a></p>
  <p id="idSCmpr001nam">name::
    <br>* McsEngl.computational-science!⇒sciComputational,
    <br>* McsEngl.sciCmpr.001-computational-science!⇒sciComputational,
    <br>* McsEngl.sciCmpr.computational-science!⇒sciComputational,
    <br>* McsEngl.sciComputational,
    <br>* McsEngl.scientific-computation!⇒sciComputational,
    <br>* McsEngl.scientific-computing!⇒sciComputational,
    <br>* McsEngl.technical-computing!⇒sciComputational,
    <a class="clsHide" href="#idSCmpr001nam"></a></p>

  <section id="idSCmpr001rtscmpr">
  <h2 id="idSCmpr001rtscmprH2">relation-to-sciCmpr of sciComputational
    <a class="clsHide" href="#idSCmpr001rtscmprH2"></a></h2>
  <p id="idSCmpr001rtscmprdsn">description::
    <br>· "Computer Science focuses on the theory, design, and development of computing technologies and software, while Computational Science focuses on using computers to solve complex scientific and engineering problems through simulations and modeling."
    <br>[{2023-08-23 retrieved} https://chat.openai.com/?model=text-davinci-002-render-sha]
    <a class="clsHide" href="#idSCmpr001rtscmprdsn"></a></p>
  <p id="idSCmpr001rtscmprnam">name::
    <br>* McsEngl.sciCmpr'relation-to-sciComputational,
    <br>* McsEngl.sciComputational'relation-to-sciCmpr,
    <a class="clsHide" href="#idSCmpr001rtscmprnam"></a></p>
  </section>

  <section id="idSCmpr001wpt">
  <h2 id="idSCmpr001wptH2">WHOLE-PART-TREE of sciComputational
    <a class="clsHide" href="#idSCmpr001wptH2"></a></h2>
  <p id="idSCmpr001wptdsn">description::
    <br>· part-branches:
    <br>* Bioinformatics,
    <br>* Car–Parrinello molecular dynamics,
    <br>* Cheminformatics,
    <br>* Chemometrics,
    <br>* Computational archaeology,
    <br>* Computational astrophysics,
    <br>* Computational biology,
    <br>* Computational chemistry,
    <br>* Computational materials science,
    <br>* Computational economics,
    <br>* Computational electromagnetics,
    <br>* Computational engineering,
    <br>* Computational finance,
    <br>* Computational fluid dynamics,
    <br>* Computational forensics,
    <br>* Computational geophysics,
    <br>* Computational history,
    <br>* Computational informatics,
    <br>* Computational intelligence,
    <br>* Computational law,
    <br>* Computational linguistics,
    <br>* Computational mathematics,
    <br>* Computational mechanics,
    <br>* Computational neuroscience,
    <br>* Computational particle physics,
    <br>* Computational physics,
    <br>* Computational sociology,
    <br>* Computational statistics,
    <br>* Computational sustainability,
    <br>* Computer algebra,
    <br>* Computer simulation,
    <br>* Financial modeling,
    <br>* Geographic information science,
    <br>* Geographic information system (GIS),
    <br>* High-performance computing,
    <br>* Machine learning,
    <br>* Network analysis,
    <br>* Neuroinformatics,
    <br>* Numerical linear algebra,
    <br>* Numerical weather prediction,
    <br>* Pattern recognition,
    <br>* Scientific visualization,
    <br>* Simulation,
    <br>[{2023-08-23 retrieved} https://en.wikipedia.org/wiki/Computational_science#Subfields]
    <a class="clsHide" href="#idSCmpr001wptdsn"></a></p>
  <p id="idSCmpr001wptnam">name::
    <br>* McsEngl.sciComputational'whole-part-tree,
    <a class="clsHide" href="#idSCmpr001wptnam"></a></p>
  </section>

  <section id="idSCmpr002">
  <h2 id="idSCmpr002H2">computer-algebra of sciComputational
    <a class="clsHide" href="#idSCmpr002H2"></a></h2>
  <p id="idSCmpr002dsn">description::
    <br>× whole: sciComputational,
    <br>· "In mathematics and computer science,[1] computer algebra, also called symbolic computation or algebraic computation, is a scientific area that refers to the study and development of algorithms and software for manipulating mathematical expressions and other mathematical objects. Although computer algebra could be considered a subfield of scientific computing, they are generally considered as distinct fields because scientific computing is usually based on numerical computation with approximate floating point numbers, while symbolic computation emphasizes exact computation with expressions containing variables that have no given value and are manipulated as symbols.
    <br>Software applications that perform symbolic calculations are called computer algebra systems, with the term system alluding to the complexity of the main applications that include, at least, a method to represent mathematical data in a computer, a user programming language (usually different from the language used for the implementation), a dedicated memory manager, a user interface for the input/output of mathematical expressions, a large set of routines to perform usual operations, like simplification of expressions, differentiation using chain rule, polynomial factorization, indefinite integration, etc.,
    <br>Computer algebra is widely used to experiment in mathematics and to design the formulas that are used in numerical programs. It is also used for complete scientific computations, when purely numerical methods fail, as in public key cryptography, or for some non-linear problems.",
    <br>[{2023-08-23 retrieved} https://en.wikipedia.org/wiki/Computer_algebra]
    <a class="clsHide" href="#idSCmpr002dsn"></a></p>
  <p id="idSCmpr002nam">name::
    <br>* McsEngl.sciCmpr.002-computer-algebra,
    <br>* McsEngl.sciCmpr.computer-algebra,
    <br>* McsEngl.sciComputer_algebra,
    <a class="clsHide" href="#idSCmpr002nam"></a></p>

  <section id="idSCmpr002cas">
  <h3 id="idSCmpr002casH3">computer-algebra-system of sciComputer_algebra
    <a class="clsHide" href="#idSCmpr002casH3"></a></h3>
  <p id="idSCmpr002casdsn">description::
    <br>· "Here are some of the most popular computer algebra systems:
    <br>* Maple: Maple is a commercial computer algebra system developed by Waterloo Maple Inc. Maple is known for its powerful symbolic computation capabilities.,
    <br>* Mathematica: Mathematica is a commercial computer algebra system developed by Wolfram Research. Mathematica is known for its graphical capabilities and its ability to integrate symbolic and numerical computation.,
    <br>* SymPy: SymPy is a free and open-source computer algebra system. SymPy is known for its flexibility and its ability to be extended by users.,
    <br>* SageMath: SageMath is a free and open-source computer algebra system. SageMath is a powerful system that combines the features of many other computer algebra systems.,
    <br>* Reduce: Reduce is a free and open-source computer algebra system. Reduce is known for its efficiency and its ability to handle large problems.,
    <br>These are just a few of the many computer algebra systems that are available. The best system for a particular task will depend on the specific needs of the user.",
    <br>[{2023-08-23 retrieved} https://bard.google.com/]
    <a class="clsHide" href="#idSCmpr002casdsn"></a></p>
  <p id="idSCmpr002casnam">name::
    <br>* McsEngl.computer-algebra-system,
    <a class="clsHide" href="#idSCmpr002casnam"></a></p>
  </section>

  <section id="idSCmpr002wpt">
  <h3 id="idSCmpr002wptH3">WHOLE-PART-TREE of sciComputer_algebra
    <a class="clsHide" href="#idSCmpr002wptH3"></a></h3>
  <p id="idSCmpr002wptdsn">description::
    <br>· "The field of computer algebra can be classified into the following subfields:
    <br>* Symbolic computation: This subfield deals with the manipulation of symbolic expressions, such as polynomials, rational functions, and power series. Symbolic computation is used to solve equations, find derivatives, and perform other symbolic operations.,
    <br>* Algebraic geometry: This subfield deals with the study of algebraic curves, surfaces, and varieties. Algebraic geometry is used to classify algebraic objects, such as elliptic curves and hypersurfaces.,
    <br>* Numerical computation: This subfield deals with the approximation of solutions to mathematical problems. Numerical computation is used to solve differential equations, compute integrals, and perform other numerical tasks.,
    <br>* Symbolic-numeric computation: This subfield combines symbolic and numerical computation to solve problems that are difficult to solve with either approach alone. Symbolic-numeric computation is used to solve problems such as the global optimization of functions and the numerical integration of differential equations.,
    <br>* Computer-aided proof: This subfield deals with the automation of mathematical proofs. Computer-aided proof is used to prove theorems in mathematics and to verify the correctness of computer programs.,
    <br>These are just some of the many subfields of computer algebra. The field is constantly evolving, and new subfields are being created all the time.",
    <br>[{2023-08-23 retrieved} https://bard.google.com/]
    <a class="clsHide" href="#idSCmpr002wptdsn"></a></p>
  <p id="idSCmpr002wptnam">name::
    <br>* McsEngl.sciComputer_algebra'whole-part-tree,
    <a class="clsHide" href="#idSCmpr002wptnam"></a></p>
  </section>
  </section>
</section>

<section id="idSCmpr009">
  <h1 id="idSCmpr009H1">sciCmpr.digital-disign
    <a class="clsHide" href="#idSCmpr009H1"></a></h1>
  <p id="idSCmpr009dsn">description::
    <br>"Overview of digital design:
    <br>Digital design is the process of creating electronic circuits that use two levels of voltage to represent data: high voltage (1) and low voltage (0). These circuits can be used to create a variety of devices, such as computers, electronic games, televisions, and automation systems.
    <br>
    <br>Digital design is divided into two main categories: **combinational circuits** and **sequential circuits**. Combinational circuits take data as input and return an output. Sequential circuits have state, which affects their output.
    <br>
    <br>**Combinational circuits**
    <br>Combinational circuits are the most basic digital circuits. They are made up of logic gates, which are devices that perform basic logical operations, such as AND, OR, XOR, and NOT. Combinational circuits can be used to create a variety of functions, such as calculators, logical analyzers, and controllers.
    <br>
    <br>**Sequential circuits**
    <br>Sequential circuits are more complex than combinational circuits. They have state, which affects their output. Sequential circuits can be used to create a variety of functions, such as memory, counters, and state machines.
    <br>
    <br>**Hardware description languages**
    <br>Hardware description languages (HDLs) are programming languages that are used to create models of digital circuits. These models can then be used to verify the implementation of a circuit in an integrated circuit (IC). The most popular HDLs are Verilog and VHDL.
    <br>
    <br>**Steps of digital design**
    <br>Digital design is a multi-step process. The basic steps are as follows:
    <br>
    <br>1. **Requirements development**
    <br>The first step is to understand the requirements of the circuit. This includes gathering information about the data that will enter the circuit, the data that will exit the circuit, and the functions that the circuit must perform.
    <br>
    <br>2. **Circuit design**
    <br>The second step is to design the circuit. This includes using logical functions and circuits to achieve the requirements of the circuit.
    <br>
    <br>3. **Circuit verification**
    <br>The third step is to verify the circuit to make sure it works correctly. This can be done using simulation software or by testing the circuit in a real system.
    <br>
    <br>4. **Circuit implementation**
    <br>The fourth step is to implement the circuit in an integrated circuit (IC). This can be done using a semiconductor manufacturing company.
    <br>
    <br>**Applications of digital design**
    <br>Digital design is used in a variety of applications, such as:
    <br>* Computers
    <br>* Electronic games
    <br>* Televisions
    <br>* Automation systems
    <br>* Control systems
    <br>* Communication systems
    <br>
    <br>Digital design is an important skill for engineers and scientists. Understanding the basic principles of digital design is essential for the development of new digital devices."
    <br>[{2023-10-20 retrieved} https://bard.google.com/chat/4e52bb74e0d91bde]
    <a class="clsHide" href="#idSCmpr009dsn"></a></p>
  <p id="idSCmpr009nam">name::
    <br>* McsEngl.digital-design,
    <br>* McsEngl.sciCmpr.009-digital-design,
    <br>* McsEngl.sciCmpr.digital-design,
    <br>====== langoGreek:
    <br>* McsElln.ψηφιακή-σχεδίαση,
    <a class="clsHide" href="#idSCmpr009nam"></a></p>
</section>

<section id="idSCmpr008">
  <h1 id="idSCmpr008H1">sciCmpr.quantum-computing
    <a class="clsHide" href="#idSCmpr008H1"></a></h1>
  <p id="idSCmpr008dsn">description::
    <br>"overview of quantum-computing:
    <br>Quantum computing is an exciting and rapidly evolving field of computer science that leverages the principles of quantum mechanics to perform certain types of computations far more efficiently than classical computers. Here's an overview of quantum computing:
    <br>
    <br>1. **Quantum Bits (Qubits):** The fundamental unit of quantum computing is the qubit. Unlike classical bits, which can be either 0 or 1, qubits can exist in a superposition of both 0 and 1 simultaneously. This property allows quantum computers to explore multiple solutions to a problem at once.
    <br>
    <br>2. **Entanglement:** Qubits can be entangled, meaning the state of one qubit is dependent on the state of another, even when they are physically separated. This property enables quantum computers to perform complex operations and algorithms that are not possible with classical bits.
    <br>
    <br>3. **Quantum Gates:** Quantum operations, or gates, are used to manipulate qubits in a quantum computer. These gates are responsible for performing various quantum operations like creating superpositions and entanglement.
    <br>
    <br>4. **Quantum Algorithms:** Quantum computers use quantum algorithms, which are designed to take advantage of the unique properties of qubits. One of the most famous quantum algorithms is Shor's algorithm, which can factor large numbers exponentially faster than the best-known classical algorithms, posing a potential threat to modern encryption schemes.
    <br>
    <br>5. **Quantum Speedup:** Quantum computers have the potential to solve certain problems much faster than classical computers. This includes tasks like factorization, database searching, optimization problems, and simulating quantum systems, which are particularly important in fields like chemistry and materials science.
    <br>
    <br>6. **Challenges:** Building and maintaining quantum computers is challenging due to issues such as qubit decoherence (loss of quantum information), error correction, and cooling requirements (qubits must be kept at extremely low temperatures). These challenges are actively being researched and addressed.
    <br>
    <br>7. **Applications:** Quantum computing has the potential to revolutionize various industries. Some potential applications include cryptography (both breaking and creating secure encryption methods), drug discovery, materials science, finance (portfolio optimization), artificial intelligence (for faster machine learning algorithms), and supply chain optimization, among others.
    <br>
    <br>8. **Current State:** As of my last knowledge update in September 2021, quantum computing is still in its infancy. Companies like IBM, Google, Microsoft, and startups like Rigetti are developing and offering access to quantum computers. Quantum supremacy, the point at which a quantum computer can perform a task faster than classical computers, has been achieved in specific cases, but practical, widespread use is still a work in progress.
    <br>
    <br>9. **Quantum Hardware:** Quantum computers come in different forms, including superconducting qubits, trapped ions, and topological qubits, each with its own advantages and challenges.
    <br>
    <br>10. **Quantum Software:** The quantum software ecosystem is growing, with programming languages and libraries (like Qiskit, Cirq, and others) allowing researchers and developers to write quantum algorithms and run them on available quantum hardware.
    <br>
    <br>Quantum computing holds immense promise, but it's important to note that it's not a replacement for classical computing. Instead, it complements classical computing for specific tasks. The field continues to advance, and its long-term impact on technology and science is still unfolding."
    <br>[{2023-10-20 retrieved} https://chat.openai.com/c/d37f2284-a8da-4d23-aa68-ae0092068e62]
    <a class="clsHide" href="#idSCmpr008dsn"></a></p>
  <p id="idSCmpr008nam">name::
    <br>* McsEngl.quantum-computing,
    <br>* McsEngl.sciCmpr.008-quantum-computing,
    <br>* McsEngl.sciCmpr.quantum-computing,
    <a class="clsHide" href="#idSCmpr008nam"></a></p>

  <section id="idSCmpr008logc">
  <h2 id="idSCmpr008logcH2">q-logic (<a class="clsPreview" href="../dirEdu/McsEdu000009.last.html#idSMind005Qntm">link</a>) of quantum-computing
    <a class="clsHide" href="#idSCmpr008logcH2"></a></h2>
  </section>

  <section id="idSCmpr008nnet">
  <h2 id="idSCmpr008nnetH2">neural-net (<a class="clsPreview" href="../dirTchInf/McsTchInf000036.last.html#idTchNnQntm">link</a>) of quantum-computing
    <a class="clsHide" href="#idSCmpr008nnetH2"></a></h2>
  </section>

  <section id="idSCmpr008evlg">
  <h2 id="idSCmpr008evlgH2">evoluting of quantum-computing
    <a class="clsHide" href="#idSCmpr008evlgH2"></a></h2>
  <p id="idSCmpr008evlgdsn">description::
    <br>"evolution of quantum-computing:
    <br>The evolution of quantum computing can be traced back to the early 1980s, when Richard Feynman and Yuri Manin independently proposed the idea of using quantum mechanics to perform computations. Feynman was motivated by the challenge of simulating quantum systems, which is intractable for classical computers. Manin was interested in the more general potential of quantum computing to solve problems that are intractable for classical computers, such as breaking modern encryption algorithms.
    <br>
    <br>In the following decade, there was a flurry of theoretical work on quantum computing, including the development of the first quantum algorithms, such as Deutsch's algorithm, Simon's algorithm, and Grover's algorithm. These algorithms demonstrated that quantum computers could potentially solve certain problems much faster than classical computers.
    <br>
    <br>In the late 1990s and early 2000s, experimentalists began to build the first small-scale quantum computers. These early machines were noisy and had a limited number of qubits, but they were capable of running simple quantum algorithms.
    <br>
    <br>Over the past decade, quantum computing has made significant progress. Quantum computers with hundreds of qubits have been built, and new quantum algorithms are being developed all the time. Quantum computers are not yet powerful enough to solve real-world problems, but they are approaching that point.
    <br>
    <br>Here is a timeline of some of the key milestones in the evolution of quantum computing:
    <br>* 1980: Paul Benioff introduces the quantum Turing machine, a theoretical model of a quantum computer.
    <br>* 1981: Richard Feynman gives a lecture on the potential of quantum computers to simulate quantum systems.
    <br>* 1982: Yuri Manin publishes a paper on the potential of quantum computers to solve problems that are intractable for classical computers.
    <br>* 1985: David Deutsch develops the Deutsch algorithm, the first quantum algorithm to demonstrate a speedup over classical algorithms.
    <br>* 1992: Lov Grover develops Grover's algorithm, a quantum algorithm for searching unsorted databases that is quadratically faster than the best classical algorithm.
    <br>* 1994: Peter Shor develops Shor's algorithm, a quantum algorithm for factoring large numbers that is exponentially faster than the best classical algorithm.
    <br>* 1998: The first experimental quantum computer is built by Isaac Chuang and Neil Gershenfeld at the Massachusetts Institute of Technology.
    <br>* 2011: D-Wave Systems releases the first commercial quantum computer.
    <br>* 2016: Google releases the Sycamore quantum computer, which is the first quantum computer to demonstrate quantum supremacy.
    <br>* 2022: IBM releases the Osprey quantum computer, which has 433 qubits.
    <br>
    <br>Quantum computing is still in its early stages of development, but it has the potential to revolutionize many fields, including medicine, materials science, and finance. Quantum computers could be used to develop new drugs, design new materials, and create new financial algorithms.
    <br>
    <br>Here are some of the challenges that still need to be overcome before quantum computers can be used to solve real-world problems:
    <br>* **Developing scalable quantum hardware:** Quantum computers are very difficult to build and scale up. Scientists are working on new technologies to build quantum computers with millions or even billions of qubits.
    <br>* **Developing robust quantum algorithms:** Quantum algorithms are sensitive to noise, so they need to be made more robust before they can be used to solve real-world problems.
    <br>* **Developing software tools for quantum computing:** There is a need to develop new software tools to make it easier to program and use quantum computers.
    <br>
    <br>Despite the challenges, quantum computing is a rapidly developing field with the potential to have a major impact on society."
    <br>[{2023-10-24 retrieved} https://bard.google.com/chat/bab08762bfae0b3f]
    <a class="clsHide" href="#idSCmpr008evlgdsn"></a></p>
  <p id="idSCmpr008evlgnam">name::
    <br>* McsEngl.evoluting-of-quantum-computing,
    <br>* McsEngl.quantum-computing'evoluting,
    <a class="clsHide" href="#idSCmpr008evlgnam"></a></p>
  </section>
</section>

<section id="idSCmpr010">
  <h1 id="idSCmpr010H1">sciCmpr.symbolic-computation
    <a class="clsHide" href="#idSCmpr010H1"></a></h1>
  <p id="idSCmpr010dsn">description::
    <br>"symbolic-computation overview:
    <br>Symbolic computation is a branch of computer science and mathematics that focuses on manipulating symbols, mathematical expressions, and abstract entities instead of dealing with specific numerical values. It allows computers to perform operations such as algebraic manipulation, calculus, logical reasoning, and more in a symbolic, rather than numeric, way. Here's an overview of symbolic computation:
    <br>
    <br>1. **Symbolic Expressions:** In symbolic computation, expressions are represented as symbolic entities. These can include variables, constants, functions, and operators. For example, "2x + 3y" is a symbolic expression, where "x" and "y" are variables.
    <br>
    <br>2. **Symbolic Manipulation:** The primary goal of symbolic computation is to manipulate these symbolic expressions. This includes operations like simplification, expansion, differentiation, integration, solving equations, and factoring. These operations are performed symbolically without evaluating specific numerical values.
    <br>
    <br>3. **Computer Algebra Systems (CAS):** Symbolic computation forms the basis for Computer Algebra Systems (CAS), software systems designed to perform symbolic mathematics. CAS tools, such as Mathematica, Maple, and Maxima, are widely used in fields like mathematics, physics, engineering, and computer science for complex symbolic calculations.
    <br>
    <br>4. **Mathematical Proof:** Symbolic computation is used in mathematical proof verification and theorem proving. By manipulating and simplifying mathematical expressions, it can assist in proving theorems, verifying conjectures, and solving mathematical problems.
    <br>
    <br>5. **Logic and Automated Reasoning:** Symbolic computation is applied to symbolic logic and automated reasoning. It can evaluate the truth value of logical statements, manipulate logical expressions, and assist in reasoning and rule-based systems.
    <br>
    <br>6. **Artificial Intelligence:** In AI, symbolic computation is used for knowledge representation and reasoning. It enables AI systems to work with abstract concepts, rules, and symbolic data to make intelligent decisions and solve problems.
    <br>
    <br>7. **Education:** Symbolic computation is valuable in educational settings for teaching mathematics, computer science, and logic. It provides a tool for students to explore and understand mathematical and logical concepts more deeply.
    <br>
    <br>8. **Natural Language Processing:** Symbolic computation can be used in natural language processing to understand and manipulate the meaning of language. It helps in tasks like semantic analysis, parsing, and language understanding.
    <br>
    <br>9. **Solving Complex Equations:** Symbolic computation allows for the solution of complex equations that may not have closed-form solutions. It can provide solutions in symbolic form, which can be very useful for further analysis.
    <br>
    <br>10. **Scientific Research:** Symbolic computation is applied in various scientific fields, including physics, chemistry, and biology. Researchers use it to analyze and solve complex mathematical models and equations.
    <br>
    <br>11. **Mathematical Symbolism:** Symbolic computation enables the use of mathematical symbolism in problem-solving. It allows mathematical equations and concepts to be expressed in a concise, formal manner.
    <br>
    <br>Symbolic computation is a powerful tool for various fields where abstract mathematical and logical reasoning is crucial. It provides a means to work with mathematical and logical concepts in a more general and versatile way than traditional numerical computations, making it an indispensable part of many disciplines."
    <br>[{2023-10-22 retrieved} https://chat.openai.com/c/09dd80a8-5a1a-4d39-8229-d657640ec460]
    <a class="clsHide" href="#idSCmpr010dsn"></a></p>
  <p id="idSCmpr010nam">name::
    <br>* McsEngl.sciCmpr.010-symbolic-computation,
    <br>* McsEngl.sciCmpr.symbolic-computation,
    <br>* McsEngl.symbolic-computation,
    <a class="clsHide" href="#idSCmpr010nam"></a></p>
</section>

<section id="idMeta">
  <h1 id="idMetaH1">meta-info
    <a class="clsHide" href="#idMetaH1"></a></h1>
  <p id="idMetaCounter" class="clsCenter">this page was-visited
    <span class="clsColorRed">
    <script src="../../dirPgm/dirCntr/counter.php?page=McsEdu000007"></script>
    </span>
    times since {2023-08-22}</p>
  <!-- the content of page-path paragraph is displayed as it is on top of toc -->
  <p id="idMetaWebpage_path"><span class="clsB clsColorGreen">page-wholepath</span>:
    <a class="clsPreview" href="../../#idOverview">synagonism.net</a> /
    <a class="clsPreview" href="../Mcs000000.last.html#idOverview">worldviewSngo</a> /
    <a class="clsPreview" href="../dirEdu/McsEdu000000.last.html#idOverview">dirEdu</a> /
    sciCmpr
    </p>
  <p id="idMetaP1">SEARCH::
    <br>· this page uses '<span class="clsColorRed">locator-names</span>', names that when you find them, you find the-LOCATION of the-concept they denote.
    <br>⊛ <strong>GLOBAL-SEARCH</strong>:
    <br>· clicking on <span class="clsColorGreenBg">the-green-BAR of a-page</span> you have access to the-global--locator-names of my-site.
    <br>· use the-prefix '<span class="clsColorRed">sciCmpr</span>' for <a class="clsPreview" href="../dirCor/McsCor000002.last.html#idOverview">senso-concepts</a> related to current concept 'science.computer'.
    <br>⊛ <strong>LOCAL-SEARCH</strong>:
    <br>· TYPE <span class="clsColorRed">CTRL+F "McsLag4.words-of-concept's-name"</span>, to go to the-LOCATION of the-concept.
    <br>· a-preview of the-description of a-global-name makes reading fast.
    <a class="clsHide" href="#idMetaP1"></a></p>
  <p id="idFooterP1">footer::
    <br>• author: <a class="clsPreview" href="../dirHmn/McsHmn000003.last.html#idOverview">Kaseluris.Nikos.1959</a>
    <br>• email:
    <br> &nbsp;<img src="../../dirRsc/dirImg/mail.png">
    <br>• edit on github: https://github.com/synagonism/McsWorld/blob/master/dirMcs/dirEdu/McsEdu000007.last.html,
    <br>• comments on <a class="clsPreview" href="../dirEdu/McsEdu000000.last.html#idComment">Disqus</a>,
    <br>• twitter: <a href="https://twitter.com/synagonism">@synagonism</a>,
    <a class="clsHide" href="#idFooterP1"></a></p>
  <p id="idMetaVersion">webpage-versions::
    <br>• version.last.dynamic: <a lass="clsPreview" href="McsEdu000007.last.html">McsEdu000007.last.html</a>,
    <br>• version.draft.creation: McsEdu000007.0-1-0.2023-08-22.last.html,
    <a class="clsHide" href="#idMetaVersion"></a></p>
</section>

<section id="idSupport">
  <h1 id="idSupportH1">support (<a class="clsPreview" href="../../#idSupport">link</a>)</h1>
  <p></p>
</section>

<script type="module">
  import * as omMcsh from '../Mcsmgr/mMcsh.js'
</script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-N8T0MHWLS1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-N8T0MHWLS1');
</script>
<!--   -->
</body>
</html>